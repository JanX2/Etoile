#include "IoState.h"
#include "IoObject.h"

void IoVMCodeInit(IoState *self, IoObject *context)
{
	char *s;

	s = "Object do(\n"
  	"	thisMessage := method(\n"
  	"		writeln(call message label, \":\", \n"
  	"			call message lineNumber, \" \", \n"
  	"			call message name, \" deprecated - use 'call message'\\n\\n\"); \n"
  	"		nil\n"
  	"	)\n"
  	"	thisBlock   := method(Exception raise(\"deprecated method\"))\n"
  	"	thisTarget  := method(Exception raise(\"deprecated method\"))\n"
  	"	sender      := method(Exception raise(\"deprecated method\"))\n"
  	")\n"
  	"\n"
  	"List do(\n"
  	"	select := method(\n"
  	"     	aList := List clone\n"
  	"\n"
  	"     	a1 := call argAt(0) \n"
  	" 		if(a1 == nil, \n"
  	" 			//writeln(\"List select missing arg\"); \n"
  	" 			Exception raise(\"missing argument\")\n"
  	" 			//writeln(\"List select missing arg done\");\n"
  	" 			return \n"
  	" 		)\n"
  	"    	a2 := call argAt(1) \n"
  	"     	a3 := call argAt(2)\n"
  	"     	\n"
  	"     	if(a3,\n"
  	"     		a1 := a1 name\n"
  	"     		a2 := a2 name\n"
  	"			self foreach(i, v, \n"
  	"				call sender setSlot(a1, i)\n"
  	"				call sender setSlot(a2, getSlot(\"v\"))\n"
  	"     			//call sender doMessage(a3) ifTrue(aList append(getSlot(\"v\")))\n"
  	"     			if(a3 doInContext(call sender, call sender), aList append(getSlot(\"v\")))\n"
  	"			)\n"
  	"			return aList\n"
  	"     	)\n"
  	"     	\n"
  	"     	if(a2,\n"
  	"     		a1 := a1 name\n"
  	"			self foreach(v, \n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"     			//call sender doMessage(a2) ifTrue(aList append(getSlot(\"v\")))\n"
  	"     			if(a2 doInContext(call sender, call sender), aList append(getSlot(\"v\")))\n"
  	"			)\n"
  	"			return aList     	\n"
  	"     	)\n"
  	"     	\n"
  	"     	self foreach(v, \n"
  	"			//getSlot(\"v\") doMessage(a1, call sender) ifTrue(aList append(getSlot(\"v\")))\n"
  	"     		if(a1 doInContext(getSlot(\"v\"), call sender), aList append(getSlot(\"v\")))\n"
  	"     	)\n"
  	"     	aList     	\n"
  	"	)\n"
  	"	\n"
  	"	detect := method(\n"
  	"     	a1 := call argAt(0) \n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"     	a2 := call argAt(1) \n"
  	"     	a3 := call argAt(2)\n"
  	"     	\n"
  	"     	if(a3,\n"
  	"     		a1 := a1 name\n"
  	"     		a2 := a2 name\n"
  	"			self foreach(i, v, \n"
  	"				call sender setSlot(a1, i)\n"
  	"				call sender setSlot(a2, getSlot(\"v\"))\n"
  	"				if(call sender doMessage(a3), return getSlot(\"v\"))\n"
  	"			)\n"
  	"			return nil\n"
  	"     	)\n"
  	"     	\n"
  	"     	if(a2,\n"
  	"     		a1 := a1 name\n"
  	"			self foreach(v, \n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				if(call sender doMessage(a2), return getSlot(\"v\"))\n"
  	"			)\n"
  	"			return nil     	\n"
  	"     	)\n"
  	"     	\n"
  	"     	self foreach(v, if(getSlot(\"v\") doMessage(a1, call sender), return getSlot(\"v\"))\n"
  	"     	)\n"
  	"     	nil     	\n"
  	"	)\n"
  	"\n"
  	"	map := method(\n"
  	"		aList := List clone\n"
  	"		\n"
  	"     	a1 := call argAt(0) \n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"     	a2 := call argAt(1) \n"
  	"     	a3 := call argAt(2)\n"
  	"     	\n"
  	"     	if(a2 == nil,\n"
  	"			self foreach(v, \n"
  	"				aList append(getSlot(\"v\") doMessage(a1, call sender))\n"
  	"     		)\n"
  	"     		return aList\n"
  	"     	)\n"
  	"\n"
  	"     	if(a3 == nil,\n"
  	"     		a1 := a1 name\n"
  	"			self foreach(v, \n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				aList append(call sender doMessage(a2))\n"
  	"			)\n"
  	"			return aList     	\n"
  	"     	)\n"
  	"     	     	\n"
  	"		a1 := a1 name\n"
  	"		a2 := a2 name\n"
  	"		self foreach(i, v, \n"
  	"			call sender setSlot(a1, i)\n"
  	"			call sender setSlot(a2, getSlot(\"v\"))\n"
  	"			aList append(call sender doMessage(a3))\n"
  	"		)\n"
  	"		return aList     	\n"
  	"	)\n"
  	"	\n"
  	"	copy := method(v, self empty; self appendSeq(v); self)\n"
  	"	\n"
  	"	mapInPlace := method(\n"
  	"		self copy(self getSlot(\"map\") performOn(self, call sender, call message))\n"
  	"	)\n"
  	"	\n"
  	"	selectInPlace := method(\n"
  	"		self copy(self getSlot(\"select\") performOn(self, call sender, call message))\n"
  	"	)  \n"
  	"	\n"
  	"	empty := method(self removeAll)\n"
  	"\n"
  	"  sort := method(self clone sortInPlace)\n"
  	"  sortBy := method(b, self clone sortInPlaceBy(getSlot(\"b\")))\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/A0_List.io");

	s = "/*\n"
  	"nil ioDoc(\n"
  	"  docCopyright(\"Steve Dekorte\", 2002)\n"
  	"  docLicense(\"BSD revised\")\n"
  	"  docObject(\"nil\")\n"
  	"  docDescription(\"nil is a singleton object that is used as a placeholder and to mean false in Io.\")\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"     docSlot(\"clone\", \"returns self since nil is a singleton.\")\n"
  	"	clone := nil\n"
  	"\n"
  	"	docSlot(\"and(expression)\", \"Returns nil without evaluating expression.\")\n"
  	"	setSlot(\"and\", nil)\n"
  	"\n"
  	"	elseif := Object getSlot(\"if\")\n"
  	"\n"
  	"	docSlot(\"then(expression)\", \"Returns nil without evaluating expression.\")\n"
  	"	setSlot(\"then\", nil)\n"
  	"\n"
  	"	docSlot(\"else(expression)\", \"Returns nil without evaluating expression.\")\n"
  	"	setSlot(\"else\", method(v, v))\n"
  	"\n"
  	"	docSlot(\"or(anObject)\", \"Returns anObject if anObject is not nil. Otherwise returns nil.\")\n"
  	"	setSlot(\"or\", method(v, if(v, v, nil)))\n"
  	"\n"
  	"	docSlot(\"print\", \"Prints 'nil'. Returns self.\")\n"
  	"	print := method(write(\"nil\"))\n"
  	"\n"
  	"	setSlot(\"==\", method(v, self uniqueId == v uniqueId))\n"
  	"	setSlot(\"!=\", method(v, self uniqueId != v uniqueId))\n"
  	"\n"
  	"	docSlot(\"isNil\", \"Returns Lobby.\")\n"
  	"	isNil := Lobby\n"
  	"\n"
  	"	docSlot(\"ifNil(expression)\", \"Evaluates message.\")\n"
  	"	ifNil := method(v, v)  \n"
  	")\n"
  	"*/\n"
  	"\n"
  	"// if(a == 1) then(b) elseif(b == c) then(d) else(f)\n"
  	"// (a == 1) ifTrue(b) ifFalse(c)\n"
  	"\n"
  	"true do(\n"
  	"	then    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"	elseif  := true\n"
  	"	else    := true\n"
  	"	ifTrue  := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	ifFalse := true\n"
  	"	setSlot(\"and\", Object getSlot(\"evalArg\"))\n"
  	"	setSlot(\"or\", true)\n"
  	"	asString := \"true\"\n"
  	"	asSimpleString := \"true\"\n"
  	"	not := false\n"
  	"	clone := true\n"
  	")\n"
  	"\n"
  	"false do(\n"
  	"	then    := false\n"
  	"	elseif  := Object getSlot(\"if\")\n"
  	"	else    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"	ifTrue  := false\n"
  	"	ifFalse := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	setSlot(\"and\", false)\n"
  	"	setSlot(\"or\", Object getSlot(\"evalArg\"))\n"
  	"	\n"
  	"	type := \"false\"\n"
  	"	asString := \"false\"\n"
  	"	asSimpleString := \"false\"\n"
  	"	not := true\n"
  	"	clone := false\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	isNil := true\n"
  	"	\n"
  	"	ifNonNil := Object getSlot(\"thisContext\")\n"
  	"	ifNil := method(call evalArgAt(0); getSlot(\"self\"))\n"
  	"	\n"
  	"	ifNilEval    := Object getSlot(\"evalArg\")\n"
  	"	ifNonNilEval := Object getSlot(\"thisContext\")	\n"
  	"	\n"
  	"	type := \"nil\"\n"
  	"	asString := \"nil\"\n"
  	"	asSimpleString := \"nil\"\n"
  	"	\n"
  	"	setSlot(\"and\", false)\n"
  	"	setSlot(\"or\", Object getSlot(\"evalArg\"))\n"
  	"	then := nil\n"
  	"	else := nil\n"
  	"	elseif := nil\n"
  	"	clone := nil\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	isNil := false\n"
  	"	\n"
  	"	ifNil := Object getSlot(\"thisContext\")\n"
  	"	ifNonNil := method(call evalArgAt(0); getSlot(\"self\"))\n"
  	"	\n"
  	"	ifNonNilEval := Object getSlot(\"evalArg\")\n"
  	"	ifNilEval    := Object getSlot(\"thisContext\")	\n"
  	"	\n"
  	"	setSlot(\"and\", Object getSlot(\"evalArg\"))\n"
  	"	setSlot(\"or\", true)\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"    makeFirstCharacterLowercase := method(\n"
  	"	   if(self size > 0, self atPut(0, self at(0) asLowercase))\n"
  	"    )\n"
  	"\n"
  	"    makeFirstCharacterUppercase := method(\n"
  	"	   if(self size > 0, self atPut(0, self at(0) asUppercase))\n"
  	"    )\n"
  	"\n"
  	"    slicesBetween := method(startSeq, endSeq,\n"
  	"        chunks := List clone\n"
  	"        lastIndex := 0\n"
  	"        while (startIndex := self findSeq(startSeq, lastIndex),\n"
  	"            endIndex := self findSeq(endSeq, startIndex + startSeq size)\n"
  	"            endIndex ifNil(break)\n"
  	"            chunks append(self slice(startIndex + startSeq size, endIndex))\n"
  	"            lastIndex := endIndex + endSeq size\n"
  	"        )\n"
  	"        chunks\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"    hasSlot := method(n,\n"
  	"        getSlot(\"self\") hasLocalSlot(n) or(getSlot(\"self\") ancestorWithSlot(n) != nil)\n"
  	"    )\n"
  	"\n"
  	"    docsSlot := method(\n"
  	"	   if(getSlot(\"self\") hasLocalSlot(\"docs\"), \n"
  	"	   getSlot(\"self\") docs, \n"
  	"	   getSlot(\"self\") docs := Object clone do(slots := Object clone)\n"
  	"	   )\n"
  	"    )\n"
  	"    \n"
  	"    docSlot := method(k, v, \n"
  	"        entry := Object clone \n"
  	"        entry description := v asSymbol\n"
  	"        if (k containsSeq(\"(\"), \n"
  	"            entry args := k afterSeq(\"(\") beforeSeq(\")\") split(\",\") map(strip)\n"
  	"        )	\n"
  	"        getSlot(\"self\") docsSlot slots setSlot(k beforeSeq(\"(\"), entry)\n"
  	"    \n"
  	"        //self docsSlot slots setSlot(k beforeSeq(\"(\"), v)\n"
  	"        //writeln(\"docSlot(\", k, \", \", self docsSlot slots getSlot(k), \")\")\n"
  	"    )\n"
  	"    \n"
  	"    docCopyright := method(v, \n"
  	"	   k := call message name asMutable removePrefix(\"doc\") makeFirstCharacterLowercase\n"
  	"	   getSlot(\"self\") docsSlot setSlot(k, v)\n"
  	"    )\n"
  	"    \n"
  	"    docLicense := getSlot(\"docCopyright\")\n"
  	"    docObject := getSlot(\"docCopyright\")\n"
  	"    docDescription := getSlot(\"docCopyright\")\n"
  	"    docCredits := getSlot(\"docCopyright\")\n"
  	"    docInclude := getSlot(\"docCopyright\")\n"
  	"    docDependsOn := getSlot(\"docCopyright\")\n"
  	"    docCategory := getSlot(\"docCopyright\")\n"
  	"\n"
  	"    ioDoc := method(\n"
  	"	   //docsSlot\n"
  	"	   if(call argAt(0), getSlot(\"self\") doMessage(call argAt(0)))\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"eval(...)\", \"Performs the argument (in the same manner as do() ) and returns the result. \")\n"
  	"    eval := method(self doMessage(call argAt(0)))\n"
  	"    \n"
  	"    docSlot(\"list(...)\", \"Returns a List containing the arguments.\")\n"
  	"    list := method(call message argsEvaluatedIn(call sender))\n"
  	"    \n"
  	"    docSlot(\"..(arg)\", \".. is an alias for: method(arg, self asString append(arg asString))\")\n"
  	"    setSlot(\"..\", method(arg, getSlot(\"self\") asString .. arg asString))\n"
  	"    \n"
  	"    slotSummary := method(\n"
  	"    	if(getSlot(\"self\") type == \"Block\", return getSlot(\"self\") asSimpleString)\n"
  	"    	s := Sequence clone\n"
  	"    	s appendSeq(\" \", getSlot(\"self\") asSimpleString, \":\\n\")\n"
  	"	names := getSlot(\"self\") slotNames\n"
  	"	if(slotsToEval := getSlot(\"self\") ?slotSummaryEvalSlotNames,\n"
  	"		slotsToEval = slotsToEval clone removeSeq(names)\n"
  	"		names appendSeq(slotsToEval)\n"
  	"	,\n"
  	"		slotsToEval = list\n"
  	"	)\n"
  	"    	names sortInPlace foreach(slotName,\n"
  	"		if(slotsToEval contains(slotName),\n"
  	"			if(e := try(x := getSlot(\"self\") perform(slotName)),\n"
  	"				valueString := \"Error: \" .. e error\n"
  	"			,\n"
  	"				valueString := getSlot(\"x\") asSimpleString\n"
  	"			)\n"
  	"		,\n"
  	"			valueString := getSlot(\"self\") getSlot(slotName) asSimpleString\n"
  	"		)\n"
  	"                s appendSeq(\"  \", slotName alignLeft(16), \" = \", valueString ifNilEval(\"?\"), \"\\n\")\n"
  	"    	)\n"
  	"    	s\n"
  	"    )\n"
  	"    \n"
  	"    asString := getSlot(\"slotSummary\")\n"
  	"    \n"
  	"    //asSimpleString := method(getSlot(\"self\") type)\n"
  	"    asSimpleString := method(getSlot(\"self\") type .. \"_\" .. getSlot(\"self\") uniqueHexId)\n"
  	"    \n"
  	"    docSlot(\"newSlot(slotName, aValue)\", \n"
  	"    \"\"\"Creates a getter and setter for the slot with the name slotName \n"
  	"    and sets it's default the value aValue. Returns self. For example, \n"
  	"    newSlot(\"foo\", 1) would create slot named foo with the value 1 as well as a setter method setFoo().\"\"\")\n"
  	"\n"
  	"    newSlot := method(name, value, doc,\n"
  	"		self setSlot(name, value)\n"
  	"		self setSlot(\"set\" .. name asCapitalized, \n"
  	"			doString(\"method(\" .. name .. \" = call evalArgAt(0); self)\"))\n"
  	"			if(doc, self docSlot(name, doc))\n"
  	"		value\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"launchFile(pathString)\", \n"
  	"    \"Eval file at pathString as if from the command line in it's folder.\")\n"
  	"    \n"
  	"    launchFile := method(path, args,\n"
  	"        args ifNil(args = List clone)\n"
  	"        Lobby args := args\n"
  	"        Lobby launchPath :=  path pathComponent\n"
  	"        Directory setCurrentWorkingDirectory(Lobby launchPath)\n"
  	"        self doFile(path)\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"println\", \"Same as print, but also prints a new line. Returns self.\")\n"
  	"    println := method(self print; write(\"\\n\"); self)\n"
  	"\n"
  	"    docSlot(\"?(aMessage)\", \"\"\"\n"
  	"    description: Sends the message aMessage to the receiver if it can respond to it. Example:\n"
  	"    <pre>\n"
  	"    MyObject test // performs test\n"
  	"    MyObject ?test // performs test if MyObject has a slot named test\n"
  	"    </pre>\n"
  	"    The search for the slot only follows the receivers proto chain. \n"
  	"    \"\"\")\n"
  	"\n"
  	"    setSlot(\"?\", method(\n"
  	"	   m := call argAt(0)\n"
  	"	   if (self getSlot(m name) != nil, self doMessage(m, call sender), nil)\n"
  	"    ))\n"
  	"\n"
  	"    docSlot(\"ancestors\", \n"
  	"    \"Returns a list of all of the receiver's ancestors as found by recursively following the protos links.\") \n"
  	"\n"
  	"    ancestors := method(a, \n"
  	"        if(a, if(a contains(self), return a), a = List clone) \n"
  	"        a append(self)\n"
  	"        self protos foreach(p, p ancestors(a))\n"
  	"        a\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"isKindOf(anObject)\", \"Returns true if anObject is in the receiver's ancestors.\") \n"
  	"\n"
  	"    isKindOf := method(anObject, self ancestors contains(anObject))\n"
  	"    \n"
  	"    docSlot(\"super(aMessage)\", \n"
  	"    \"\"\"Sends the message aMessage to the receiver's proto with the context of self. Example:\n"
  	"    <pre>\n"
  	"    self test(1, 2)   // performs test(1, 2) on self\n"
  	"    super(test(1, 2)) // performs test(1, 2) on self proto but with the context of self\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"\n"
  	"  setSlot(\"super\", method(\n"
  	"	senderSlotContext := call sender call slotContext\n"
  	"	m := call argAt(0)\n"
  	"	m ifNil(Exception raise(\"Object super requires an argument\"))\n"
  	"	senderSlotContext ifNil(Exception raise(\"Object super called outside of block context\"))\n"
  	"	slotName := m name\n"
  	"	ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"        if(ancestor == nil,\n"
  	"            slotName = \"forward\"\n"
  	"            ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"        )\n"
  	"	if(ancestor uniqueId == senderSlotContext uniqueId, Exception raise(\"Object super slot \" .. slotName .. \" not found\"))\n"
  	"	b := ancestor getSlot(slotName) \n"
  	"	if(getSlot(\"b\") type != \"Block\", b, getSlot(\"b\") performOn(call sender getSlot(\"self\"), call sender, m, ancestor))\n"
  	"))\n"
  	"\n"
  	"    docSlot(\"resend\", \n"
  	"    \"\"\"Send the message used to activate the current method to the Object's proto.\n"
  	"    For example;\n"
  	"    <pre>\n"
  	"    Dog := Mammal clone do(\n"
  	"	init := method(\n"
  	"	    resend\n"
  	"	)\n"
  	"    )\n"
  	"    </pre>\n"
  	"    calling Dog init will send an init method to Mammal, but using the Dog's context.\n"
  	"    \"\"\")\n"
  	"\n"
  	"	setSlot(\"resend\", method(\n"
  	"		senderSlotContext := call sender call slotContext\n"
  	"		senderSlotContext ifNil(Exception raise(\"Object resend called outside of block context\"))\n"
  	"		m := call sender call message\n"
  	"		slotName := m name\n"
  	"		ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"			if(ancestor == nil,\n"
  	"				slotName = \"forward\"\n"
  	"				ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"			)\n"
  	"	\n"
  	"			if(ancestor uniqueId == senderSlotContext uniqueId,\n"
  	"				Exception raise(\"Object resend slot \" .. slotName .. \" not found\")\n"
  	"			)\n"
  	"			ancestor getSlot(slotName) performOn(call sender getSlot(\"self\"), call sender, m, ancestor)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"\n"
  	"    docSlot(\"list(...)\", \"Returns a List containing the arguments.\")\n"
  	"    list := method(call message argsEvaluatedIn(call sender))\n"
  	"\n"
  	"    Object print := method(write(getSlot(\"self\") asString))\n"
  	"\n"
  	"    docSlot(\"println\", \"Same as print, but also prints a new line. Returns self.\")\n"
  	"    println := method(getSlot(\"self\") print; write(\"\\n\"); getSlot(\"self\"))\n"
  	"\n"
  	"    docSlot(\"in(aList)\", \"Same as: aList contains(self)\")\n"
  	"    in := method(aList, aList contains(self)) \n"
  	"\n"
  	"	uniqueHexId := method(\"0x\" .. getSlot(\"self\") uniqueId asString toBase(16))\n"
  	"	\n"
  	"	lazySlot := method(name,\n"
  	"		m := ((\"self setSlot(\\\"\" .. name .. \"\\\", \" .. call message argAt(1) code .. \")\") asMessage)\n"
  	"        self setSlot(name, method(1) setMessage(m))\n"
  	"        nil\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/A1_Object.io");

	s = "\n"
  	"List do(\n"
  	"    docSlot(\"sum\", \"Returns the sum of the items.\")\n"
  	"    sum := method(s := 0; self foreach(v, s = s + v); s)\n"
  	"\n"
  	"    docSlot(\"average\", \"Returns the average of the items.\")\n"
  	"    average := method(self sum / self size)\n"
  	"\n"
  	"    docSlot(\"shuffle\", \"Randomizes the order of the elements in the receiver. Returns self.\")\n"
  	"    shuffle := method(for(i, 0, size - 1, swapIndices(i, Random value(i, size) floor)))\n"
  	"\n"
  	"    docSlot(\"anyOne\", \"Returns a random element of the receiver or nil if the receiver is empty.\")\n"
  	"    anyOne := method(at(Random value(0, size) floor))\n"
  	" \n"
  	"    docSlot(\"removeFirst\", \"Returns the first item and removes it from the list. nil is returned if the list is empty.\")\n"
  	"    removeFirst := method(if(self size != 0, removeAt(0), nil))\n"
  	"\n"
  	"    docSlot(\"removeLast\", \"Returns the last item and removes it from the list. nil is returned if the list is empty.\")\n"
  	"    removeLast := method(self pop)\n"
  	"\n"
  	"    docSlot(\"removeSeq\", \"Removes each of the items from the current list which are contained in the sequence passed in.\")\n"
  	"    removeSeq := method(seq,\n"
  	"	    seq foreach(x, self remove(x))\n"
  	"	    self\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"join(optionalString)\", \"Returns a Sequence of the concatenated items with optionalString between each item or simply the concatenation of the items if no optionalString is supplied.\")\n"
  	"    join := method(arg,\n"
  	"		s := Sequence clone\n"
  	"		if(arg) then(\n"
  	"			max := self size - 1\n"
  	"			self foreach(i, v, s appendSeq(v); if(i != max, s appendSeq(arg)))\n"
  	"		) else(\n"
  	"			self foreach(v, s appendSeq(v))\n"
  	"		)\n"
  	"		s\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"insertAfter(item, afterItem)\", \"Inserts item after first occurance of afterItem and returns self. If afterItem is not found, item is appended to the end of the list.\")\n"
  	"    insertAfter := method(item, afterItem,\n"
  	"       i := self indexOf(afterItem) \n"
  	"       if(i, self atInsert(i + 1, item), self append(item))\n"
  	"       self\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"insertBefore(item, beforeItem)\", \"Inserts item before first occurance of beforeItem or to the end of the list if beforeItem is not found. Returns self.\")\n"
  	"    insertBefore := method(item, beforeItem,\n"
  	"       i := self indexOf(beforeItem)\n"
  	"       if(i, self atInsert(i, item), self append(item))\n"
  	"       self\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"insertAt(item, index)\", \"Inserts item at the specified index. Raises an exception if the index is out of bounds. Returns self.\")\n"
  	"    insertAt := method(item, index, self atInsert(index, item))\n"
  	"    \n"
  	"    asString := method(\n"
  	"    	s := \"list(\" asMutable\n"
  	"    	self foreach(i, v, \n"
  	"    		s appendSeq(getSlot(\"v\") asSimpleString)\n"
  	"    		if (i != self size - 1, s appendSeq(\", \"))\n"
  	"    	)\n"
  	"     	s appendSeq(\")\")\n"
  	"     )\n"
  	"     \n"
  	"     max := method(\n"
  	"     	m := call argAt(0) \n"
  	"     	obj := self first\n"
  	"     	self foreach(o, \n"
  	"     		v1 := if(m, o doMessage(m, call sender), o)\n"
  	"     		v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"     		if(v1 > v2, obj := o)\n"
  	"     	)\n"
  	"     	obj\n"
  	"     )\n"
  	"     \n"
  	"     min := method(\n"
  	"     	m := call argAt(0) \n"
  	"     	obj := self first\n"
  	"     	self foreach(o, \n"
  	"     		v1 := if(m, o doMessage(m, call sender), o)\n"
  	"     		v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"     		if(v1 < v2, obj := o)\n"
  	"     	)\n"
  	"     	obj\n"
  	"     )\n"
  	"     \n"
  	"  docSlot(\"flatten\", \"\"\"Creates a new list, with all contained lists flattened into the new list. For example:\n"
  	"<pre>\n"
  	"list(1,2,list(3,4,list(5))) flatten\n"
  	"==> list(1, 2, 3, 4, 5)\n"
  	"</pre>\n"
  	"  \"\"\")\n"
  	"  List flatten := method(\n"
  	"    l := List clone\n"
  	"    self foreach(v,\n"
  	"      if(getSlot(\"v\") type == \"List\",\n"
  	"        l appendSeq(getSlot(\"v\") flatten)\n"
  	"      ,\n"
  	"        l append(getSlot(\"v\")))\n"
  	"      )\n"
  	"    l\n"
  	"  )\n"
  	"     \n"
  	"	docSlot(\"select(optionalIndex, value, message)\", \n"
  	"		   \"Like foreach, but the values for which the result of \n"
  	"message are non-Nil are returned in a new List. Example:\n"
  	"<pre>list(1, 5, 7, 2) select(i, v, v > 3) print\n"
  	"==> 5, 7\n"
  	"\n"
  	"list(1, 5, 7, 2) select(v, v > 3) print\n"
  	"==> 5, 7</pre>\")     \n"
  	"     \n"
  	"	docSlot(\"detect(optionalIndex, value, message)\", \n"
  	"		   \"Returns the first value for which the message evaluates to a non-Nil. Example:\n"
  	"<pre>list(1, 2, 3, 4) detect(i, v, v > 2)\n"
  	"==> 3\n"
  	"\n"
  	"list(1, 2, 3, 4) detect(v, v > 2)\n"
  	"==> 3</pre>\")\n"
  	"\n"
  	"	docSlot(\"map(optionalIndex, value, message)\", \"Same as calling mapInPlace() on a clone of the receiver, but more efficient.\")\n"
  	"	\n"
  	"	docSlot(\"cusor\", \"Returns a ListCursor for the receiver.\")\n"
  	"	cursor := method(ListCursor clone setCollection(self)) \n"
  	")\n"
  	"\n"
  	"ListCursor := Object clone do(\n"
  	"	newSlot(\"index\", 0)\n"
  	"	newSlot(\"collection\")\n"
  	"	next := method(index = index + 1; if(index > (collection size - 1), index = collection size - 1))\n"
  	"	previous := method(index = index - 1; if(index < 0, index = 0))\n"
  	"	value := method(collection at(index))\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/A2_List.io");

	s = "Sequence do(\n"
  	"	docSlot(\"repeated(aNumber)\", \"Returns a new sequence containing the receiver repeated aNumber number of times.\")\n"
  	"	repeated := method(n,\n"
  	"		s := Sequence clone\n"
  	"		for(i, 0, n, s appendSeq(self))\n"
  	"		s \n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Call do(\n"
  	"	docSlot(\"description\", \"Returns a description of the receiver as a String.\")\n"
  	"\n"
  	"	description := method(\n"
  	"		m := self message\n"
  	"		s := self target type .. \" \" .. m name\n"
  	"		s .. \" \" repeated(s size - 35) .. m label lastPathComponent .. \" \" .. m lineNumber	\n"
  	"	)\n"
  	"\n"
  	"	delegateTo := method(target, altSender,\n"
  	"		target doMessage(self message clone setNext setAttached, altSender ifNilEval(self sender))\n"
  	"	)\n"
  	"\n"
  	"        delegateToMethod := method(target, methodName,\n"
  	"                target doMessage(self message clone setNext setAttached setName(methodName), self sender)\n"
  	"        )\n"
  	"\n"
  	"	evalArgs := method(\n"
  	"		self message argsEvaluatedIn(sender)\n"
  	"	)\n"
  	"\n"
  	"        hasArgs := method(\n"
  	"                argCount > 0\n"
  	"        )\n"
  	"\n"
  	"        argCount := method(\n"
  	"                self message arguments size\n"
  	"        )\n"
  	")\n"
  	"\n"
  	"Message description := method(\n"
  	"	self name .. \" \" repeated(self name size - 35) .. self label lastPathComponent .. \" \" .. self lineNumber	\n"
  	")\n"
  	"	\n"
  	"FifoQueue := List clone do(pop := method(self removeFirst)) // not efficient\n"
  	"\n"
  	"Scheduler := Object clone do(\n"
  	"	newSlot(\"yieldingCoros\", FifoQueue clone)\n"
  	"	newSlot(\"timers\", FifoQueue clone)\n"
  	"	currentCoroutine := method(Coroutine currentCoroutine)\n"
  	")\n"
  	"\n"
  	"Coroutine do(\n"
  	"	type := \"Coroutine\"\n"
  	"	newSlot(\"exception\", nil)\n"
  	"	newSlot(\"parentCoroutine\", nil)\n"
  	"	newSlot(\"runTarget\", nil)\n"
  	"	newSlot(\"runLocals\", nil)\n"
  	"	newSlot(\"runMessage\", nil)\n"
  	"	newSlot(\"result\", nil)\n"
  	"	newSlot(\"label\", \"\")\n"
  	"	newSlot(\"inException\", false)\n"
  	"	\n"
  	"	newSlot(\"yieldingCoros\", List clone)\n"
  	"	\n"
  	"	label := method(self uniqueId)\n"
  	"	\n"
  	"	showYielding := method(s,\n"
  	"		writeln(\"   \", label, \" \", s)\n"
  	"		yieldingCoros foreach(v, writeln(\"    \", v uniqueId))\n"
  	"	)\n"
  	"	\n"
  	"	resumeLater := method(\n"
  	"		yieldingCoros atInsert(0, self)\n"
  	"	)\n"
  	"\n"
  	"	yield := method(\n"
  	"		//showYielding(\"yield\")\n"
  	"		//writeln(\"Coro \", self uniqueId, \" yielding - yieldingCoros = \", yieldingCoros size)\n"
  	"		yieldingCoros remove(self)\n"
  	"		yieldingCoros atInsert(0, self)\n"
  	"		next := yieldingCoros pop \n"
  	"		//writeln(\"Coro \", next uniqueId, \" resume\")\n"
  	"		if(next, next resume)	\n"
  	"	)\n"
  	"	\n"
  	"	pause := method(\n"
  	"		//showYielding(\"pause\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifTrue(\n"
  	"			next := yieldingCoros pop \n"
  	"			if(next, \n"
  	"				next resume, \n"
  	"				writeln(\"Scheduler: nothing left to resume so we are exiting\")\n"
  	"				System exit\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	yieldCurrentAndResumeSelf := method(\n"
  	"		//showYielding(\"yieldCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"	\n"
  	"	pauseCurrentAndResumeSelf := method(\n"
  	"		//showYielding(\"pauseCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"\n"
  	"	//typeId := method(self type .. \"_0x\" .. self uniqueId asString toBase(16) .. \" \" .. self label)\n"
  	"	typeId := method(self type .. \"_0x\" .. self uniqueId asString toBase(16))\n"
  	"\n"
  	"	callStack := method(\n"
  	"		stack := ioStack\n"
  	"		stack selectInPlace(v, Object argIsCall(getSlot(\"v\"))) reverse \n"
  	"		stack selectInPlace(v, (v target type == \"Coroutine\" and v message name == \"setResult\") not)  \n"
  	"		stack selectInPlace(v, (v target type == \"Coroutine\" and v message name == \"main\") not)  \n"
  	"		stack foreach(i, v, if(v target type == \"Importer\" and v message name == \"find\", stack sliceInPlace(i+1); break) )\n"
  	"		//stack foreach(v, writeln(v type)) \n"
  	"		//System exit\n"
  	"		stack\n"
  	"	)\n"
  	"	\n"
  	"	backTraceString := method(\n"
  	"		if(Coroutine inException, \n"
  	"			writeln(\"\\n\", exception type, \": \", exception error, \"\\n\\n\")\n"
  	"			writeln(\"Coroutine Exception loop detected\"); \n"
  	"			System exit\n"
  	"		)\n"
  	"		Coroutine setInException(true)\n"
  	"		buf := Sequence clone\n"
  	"		\n"
  	"		if(CGI isInWebScript, buf appendSeq(\"<pre>\"))\n"
  	"		\n"
  	"		if(exception, buf appendSeq(\"\\n  \", exception type, \": \", exception error, \"\\n\"))\n"
  	"		//buf appendSeq(\"  \", self typeId, \" stack trace\")\n"
  	"		\n"
  	"		if(callStack size > 0) then(\n"
  	"			buf appendSeq(\"  ---------\\n\")\n"
  	"			\n"
  	"			if(exception and exception caughtMessage, \n"
  	"				buf appendSeq(\"  \", exception caughtMessage description, \"\\n\")\n"
  	"			)\n"
  	"			\n"
  	"			callStack foreach(v, buf appendSeq(\"  \", v description, \"\\n\"))\n"
  	"			buf appendSeq(\"\\n\")\n"
  	"		) else(buf appendSeq(\" empty\\n\"))\n"
  	"\n"
  	"		Coroutine setInException(false)\n"
  	"		buf\n"
  	"	)\n"
  	"	\n"
  	"	showStack := method(write(backTraceString))\n"
  	"\n"
  	"	resumeParentCoroutine := method(\n"
  	"		if(parentCoroutine, parentCoroutine pauseCurrentAndResumeSelf)\n"
  	"	)\n"
  	"\n"
  	"	main := method(\n"
  	"		setResult(runTarget doMessage(runMessage, runLocals))\n"
  	"		resumeParentCoroutine\n"
  	"	    //writeln(\"Coroutine error: attempt to return from Coroutine\")\n"
  	"	    pause\n"
  	"	)\n"
  	"\n"
  	"	raiseException := method(e, \n"
  	"		self setException(e)\n"
  	"		resumeParentCoroutine\n"
  	"	)\n"
  	"	\n"
  	")\n"
  	"\n"
  	"Object wait := method(s, \n"
  	"	endDate := Date clone now + Duration clone setSeconds(s)\n"
  	"	loop(endDate isPast ifTrue(break); yield)\n"
  	")\n"
  	"\n"
  	"Message do(\n"
  	"	codeOfLength := method(length,\n"
  	"		c := self code\n"
  	"		if (c size < length, c, c slice(0, length) .. \"...\") asMutable replaceSeq(\"\\n\", \";\")\n"
  	"	)\n"
  	"\n"
  	"	asStackEntry := method(\n"
  	"		label := label lastPathComponent fileName\n"
  	"		label .. \" \" repeated(label size - 18) .. lineNumber .. \" \" repeated(lineNumber asString size - 6)  .. name\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	try := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setParentCoroutine(Scheduler currentCoroutine) \n"
  	"		coro setRunTarget(call sender) \n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0)) \n"
  	"		coro run\n"
  	"		if(coro exception, coro exception, nil)\n"
  	"	)\n"
  	"	\n"
  	"	coroDo := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self) \n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0)) \n"
  	"		Coroutine yieldingCoros atInsert(0, Scheduler currentCoroutine)\n"
  	"		coro run \n"
  	"		coro\n"
  	"	)\n"
  	"	\n"
  	"	currentCoro := method(Coroutine currentCoroutine)\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	catch := nil\n"
  	"	pass := nil\n"
  	")\n"
  	"\n"
  	"Protos Exception do(\n"
  	"	type := \"Exception\"\n"
  	"	newSlot(\"error\", nil)\n"
  	"	newSlot(\"coroutine\", nil)\n"
  	"	newSlot(\"caughtMessage\", nil)\n"
  	"        newSlot(\"nestedException\", nil)\n"
  	"	\n"
  	"	raise := method(error, nestedException,\n"
  	"		coro := Scheduler currentCoroutine\n"
  	"		coro raiseException(self clone setError(error) setCoroutine(coro) setNestedException(nestedException))\n"
  	"	)\n"
  	"	\n"
  	"	catch := method(exceptionProto,\n"
  	"		if (self isKindOf(exceptionProto),\n"
  	"			call evalArgAt(1)\n"
  	"		)\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	pass := method(Scheduler currentCoroutine raiseException(self)) \n"
  	"\n"
  	"	showStack := method(\n"
  	"                coroutine showStack\n"
  	"                if(nestedException,\n"
  	"                        write(\"Nested Exception:\")\n"
  	"                        nestedException showStack\n"
  	"                )\n"
  	"        )\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/A3_Exception.io");

	s = "Future := Object clone do(\n"
  	"	type := \"Future\"\n"
  	"    newSlot(\"runTarget\", nil)\n"
  	"    newSlot(\"runMessage\", nil)\n"
  	"    newSlot(\"waitingCoros\", nil)\n"
  	"    newSlot(\"hasTrigger\", false)\n"
  	"    \n"
  	"    futureProxy := method(\n"
  	"    	self waitingCoros := List clone\n"
  	"    	self proxy := Object clone\n"
  	"    	proxy _future := self\n"
  	"    	proxy forward := method(\n"
  	"			//writeln(\"proxy forwarding: \", call message )\n"
  	"    		//call delegateTo(_future getSlot(\"result\"))\n"
  	"			_future result doMessage(call message, call sender)\n"
  	"    	)\n"
  	"    	proxy removeAllProtos\n"
  	"    	proxy\n"
  	"    )\n"
  	"        \n"
  	"    setResult := method(r,\n"
  	"		if(waitingCoros, waitingCoros foreach(resumeLater))\n"
  	"		self result := getSlot(\"r\")\n"
  	"    )\n"
  	"    \n"
  	"    result := method(\n"
  	"  		waitingCoros append(Scheduler currentCoroutine)\n"
  	"    	Scheduler currentCoroutine pause\n"
  	"		self getSlot(\"result\")\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	yield := method(Coroutine currentCoroutine yield)\n"
  	"	pause := method(Coroutine currentCoroutine pause)\n"
  	"	//actorQueue := method(self actorQueue := List clone)\n"
  	"	//actorCoroutine := method(self actorCoroutine := self coroDo(yield; actorProcessQueue))\n"
  	"	\n"
  	"	actorRun := method(\n"
  	"		if(self hasLocalSlot(\"actorCoroutine\"),\n"
  	"        	if(actorQueue size == 0, actorCoroutine resumeLater)\n"
  	"		,\n"
  	"			self actorQueue := List clone\n"
  	"        	self actorCoroutine := self coroDo(yield; actorProcessQueue)\n"
  	"        	//writeln(\"actorCoroutine = \", actorCoroutine uniqueId)\n"
  	"        )\n"
  	"		//writeln(\"actorRun yieldingCoros = \", Coroutine yieldingCoros size, \"\\n\")\n"
  	"	)\n"
  	" \n"
  	" 	actorProcessQueue := method(\n"
  	"		if(Coroutine currentCoroutine uniqueId != actorCoroutine uniqueId, \n"
  	"			writeln(\"actorProcessQueue called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", actorCoroutine uniqueId)\n"
  	"			System exit\n"
  	"		)\n"
  	"		\n"
  	"		loop(\n"
  	"			//writeln(\"actorProcessQueue loop 1\")\n"
  	"			while(future := actorQueue removeFirst,\n"
  	"				//writeln(\"actorProcessQueue loop 2 actorQueue size = \", actorQueue size)\n"
  	"				future setResult(self doMessage(future runMessage))\n"
  	"				yield\n"
  	"			)\n"
  	"			actorCoroutine pause\n"
  	"        )\n"
  	"	)\n"
  	"   \n"
  	"	setSlot(\"@\", method(\n"
  	"        m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"        f := Future clone setRunTarget(self) setRunMessage(m)\n"
  	"		actorRun\n"
  	"        actorQueue append(f)\n"
  	"        f futureProxy\n"
  	"	))\n"
  	" \n"
  	"	setSlot(\"@@\", method(\n"
  	"        m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"        f := Future clone setRunTarget(self) setRunMessage(m) \n"
  	"		self actorRun\n"
  	"        self actorQueue append(f)\n"
  	"        nil\n"
  	"	))\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Actor.io");

	s = "\n"
  	"getSlot(\"Block\") do(\n"
  	"	asSimpleString := method(\n"
  	"                if(scope, \"block\", \"method\") .. \"(\" .. argumentNames append(\"...\") join(\", \") .. \")\"\n"
  	"        )\n"
  	"	asString := method(getSlot(\"self\") code)\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Block.io");

	s = "Lobby IoVM do(\n"
  	"	ImmutableSequence := \"\"\n"
  	"	String := ImmutableSequence\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"\n"
  	"	setSlot(\"..\", method(arg, self asString cloneAppendSeq(arg asString)))\n"
  	"\n"
  	"    docSlot(\"alignLeftInPlace(width, [padding])\", \"Same as align left but operation is performed on the receiver.\")\n"
  	"    alignLeftInPlace := method(width, padding,\n"
  	"        originalSize := size\n"
  	"        padding = padding ifNilEval(\" \")\n"
  	"        ((width - size) / padding size) ceil repeatTimes(appendSeq(padding))\n"
  	"        setSize(width max(originalSize))\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"removeSeq(aSequence)\", \"Removes occurances of aSequence from the receiver.\")\n"
  	"    removeSeq := method(s, self replaceSeq(s, \"\"))\n"
  	"\n"
  	"    docSlot(\"alignLeft(width, [padding])\", \"\"\"\n"
  	"    Example:\n"
  	"    <pre>\n"
  	"    Io> \"abc\" alignLeft(10, \"-\")\n"
  	"    ==> abc-------\n"
  	"    Io> \"abc\" alignLeft(10, \"-=\")\n"
  	"    ==> abc-=-=-=-\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"    alignLeft := method(width, padding,\n"
  	"        asMutable alignLeftInPlace(width, padding)\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"alignRight(width, [padding]\", \"\"\"\n"
  	"    Example:\n"
  	"    <pre>\n"
  	"    Io> \"abc\" alignRight(10, \"-\")\n"
  	"    ==> -------abc\n"
  	"    Io> \"abc\" alignRight(10, \"-=\")\n"
  	"    ==> -=-=-=-abc\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"    alignRight := method(width, padding,\n"
  	"        Sequence clone alignLeftInPlace(width - size, padding) appendSeq(self)\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"alignCenter(width, [padding]\", \"\"\"\n"
  	"    Example:\n"
  	"    <pre>\n"
  	"    Io> \"abc\" alignCenter(10, \"-\")\n"
  	"    ==> ---abc----\n"
  	"    Io> \"abc\" alignCenter(10, \"-=\")\n"
  	"    ==> -=-abc-=-=\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"    alignCenter := method(width, padding,\n"
  	"        alignRight(((size + width) / 2) floor, padding) alignLeftInPlace(width, padding)\n"
  	"    )\n"
  	"    \n"
  	"    asSimpleString := method(\"\\\"\" .. self asString .. \"\\\"\")\n"
  	"\n"
  	"	splitNoEmpties := method(\n"
  	"		docSlot(\"split(optionalArg1, optionalArg2, ...)\", \"\"\"\n"
  	"		Returns a list containing the non-empty sub-sequences of the receiver divided by the given arguments.\n"
  	"		If no arguments are given the sequence is split on white space.\n"
  	"		Examples:\n"
  	"		<pre>\n"
  	"		\"a   b  c d\" splitNoEmpties => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b**c*d\" splitNoEmpties(\"*\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b||c,d\" splitNoEmpties(\"*\", \"|\", \",\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		</pre>\n"
  	"		\"\"\")\n"
  	"	\n"
  	"		self doMessage(\n"
  	"			call message clone setName(\"split\") setAttachedMessage(nil) setNextMessage(nil)\n"
  	"		,\n"
  	"			call sender\n"
  	"		) selectInPlace(s, s size != 0)\n"
  	"	)\n"
  	"\n"
  	"  docSlot(\"findNthSeq(aSequence, n)\", \"Returns a number with the nth occurence of aSequence\")\n"
  	"  Sequence findNthSeq := method(str, n,\n"
  	"    num := self findSeq(str)\n"
  	"    if(num isNil, return nil)\n"
  	"    if(n == 1, return num)\n"
  	"    num + self slice(num + 1, self size) findNthSeq(str, n - 1)\n"
  	"  ) \n"
  	"\n"
  	"  docSlot(\"interpolate\", \"Takes #<lang>{ ... } tags and expands them using an appropriate interpreter. Returns a new string with the values expanded. Optional argument is the context to evaluate the code into. Currently the only <lang>'s supported are \\\"io\\\".\")\n"
  	"  Sequence interpolate := method(ctx,\n"
  	"		if(ctx isNil, ctx = call sender)\n"
  	"  		strings := List clone\n"
  	"		start := 0\n"
  	"		while (start < self size,\n"
  	"			s := start\n"
  	"			start := self findSeq(\"#io{\", s)\n"
  	"			if(start == nil, strings append(self slice(s, self size)); break)\n"
  	"			strings append(self slice(s, start))\n"
  	"			\n"
  	"			end := self findSeq(\"}\", start)\n"
  	"			if(end == nil, strings append(self slice(s, self size)); break)\n"
  	"			\n"
  	"			//writeln(\"start = \", start, \" end = \", end)\n"
  	"			\n"
  	"			exp := self slice(start+4, end)\n"
  	"			strings append(ctx doMessage(exp asMessage, call sender) asString)\n"
  	"			start := end + 1\n"
  	"		)\n"
  	"		strings join\n"
  	"	)\n"
  	"	\n"
  	"  docSlot(\"interpolateInPlace\", \"Takes #<lang>{ ... } tags and expands them using an appropriate interpreter. Modifies and returns the string with the values expanded. Optional argument is the context to evaluate the code into. Currently the only <lang>'s supported are \\\"io\\\".\")\n"
  	"\n"
  	"	Sequence interpolateInPlace := method(ctx,\n"
  	"		if(self isMutable == false,\n"
  	"			Exception raise(\"'interpolateInPlace' cannot be called on an immutable Sequence\")\n"
  	"		)\n"
  	"		if(ctx isNil, ctx = call sender)\n"
  	"		self copy(self interpolate(ctx))\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/B_Sequence.io");

	s = "getSlot(\"CFunction\") do(\n"
  	"    type := \"CFunction\"\n"
  	"\n"
  	"    name := method(typeName ifNilEval(\"Object\") .. \"_\" .. uniqueName ifNilEval(\"<unnamed>\") .. \"()\")\n"
  	"    \n"
  	"    asSimpleString := method(name)\n"
  	"\n"
  	"    asString := getSlot(\"asSimpleString\")\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/CFunction.io");

	s = "Date do(\n"
  	"	secondsToRun := method(\n"
  	"		t1 := Date clone now\n"
  	"		call evalArgAt(0)\n"
  	"		dt := Date clone now secondsSince(t1)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Number do(\n"
  	"	years := method(Duration clone setYears(self))\n"
  	"	days := method(Duration clone setDays(self))\n"
  	"	hours := method(Duration clone setHours(self))\n"
  	"	minutes := method(Duration clone setMinutes(self))\n"
  	"	seconds := method(Duration clone setSeconds(self))\n"
  	")\n"
  	"\n"
  	"Duration do(\n"
  	"	setSlot(\"+\", method(d, self clone += d))\n"
  	"	setSlot(\"-\", method(d, self clone -= d))\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Date.io");

	s = "Debugger do(\n"
  	"    docDescription(\"To start debugging a coroutine, call \n"
  	"    <pre>\n"
  	"    Coroutine currentCoroutine setMessageDebugging(true)\n"
  	"    </pre>\n"
  	"    Then each message sent within that coroutine will cause the Debugger vmWillSendMessage slot to be activated and the Debugger slots: messageCoroutine, messageSelf, messageLocals, and message will be set with the values related to the current message send. You can override vmWillSendMessage to implement your own debugging mechanisms.\")\n"
  	"\n"
  	"	start := method(\n"
  	"		self debuggerCoroutine := Coroutine currentCoroutine\n"
  	"		debuggerCoroutine pause\n"
  	"		loop(\n"
  	"			self vmWillSendMessage (self message name)\n"
  	"			messageCoroutine resume\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	vmWillSendMessage := method(\n"
  	"		writeln(\"Debugger vmWillSendMessage(\", self message name, \")\")\n"
  	"	)\n"
  	"	\n"
  	"	@@start\n"
  	"	yield\n"
  	")\n"
  	"\n"
  	"    docSlot(\"vmWillSendMessage\", \"Override this method to implement your own debugging mechanisms.\")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Debugger.io");

	s = "\n"
  	"Directory do(\n"
  	"    docSlot(\"with(aPath)\", \"Returns a new instance with the provided path.\")\n"
  	"    with := method(path, self clone setPath(path))\n"
  	"\n"
  	"    parentDirectory := method(\n"
  	"		if(path == \".\", return nil)\n"
  	"		p := self path pathComponent	\n"
  	"		if(p == \"\", p = \".\")\n"
  	"		Directory clone setPath(p)\n"
  	"    )\n"
  	"\n"
  	"    folders := method(\n"
  	"		items select(item, item type ==(\"Directory\") and(item name != \".\") and(item name != \"..\"))\n"
  	"    )\n"
  	"\n"
  	"    isAccessible := method(\n"
  	"        r := self\n"
  	"		try(items) catch(Exception, e, r = nil)\n"
  	"		r\n"
  	"    )\n"
  	"\n"
  	"    parents := method(\n"
  	"		list := List clone\n"
  	"		d := self\n"
  	"		while(d = d parentDirectory, list append(d))\n"
  	"		list reverse\n"
  	"    )\n"
  	"\n"
  	"    accessibleParents := method(\n"
  	"		parents select(p, p isAccessible)\n"
  	"    )\n"
  	"    \n"
  	"    files := method(\n"
  	"		//writebr(\"path = \", path)\n"
  	"		items select(v, v type == \"File\")\n"
  	"    )\n"
  	"    \n"
  	"    fileNames := method(\n"
  	"		files mapInPlace(i, v, v name)\n"
  	"    )\n"
  	"    \n"
  	"    fileNamed := method(name,\n"
  	"		files detect(i, v, v name == name)\n"
  	"		//File clone setPath(Path with(path, name))\n"
  	"    )\n"
  	"\n"
  	"    filesWithExtension := method(ext,\n"
  	"      if(ext containsSeq(\".\") not, ext = \".\" .. ext)\n"
  	"      files select(f, f name endsWithSeq(ext))\n"
  	"    )\n"
  	"\n"
  	"    folderNamed := method(name,\n"
  	"		folders detect(i, v, v name == name)\n"
  	"    )\n"
  	"\n"
  	"    remove := method(\n"
  	"        File clone setPath(self path) remove\n"
  	"    )\n"
  	"\n"
  	"    folderNamedCreateIfAbsent := method(name,\n"
  	"		f := folderNamed(name)\n"
  	"		if(f, return f)\n"
  	"		createSubdirectory(name)\n"
  	"		folderNamed(name)\n"
  	"    )\n"
  	"\n"
  	"    createFileNamed := method(name,\n"
  	"		f := fileNamed(name)\n"
  	"		if(f, return f)\n"
  	"		return File clone setPath(Path with(path, name))\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Directory.io");

	s = "\n"
  	"File do(\n"
  	"	docSlot(\"with(aPath)\", \"Returns a new instance with the provided path.\")\n"
  	"	with := method(path, self clone setPath(path))\n"
  	"	\n"
  	"	newSlot(\"streamDestination\")\n"
  	"	newSlot(\"streamReadSize\", 1024*64)\n"
  	"	startStreaming := method(\n"
  	"		b := Sequence clone\n"
  	"		self open\n"
  	"		while(isAtEnd not, \n"
  	"			b empty\n"
  	"			readToBufferLength(b, streamReadSize)\n"
  	"			streamDestination write(b)\n"
  	"			yield\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/File.io");

	s = "\n"
  	"Notifier := Object clone do(\n"
  	"	addListener := method(listener, \n"
  	"		if(self getSlot(\"listeners\") == nil, self listeners := List clone)\n"
  	"		listeners append(listener); \n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	removeListener := method(obj,\n"
  	"		if(?listeners, listeners remove(obj))\n"
  	"	)\n"
  	"	\n"
  	"	notifyListeners := method(\n"
  	"		if(?listeners, \n"
  	"			listeners foreach(l,\n"
  	"				if(l hasSlot(call argAt(0) name), \n"
  	"					l doMessage(call argAt(0), call sender)\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	")";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Notifier.io");

	s = "Number do(\n"
  	"  constants := Object clone do(\n"
  	"    docSlot(\"constants pi\", \"Returns the constant pi.\")\n"
  	"    pi := 3.14159265358979323846264338327950288\n"
  	"\n"
  	"    docSlot(\"constants nan\", \"Returns a infinity constant.\")    \n"
  	"    nan := (0/0)\n"
  	"\n"
  	"    docSlot(\"constants inf\", \"Returns a not-a-number constant.\")    \n"
  	"    inf := (1/0)\n"
  	"        \n"
  	"    docSlot(\"constants e\", \"Returns the constant e.\")\n"
  	"    e  := 2.71828182845904523536028747135266249\n"
  	"  )\n"
  	"\n"
  	"  asSimpleString := method(self asString)\n"
  	"\n"
  	"  docSlot(\"to\", \"Convenience constructor that returns a cursor object representing the range of numbers from the receiver to the 'endingPoint' parameter. Increments over each item in that range by 1.\")\n"
  	"  to := method(e, self toBy(e, 1))\n"
  	"\n"
  	"  docSlot(\"toBy(endingPoint, incrementValue)\", \"Convenience constructor that returns a cursor object representing the range of numbers from the receiver to the 'endingPoint' parameter. Increments over each item in that range by the 'incrementValue' parameter.\")\n"
  	"  toBy := method(e, i,\n"
  	"    if(i < 0, Exception raise(\"increment value must be non-negative\"))\n"
  	"    Range clone setRange(self, e, i)\n"
  	"  )\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Number.io");

	s = "CGI := Object clone do(\n"
  	"	type := \"CGI\"\n"
  	"	docCopyright(\"Steve Dekorte\", 2004)\n"
  	"	docLicense(\"BSD revised\")\n"
  	"	docDescription(\"\n"
  	"	CGI supports accessing CGI parameters passed in environment variable or standard input by a web servers like Apache.Example use;\n"
  	"	<pre>\n"
  	"	#!./ioServer\n"
  	"	\n"
  	"	write(\\\"Content-type:text/html\\n\\n\\\")\n"
  	"	write(\\\"&lt;!doctype html public \\\"-//W3C/DTD HTML 4.0/EN\\\"&gt;\\n\\\")\n"
  	"	write(\\\"Got the following CGI parameters:&lt;PRE&gt;\\\")\n"
  	"	\n"
  	"	form = CGI clone parse\n"
  	"	\n"
  	"	if(form != nil) then(\n"
  	"	  form foreach(k, v, write(\\\"  \\\", k, \\\" = \\\", v, \\\"&lt;BR&gt;\\\"))\n"
  	"	) else( \n"
  	"	  write(\\\"no form variables found\\n\\\") \n"
  	"	)</pre>\")\n"
  	"	docCategory(\"Networking\")\n"
  	"\n"
  	"    docSlot(\"parse\", \"Parses the QUERY_STRING environment variable (or standard input if there is no QUERY_STRING environment variable) and returns a Map containing key/value query value pairs.\")\n"
  	"\n"
  	"	isInWebScript := method(\n"
  	"		System getenv(\"QUERY_STRING\") != nil\n"
  	"	)\n"
  	"	\n"
  	"	parse := method(\n"
  	"		q := System getenv(\"QUERY_STRING\")\n"
  	"		contentLength := System getenv(\"CONTENT_LENGTH\")\n"
  	"		if (q == nil, return Map clone)\n"
  	"		\n"
  	"		if (contentLength, \n"
  	"			post := File clone standardInput readStringOfLength(contentLength asNumber)\n"
  	"			q = if (q != \"\", q .. \"&\" .. post, post)\n"
  	"		)\n"
  	"		//write(\"<PRE> q := \", q, \"</PRE>\\n\")\n"
  	"		return self parseString(q)\n"
  	"	)\n"
  	"\n"
  	"    parseString := method(q, \n"
  	"		q = q asMutable replaceSeq(\"+\", \" \")\n"
  	"		\n"
  	"		form := Map clone\n"
  	"		q splitNoEmpties(\"&\") foreach(i, v, \n"
  	"			kv := v splitNoEmpties(\"=\")\n"
  	"			if(kv size == 2) then(\n"
  	"				k := kv at(0)\n"
  	"				v := decodeUrlParam(kv at(1))\n"
  	"				\n"
  	"				if (form hasKey(k)) then(\n"
  	"					vallist := List clone\n"
  	"					\n"
  	"					// this already exists, so we want to take the value of k, \n"
  	"					// and make a list of the values, \n"
  	"					// remove the original k/v then add k/v as list back.\n"
  	"					\n"
  	"					if (form at(k) type == \"List\") then(\n"
  	"						//it's a list already, so just add the value at the end\n"
  	"						vallist = form at(k)\n"
  	"						vallist append(v)\n"
  	"					) else(\n"
  	"						vallist append(form at(k))  \n"
  	"						vallist append(v)\n"
  	"					)\n"
  	"					\n"
  	"					form removeAt(k)\n"
  	"					form atPut(k, vallist)\n"
  	"				) else(\n"
  	"					form atPut(k, v)\n"
  	"				)\n"
  	"				\n"
  	"			) else( \n"
  	"				kv := kv at(0) splitNoEmpties(\",\")\n"
  	"				form atPut(\"imageMapX\", kv at(0))\n"
  	"				form atPut(\"imageMapY\", kv at(1))\n"
  	"			)\n"
  	"		)\n"
  	"		return form\n"
  	"    )\n"
  	"\n"
  	"    urlCodes := Map clone\n"
  	"\n"
  	"	setup := method(\n"
  	"		for (i, 0, 255,\n"
  	"			code := i asString toBase(16) asUppercase\n"
  	"			if (code size == 1, code = \"0\" .. code)\n"
  	"			/*write(i, \" := \", i asCharacter, \" := \", \"%\" .. code, \"<BR>\")*/\n"
  	"			urlCodes atPut(i asCharacter, \"%\" .. code) \n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"    setup\n"
  	"\n"
  	"    urlPlains := Map clone do(\n"
  	"	    atPut(\" \", \"+\")\n"
  	"	    atPut(\"*\", \"*\")\n"
  	"	    atPut(\"-\", \"-\")\n"
  	"	    atPut(\".\", \".\")\n"
  	"	    for (i, 48, 57, atPut(i asCharacter, i asCharacter))\n"
  	"	    for (i, 65, 90, atPut(i asCharacter, i asCharacter))\n"
  	"	    atPut(\"_\", \"_\")\n"
  	"	    for (i, 97, 122, atPut(i asCharacter, i asCharacter))\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"encodeUrlParam(aString)\", \"Returns a URL encoded version of aString.\")\n"
  	"\n"
  	"    encodeUrlParam := method(sIn,\n"
  	"	    sOut := Sequence clone\n"
  	"	    sIn foreach(i, v,\n"
  	"		    c := v asCharacter\n"
  	"		    p := urlPlains at(c)\n"
  	"		    sOut appendSeq(if(p, p, urlCodes at(c)))\n"
  	"	    )\n"
  	"	    return sOut asString\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"decodeUrlParam(aString)\", \"Returns a URL decoded version of aString.\")\n"
  	"\n"
  	"    decodeUrlParam := method(s,\n"
  	"		urlCodes foreach(k, v, s = s replaceSeq(v, k))\n"
  	"		return s\n"
  	"    )\n"
  	"\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/P_CGI.io");

	s = "Range do(\n"
  	"  docSlot(\"asList\", \"Returns a list containing all the items within and including the ranges starting and ending points.\")\n"
  	"  asList := method(\n"
  	"    lst := List clone\n"
  	"    self foreach(v, lst append(v))\n"
  	"    lst\n"
  	"  )\n"
  	"\n"
  	"  docSlot(\"contains\", \"Returns a boolean value if the range contains the argument. This works independant of any increment value.\")\n"
  	"  contains := method(v,\n"
  	"    Exception raise(\"'contains' method has no implementation.\")\n"
  	"  )\n"
  	"\n"
  	"  docSlot(\"select\", \"Operates the same as 'List select'\")\n"
  	"  select := List getSlot(\"select\")\n"
  	"\n"
  	"  docSlot(\"map([value], body)\", \"Returns a new list which contains the result of the 'body' for every element stepped over in the range, from the starting point to the ending point inclusive.\")\n"
  	"  map := method(\n"
  	"    a1 := call argAt(0)\n"
  	"    if(a1 isNil,\n"
  	"      Exception raise(\"'map' requires at least 1 argument\")\n"
  	"      return\n"
  	"    )\n"
  	"    lst := List clone\n"
  	"    body := call argAt(1)\n"
  	"    if(body, valName := a1 name)\n"
  	"    if(a1 and body isNil, body = call argAt(0))\n"
  	"    loop(\n"
  	"      if(getSlot(\"valName\"), call sender setSlot(valName, value))\n"
  	"      lst append(call sender doMessage(body))\n"
  	"      next ifFalse(break)\n"
  	"    )\n"
  	"    lst\n"
  	"  )\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Range.io");

	s = "Sandbox do(\n"
  	"    docSlot(\"printCallback(string)\", \n"
  	"     \"default implementation is; method(string, string print)\")\n"
  	"    printCallback := method(string, string print)\n"
  	")";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Sandbox.io");

	s = "\n"
  	"nil serialized := method(b, \n"
  	"	if(b == nil, b := Sequence clone)\n"
  	"	b appendSeq(\"nil\")\n"
  	")\n"
  	"\n"
  	"true serialized := method(b, \n"
  	"	if(b == nil, b := Sequence clone)\n"
  	"	b appendSeq(\"true\")\n"
  	")\n"
  	"\n"
  	"false serialized := method(b, \n"
  	"	if(b == nil, b := Sequence clone)\n"
  	"	b appendSeq(\"false\")\n"
  	")\n"
  	"\n"
  	"Sequence serialized := method(b,\n"
  	"	if(b == nil, b := Sequence clone)\n"
  	"	b appendSeq(self asMutable replaceSeq(\"\\\"\", \"\\\\\\\"\") asSimpleString)\n"
  	")\n"
  	"\n"
  	"Number serialized := method(b,\n"
  	"	if(b == nil, b := Sequence clone)\n"
  	"	b appendSeq(self asSimpleString)\n"
  	")\n"
  	"\n"
  	"List serialized := method(b,\n"
  	"	if(b == nil, b := Sequence clone)\n"
  	"	b appendSeq(\"list(\")\n"
  	"	b appendSeq(self map(serialized) join(\", \"))\n"
  	"	b appendSeq(\");\")\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	serialized := method(b,\n"
  	"		if(b == nil, b := Sequence clone)\n"
  	"		b appendSeq(self type, \" clone do(\\n\") \n"
  	"		self serializedSlots(b)\n"
  	"		b appendSeq(\")\\n\")\n"
  	"		b\n"
  	"	)\n"
  	"\n"
  	"	serializedSlots := method(b,\n"
  	"		if(b == nil, b := Sequence clone)\n"
  	"		self serializedSlotsWithNames(self slotNames, b)\n"
  	"	)\n"
  	"	\n"
  	"	serializedSlotsWithNames := method(names, b,\n"
  	"		if(b == nil, b := Sequence clone)\n"
  	"		names foreach(slotName, \n"
  	"			b appendSeq(\"\\t\", slotName, \" := \")\n"
  	"			self getSlot(slotName) serialized(b)\n"
  	"			b appendSeq(\"\\n\")\n"
  	"		)\n"
  	"		b\n"
  	"	)\n"
  	")";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Serialize.io");

	s = "\n"
  	"\n"
  	"\n"
  	"System do(\n"
  	"	docSlot(\"getOptions(args)\", \"\n"
  	"	This primitive is used to get command line options similar to Cs getopt(). \n"
  	"	It returns a map in containing the left side of the argument, with the \n"
  	"	value of the right side. (The key will not contain\n"
  	"	the beginning dashes (--).\n"
  	" 	<p>\n"
  	"	Example:\n"
  	" 	<pre>\n"
  	"	options := System getOptions(args)\n"
  	"	options foreach(k, v,\n"
  	"	  if(v type == List type,\n"
  	"	    v foreach(i, j, writeln(\\\"Got unnamed argument with value: \\\" .. j))\n"
  	"	    continue\n"
  	"	  )\n"
  	"	  writeln(\\\"Got option: \\\" .. k .. \\\" with value: \\\" .. v)\n"
  	"	)\n"
  	" 	</pre>\n"
  	"\")\n"
  	"\n"
  	"  getOptions := method(arguments,\n"
  	"    opts := Map clone\n"
  	"    optname := Sequence clone\n"
  	"    optvalue := Sequence clone\n"
  	"    optsNoKey := List clone\n"
  	"  \n"
  	"    arguments foreach(i, arg,\n"
  	"      if(arg beginsWithSeq(\"--\") isNil) then(\n"
  	"        optsNoKey append(arg)\n"
  	"        continue\n"
  	"      )\n"
  	"      if(arg containsSeq(\"=\")) then(\n"
  	"        optname := arg clone asMutable\n"
  	"        optname clipAfterStartOfSeq(\"=\")\n"
  	"        optname clipBeforeEndOfSeq(\"--\")\n"
  	"        optvalue := arg clone asMutable\n"
  	"        optvalue clipBeforeEndOfSeq(\"=\")\n"
  	"      ) else(\n"
  	"        optname := arg clone asMutable\n"
  	"        optname clipBeforeEndOfSeq(\"--\")\n"
  	"        optvalue = \"\"\n"
  	"      )\n"
  	"      opts atPut(optname, optvalue)\n"
  	"    )\n"
  	"    if(optsNoKey last != nil, opts atPut(\"\", optsNoKey))\n"
  	"    opts\n"
  	"  )\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/System.io");

	s = "UnitTest := Object clone do(\n"
  	"	type  := \"UnitTest\"\n"
  	"	docCategory(\"Testing\")\n"
  	"	setUp := method(nil)\n"
  	"	tearDown := method(nil)\n"
  	"	init := method(self exceptions := List clone)\n"
  	"	testSlotNames := method(self slotNames select(n, n beginsWithSeq(\"test\")) sortInPlace)\n"
  	"	\n"
  	"	testCount := method(testSlotNames size)\n"
  	"	\n"
  	"	run := method(\n"
  	"		testSlotNames foreach(n, \n"
  	"			self setUp\n"
  	"			writeln(\"    \", n)\n"
  	"			e := try(self doString(n))\n"
  	"			if(e, \n"
  	"				write(\"    \", n, \" - failed\")\n"
  	"				exceptions append(e)\n"
  	"				write(\"\\n\")\n"
  	"				writeln(e showStack)\n"
  	"				//System exit\n"
  	"			)\n"
  	"			//Scheduler currentCoroutine yield\n"
  	"			Collector collect; Collector collect\n"
  	"			//Collector collect; Collector collect\n"
  	"			self tearDown\n"
  	"			Collector collect\n"
  	"			Collector collect\n"
  	"		)\n"
  	"	)\n"
  	"    \n"
  	"    fail := method(Exception raise(\"fail\"))\n"
  	"    \n"
  	"	assertEquals := method(a, b, m,\n"
  	"		//writeln(\"assertEquals1 call message = \", call message type)\n"
  	"		mm := call message\n"
  	"		if(m == nil, m = mm)\n"
  	"		d := m argAt(0) code .. \" != \" .. call argAt(1) code\n"
  	"		if(a != b, Exception raise(\"[\" .. d .. \"] [\" .. a .. \" != \" .. b .. \"]\"))\n"
  	"		//writeln(\"assertEquals2\")\n"
  	"	)\n"
  	"\n"
  	"	assertNotEquals := method(a, b, if(a == b, Exception raise(a .. \" == \" .. b)))\n"
  	"\n"
  	"    assertSame    := method(a, b, assertEquals(a uniqueId, b uniqueId, call message))\n"
  	"    assertNotSame := method(a, b, assertNotEquals(a uniqueId, b uniqueId, call message))\n"
  	"    assertNil     := method(a, assertEquals(a, nil, call message))\n"
  	"    assertNotNil  := method(a, assertNotEquals(a, nil, call message))\n"
  	"    assertTrue    := method(a, assertEquals(a, true, call message))\n"
  	"    assertFalse   := method(a, assertEquals(a, false, call message))\n"
  	"\n"
  	"	assertRaisesException := method(\n"
  	"		e := try(\n"
  	"			call evalArgAt(0)\n"
  	"			writeln(\"Should have raised Exception\")\n"
  	"		)\n"
  	"		e ifNil(Exception raise(\"Should have raised Exception\"))\n"
  	"	)\n"
  	"    \n"
  	"	knownBug := method(writeln(\"  [known bug: \", call argAt(0) code, \"]\"))\n"
  	"  \n"
  	"	assertEqualsWithinDelta := method(expected, actual, delta,\n"
  	"		if(((expected - actual) abs > delta),\n"
  	"			Exception raise(\"expected \" .. expected .. \" but was \" .. actual .. \" (allowed delta: \" .. delta .. \")\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"TestSuite := Object clone do(\n"
  	"	type := \"TestSuite\"\n"
  	"	docCategory(\"Testing\")\n"
  	"	name := method(\n"
  	"		path asMutable pathComponent lastPathComponent\n"
  	"	)\n"
  	"	newSlot(\"path\", \".\")\n"
  	"	run := method(\n"
  	"		writeln(\"\\n\", name)\n"
  	"		unitTestFiles := Directory with(launchPath) files select(f, f name endsWithSeq(\"Test.io\"))\n"
  	"		exceptions := List clone\n"
  	"		testCount := 0\n"
  	"		\n"
  	"		unitTestFiles foreach(f, \n"
  	"			writeln(\"  \", f name fileName)\n"
  	"			test := Lobby doString(f contents, f path)\n"
  	"			test run\n"
  	"			testCount = testCount + test testCount\n"
  	"			exceptions appendSeq(test exceptions)\n"
  	"		)\n"
  	"		\n"
  	"		writeln(\"  ---------------\")\n"
  	"		Collector collect\n"
  	"		writeln(\"  \", testCount, \" tests, \", exceptions size, \" failures\\n\")\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/UnitTest.io");

	s = "Path := Object clone do(\n"
  	"	type := \"Path\"\n"
  	"	docCategory(\"FileSystem\")\n"
  	"	with := method(\n"
  	"		s := Sequence clone\n"
  	"		call message arguments foreach(arg,\n"
  	"			s appendPathSeq(call sender doMessage(arg))\n"
  	"		)\n"
  	"		s asSymbol\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Y_Path.io");

	s = "\n"
  	"Protos CLI := Object clone do(\n"
  	"	type := \"CLI\"\n"
  	"	stdout := File clone standardOutput\n"
  	"	stdin  := File clone standardInput\n"
  	"	inPrompt  := \"Io> \"\n"
  	"	outPrompt := \"==> \"\n"
  	"	multiLine := true\n"
  	"	newSlot(\"evalContext\", method(Lobby))\n"
  	"	newSlot(\"isRunning\", true)\n"
  	"	\n"
  	"	stop := method(setIsRunning(false))\n"
  	"	\n"
  	"	runPath := method(path,\n"
  	"		//Lobby launchPath := path pathComponent\n"
  	"		Lobby launchPath := if(path beginsWithSeq(\"/\") /* i.e. absolute */, path,\n"
  	"			Directory currentWorkingDirectory asMutable appendPathSeq(path)\n"
  	"		) pathComponent\n"
  	"\n"
  	"		e := try(Lobby doFile(path))\n"
  	"		if(e, e showStack)\n"
  	"	)\n"
  	"\n"
  	"	run := method(\n"
  	"		Lobby launchPath := Directory currentWorkingDirectory\n"
  	"        Lobby exit := method(System exit)\n"
  	"        \n"
  	"		if(?args and(args size > 0), \n"
  	"			args foreach(i, arg,\n"
  	"			\n"
  	"				if(arg == \"-e\", \n"
  	"					writeln(evalContext doString(args slice(i + 1) join(\" \")))\n"
  	"					return\n"
  	"				)\n"
  	"				\n"
  	"				if(arg == \"-i\",\n"
  	"					if(args size == i + 1,\n"
  	"						if(File clone setPath(\"main.io\") exists,\n"
  	"							runPath(\"main.io\")\n"
  	"						)\n"
  	"					,\n"
  	"						nextArg := args at(i + 1) \n"
  	"						if(nextArg, runPath(nextArg))\n"
  	"					)\n"
  	"					return interactiveMultiline\n"
  	"				)\n"
  	"				\n"
  	"				runPath(arg)\n"
  	"				return\n"
  	"			)\n"
  	"		,\n"
  	"			if(File clone setPath(\"main.io\") exists,\n"
  	"				runPath(\"main.io\")\n"
  	"				return\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"        interactiveMultiline\n"
  	"	)\n"
  	"	\n"
  	"	outputResult := method(result,\n"
  	"			writeln(\"\\n\", outPrompt, getSlot(\"result\"))\n"
  	"	)\n"
  	"	\n"
  	"	interactive := method(\n"
  	" 		writeln(System distribution, \" \", System version)\n"
  	" 		while(isRunning,\n"
  	"			write(inPrompt)\n"
  	"			line := stdin readLine\n"
  	"			if(stdin isAtEnd, writeln; Lobby exit)\n"
  	"			result := nil\n"
  	"			e := try(result = evalContext doString(line))\n"
  	"			if(e, e showStack)\n"
  	"			outputResult(getSlot(\"result\"))\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	interactiveMultiline := method(\n"
  	"		writeln(System distribution, \" \", System version)\n"
  	"		errTriQuote	:= try(Compiler messageForString(\"\\\"\\\"\\\"\")) error\n"
  	"		errParen		:= try(Compiler messageForString(\"(\")) error\n"
  	"		errArg		:= try(Compiler messageForString(\"(x,\")) error\n"
  	"		errParen2	:= try(Compiler messageForString(\"1+(2+(\")) error\n"
  	"		mapContinueOnErr := Map clone\n"
  	"		mapContinueOnErr atPut(errTriQuote, \"\\\"-> \")\n"
  	"		mapContinueOnErr atPut(errParen, \")-> \")\n"
  	"		mapContinueOnErr atPut(errParen2, \"))> \")\n"
  	"\n"
  	"		while(isRunning,\n"
  	"			prompt := inPrompt\n"
  	"			line := \"\"\n"
  	"			loop(\n"
  	"				write(prompt)\n"
  	"				nextLine := stdin readLine\n"
  	"				if(stdin isAtEnd, writeln; Lobby exit)\n"
  	"				line := line .. \"\\n\" .. (nextLine)\n"
  	"				if(line endsWithSeq(\"\"\"\\\\\"\"\"),\n"
  	"					prompt = \"    \"\n"
  	"					continue\n"
  	"				)\n"
  	"				result := nil\n"
  	"				e := try(result = evalContext doString(line))\n"
  	"				if(e,\n"
  	"					err := e error\n"
  	"					if(prompt = mapContinueOnErr at(err),\n"
  	"						//err println\n"
  	"						continue\n"
  	"					)\n"
  	"					if(err ==(errArg) and(line asMutable strip endsWithSeq(\",\")),\n"
  	"						//err println\n"
  	"						prompt = \"a-> \"\n"
  	"						continue\n"
  	"					)\n"
  	"					e showStack\n"
  	"				)\n"
  	"				break\n"
  	"			)\n"
  	"			outputResult(getSlot(\"result\"))\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Shell := Object clone do(\n"
  	"	newSlot(\"directory\", Directory clone setPath(\".\"))\n"
  	"	\n"
  	"	cd := method(name, \n"
  	"		item := directory at(call argAt(0) name)\n"
  	"	    if(v type == \"Directory\", setDirectory(v))\n"
  	"	)\n"
  	"	\n"
  	"	ls := method(directory items foreach(name println))\n"
  	"	\n"
  	"	open := method(name,\n"
  	"		item := directory at(call argAt(0) name)\n"
  	"		if(item isUserExecutable) then(\n"
  	"			// insert stuff to add args\n"
  	"			System system(item path)\n"
  	"		)	\n"
  	"	)\n"
  	"	\n"
  	"	forward := method(\n"
  	"		call delegateTo(directory)\n"
  	"		/*\n"
  	"		item := directory at(call message name)\n"
  	"		if(item == nil, writeln(\"no such path\"); return item)\n"
  	"		*/\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Lobby shell := method(\n"
  	"	CLI setEvalContext(Shell)\n"
  	"	//CLI outputResult := method(nil)\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Z_CLI.io");

	s = "Importer := Object clone do(\n"
  	"	type := \"Importer\"\n"
  	"    docDescription(\"A simple search path based auto-importer.\")\n"
  	"\n"
  	"    paths := List clone append(\"\")\n"
  	"    debug := false\n"
  	"    \n"
  	"    addSearchPath    := method(p, paths append(p asSymbol))\n"
  	"    removeSearchPath := method(p, paths remove(p asSymbol))\n"
  	"    \n"
  	"    extensions := list(\"io\")\n"
  	"\n"
  	"    executeString := method(name, s,\n"
  	"		Lobby doString(s, name)\n"
  	"		r := Lobby getSlot(name)\n"
  	"		if(r, return r)\n"
  	"		Exception raise(\"Importer slot '\" .. name .. \"' missing after file load\")\n"
  	"		nil    \n"
  	"    )\n"
  	"    \n"
  	"	execute_io := method(path, name, extension,\n"
  	"		p := Path with(path, name .. \".\" .. extension)\n"
  	"		s := File clone setPath(p) asBuffer\n"
  	"		executeString(name, s)\n"
  	"	)\n"
  	"\n"
  	"	find := method(message, theObject,\n"
  	"		name := message name\n"
  	"		p := ?launchPath\n"
  	"		if(debug, writeln(\"Importer find '\", name, \"' \", message label, \" \", message lineNumber, \" ---------------------------\"))\n"
  	"		if(p and(paths contains(p) not), paths atInsert(0, p))  \n"
  	"		if(name at(0) isUppercase, paths foreach(p, \n"
  	"			extensions foreach(extension,\n"
  	"				if(p beginsWithSeq(\"/\")) then(\n"
  	"					fullPath := Path with(p, name .. \".\" .. extension) asSymbol\n"
  	"				) else(\n"
  	"					fullPath := Path with(Directory currentWorkingDirectory, p, name .. \".\" .. extension) asSymbol\n"
  	"				)\n"
  	"				//if(debug, writeln(\"Directory currentWorkingDirectory:\", Directory currentWorkingDirectory))\n"
  	"				if(debug, writeln(\"cwd:                  \", Directory currentWorkingDirectory))\n"
  	"				if(debug, writeln(\"p:                    \", p))\n"
  	"				if(debug, writeln(\"Importer looking for: \", fullPath))\n"
  	"				//writeln(\"File clone setPath(\\\"\" .. fullPath .. \"\\\") exists = \", File clone setPath(fullPath) exists)\n"
  	"				if(File clone setPath(fullPath) exists, \n"
  	"					r := self perform(\"execute_\" .. extension, p, name, extension)\n"
  	"					if (r, return r)\n"
  	"				)\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"		Exception raise(theObject type .. \" does not respond to '\" .. name .. \"'\")\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"turnOn\", \"Turns on the Importer. Returns self.\")    \n"
  	"    turnOn := method(Lobby forward := method(Importer find(call message, self)); self)\n"
  	"\n"
  	"    docSlot(\"turnOff\", \"Turns off the Importer. Returns self.\")    \n"
  	"    turnOff := method(Lobby removeSlot(\"forward\"); self)\n"
  	"    turnOn\n"
  	")\n"
  	"\n"
  	"";

	IoState_on_doCString_withLabel_(self, context, s, "_ioCode/Z_Importer.io");

}

