#include "IoState.h"
#include "IoObject.h"

void IoVMCodeInit(IoObject *context)
{
IoState *self = ((IoObject *)context)->tag->state;
	char *s;

	s = "Object do(\n"
  	"    deprecated  := method(Exception raise(\"deprecated method\"))\n"
  	"	//thisMessage := getSlot(\"deprecated\")\n"
  	"	thisBlock   := getSlot(\"deprecated\")\n"
  	"	thisTarget  := getSlot(\"deprecated\")\n"
  	"	sender      := getSlot(\"deprecated\")\n"
  	"	inlineMethod := method(call message argAt(0) setIsActivatable(true))\n"
  	")\n"
  	"\n"
  	"List do(\n"
  	"    unique := method(\n"
  	"        u := List clone\n"
  	"        self foreach(v, u appendIfAbsent(v))\n"
  	"        u\n"
  	"    )\n"
  	"    \n"
  	"	select := method(\n"
  	"     	aList := List clone\n"
  	"\n"
  	"     	a1 := call argAt(0) \n"
  	" 		if(a1 == nil, \n"
  	" 			//writeln(\"List select missing arg\"); \n"
  	" 			Exception raise(\"missing argument\")\n"
  	" 			//writeln(\"List select missing arg done\");\n"
  	" 			return \n"
  	" 		)\n"
  	"    	a2 := call argAt(1) \n"
  	"     	a3 := call argAt(2)\n"
  	"     	\n"
  	"     	if(a3,\n"
  	"     		a1 := a1 name\n"
  	"     		a2 := a2 name\n"
  	"			self foreach(i, v, \n"
  	"				call sender setSlot(a1, i)\n"
  	"				call sender setSlot(a2, getSlot(\"v\"))\n"
  	"     			//call sender doMessage(a3) ifTrue(aList append(getSlot(\"v\")))\n"
  	"     			if(a3 doInContext(call sender, call sender), aList append(getSlot(\"v\")))\n"
  	"			)\n"
  	"			return aList\n"
  	"     	)\n"
  	"     	\n"
  	"     	if(a2,\n"
  	"     		a1 := a1 name\n"
  	"			self foreach(v, \n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"     			//call sender doMessage(a2) ifTrue(aList append(getSlot(\"v\")))\n"
  	"     			if(a2 doInContext(call sender, call sender), aList append(getSlot(\"v\")))\n"
  	"			)\n"
  	"			return aList     	\n"
  	"     	)\n"
  	"     	\n"
  	"     	self foreach(v, \n"
  	"			//getSlot(\"v\") doMessage(a1, call sender) ifTrue(aList append(getSlot(\"v\")))\n"
  	"     		if(a1 doInContext(getSlot(\"v\"), call sender), aList append(getSlot(\"v\")))\n"
  	"     	)\n"
  	"     	aList     	\n"
  	"	)\n"
  	"	\n"
  	"	detect := method(\n"
  	"     	a1 := call argAt(0) \n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"     	a2 := call argAt(1) \n"
  	"     	a3 := call argAt(2)\n"
  	"     	\n"
  	"     	if(a3,\n"
  	"     		a1 := a1 name\n"
  	"     		a2 := a2 name\n"
  	"			self foreach(i, v, \n"
  	"				call sender setSlot(a1, i)\n"
  	"				call sender setSlot(a2, getSlot(\"v\"))\n"
  	"				if(call sender doMessage(a3), return getSlot(\"v\"))\n"
  	"			)\n"
  	"			return nil\n"
  	"     	)\n"
  	"     	\n"
  	"     	if(a2,\n"
  	"     		a1 := a1 name\n"
  	"			self foreach(v, \n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				if(call sender doMessage(a2), return getSlot(\"v\"))\n"
  	"			)\n"
  	"			return nil     	\n"
  	"     	)\n"
  	"     	\n"
  	"     	self foreach(v, if(getSlot(\"v\") doMessage(a1, call sender), return getSlot(\"v\"))\n"
  	"     	)\n"
  	"     	nil     	\n"
  	"	)\n"
  	"\n"
  	"	map := method(\n"
  	"		aList := List clone\n"
  	"		\n"
  	"     	a1 := call argAt(0) \n"
  	"		if(a1 == nil, Exception raise(\"missing argument\"))\n"
  	"     	a2 := call argAt(1) \n"
  	"     	a3 := call argAt(2)\n"
  	"     	\n"
  	"     	if(a2 == nil,\n"
  	"			self foreach(v, \n"
  	"				aList append(getSlot(\"v\") doMessage(a1, call sender))\n"
  	"     		)\n"
  	"     		return aList\n"
  	"     	)\n"
  	"\n"
  	"     	if(a3 == nil,\n"
  	"     		a1 := a1 name\n"
  	"			self foreach(v, \n"
  	"				call sender setSlot(a1, getSlot(\"v\"))\n"
  	"				aList append(call sender doMessage(a2))\n"
  	"			)\n"
  	"			return aList     	\n"
  	"     	)\n"
  	"     	     	\n"
  	"		a1 := a1 name\n"
  	"		a2 := a2 name\n"
  	"		self foreach(i, v, \n"
  	"			call sender setSlot(a1, i)\n"
  	"			call sender setSlot(a2, getSlot(\"v\"))\n"
  	"			aList append(call sender doMessage(a3))\n"
  	"		)\n"
  	"		return aList     	\n"
  	"	)\n"
  	"	\n"
  	"	copy := method(v, self empty; self appendSeq(v); self)\n"
  	"	\n"
  	"	mapInPlace := method(\n"
  	"		self copy(self getSlot(\"map\") performOn(self, call sender, call message))\n"
  	"	)\n"
  	"	\n"
  	"	selectInPlace := method(\n"
  	"		self copy(self getSlot(\"select\") performOn(self, call sender, call message))\n"
  	"	)  \n"
  	"	\n"
  	"	empty := method(self removeAll)\n"
  	"\n"
  	"    isEmpty := method(size == 0)\n"
  	"    isNotEmpty := method(size > 0)\n"
  	"\n"
  	"  sort := method(self clone sortInPlace)\n"
  	"  sortBy := method(b, self clone sortInPlaceBy(getSlot(\"b\")))\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/A0_List.io");

	s = "true setSlot(\"and\", Object getSlot(\"evalArg\"))\n"
  	"false setSlot(\"and\", false)\n"
  	"\n"
  	"nil setSlot(\"ifNil\", Object getSlot(\"evalArgAndReturnSelf\"))\n"
  	"Object setSlot(\"ifNil\", Object getSlot(\"thisContext\"))\n"
  	"\n"
  	"nil setSlot(\"ifNilEval\", Object getSlot(\"evalArg\"))\n"
  	"Object setSlot(\"ifNilEval\", Object getSlot(\"thisContext\"))\n"
  	"\n"
  	"Message do (\n"
  	"	setSlot(\"isRightOperator\",\n"
  	"		method(\n"
  	"			arguments size ==(0) and(OperatorTable rightOperators contains(name))\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	setSlot(\"isLeftOperator\",\n"
  	"		method(\n"
  	"			OperatorTable leftOperators contains(name)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	setSlot(\"operatorPrecedence\",\n"
  	"		method(\n"
  	"			if(arguments size ==(0), OperatorTable operatorPrecedence(name), nil)\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	setSlot(\"opShuffleIo\",\n"
  	"		method(\n"
  	"			setSlot(\"levels\", Levels clone)\n"
  	"			setSlot(\"expressions\", List clone with(self))\n"
  	"\n"
  	"			while(expressions size >=(1),\n"
  	"				setSlot(\"n\", expressions pop)\n"
  	"				while(n,\n"
  	"					setSlot(\"a\", n)\n"
  	"					while(a,\n"
  	"						levels attach(a, expressions)\n"
  	"						expressions appendSeq(a arguments)\n"
  	"						updateSlot(\"a\", a attached)\n"
  	"					)\n"
  	"					levels nextMessage\n"
  	"					updateSlot(\"n\", n next)\n"
  	"				)\n"
  	"			)\n"
  	"			self\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"        setSlot(\"opShuffle\", getSlot(\"opShuffleC\"))\n"
  	"\n"
  	"        useCShuffle := method(self setSlot(\"opShuffle\", getSlot(\"opShuffleC\")))\n"
  	"        useIoShuffle := method(self setSlot(\"opShuffle\", getSlot(\"opShuffleIo\")))\n"
  	"               \n"
  	"        setSlot(\"OperatorTable\",\n"
  	"                Map clone do(\n"
  	"                        setSlot(\"maxPrecedence\", nil)\n"
  	"\n"
  	"                        setSlot(\"contains\", getSlot(\"hasKey\"))\n"
  	"\n"
  	"                        setSlot(\"operatorPrecedence\",\n"
  	"                                method(name,\n"
  	"                                        rightOperators at(name) ifNilEval(leftOperators at(name))\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"leftOperators\",\n"
  	"                                thisContext clone do(\n"
  	"                                        atPut(\":=\", 0)\n"
  	"                                        atPut(\"=\", 0)\n"
  	"                                        updateSlot(\"maxPrecedence\", 0)\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"rightOperators\",\n"
  	"                                thisContext clone do(\n"
  	"                                        atPut(\"@\",   0)\n"
  	"                                        atPut(\"@@\",  0)\n"
  	"                                        atPut(\"'\",   0)\n"
  	"                                        atPut(\".\",   0)\n"
  	"                                        atPut(\"?\",   0)\n"
  	"                                        atPut(\"(\",   0)\n"
  	"                                        atPut(\")\",   0)\n"
  	"                                        atPut(\":\",   0)\n"
  	"                                              \n"
  	"                                        atPut(\"**\",  1)\n"
  	"                                        \n"
  	"                                        atPut(\"++\",  2)\n"
  	"                                        atPut(\"--\",  2)\n"
  	"                                        \n"
  	"                                        atPut(\"*\",   3)\n"
  	"                                        atPut(\"/\",   3)\n"
  	"                                        atPut(\"%\",   3)\n"
  	"                                        \n"
  	"                                        atPut(\"+\",   4)\n"
  	"                                        atPut(\"-\",   4)\n"
  	"                                        \n"
  	"                                        atPut(\"<<\",  5)\n"
  	"                                        atPut(\">>\",  5)\n"
  	"                                        \n"
  	"                                        atPut(\">\",   6)\n"
  	"                                        atPut(\"<\",   6)\n"
  	"                                        atPut(\"<=\",  6)\n"
  	"                                        atPut(\">=\",  6)\n"
  	"                                        \n"
  	"                                        atPut(\"==\",  7)\n"
  	"                                        atPut(\"!=\",  7)\n"
  	"                                        \n"
  	"                                        atPut(\"&\",   8)\n"
  	"                                        \n"
  	"                                        atPut(\"^\",   9)\n"
  	"                                        \n"
  	"                                        atPut(\"|\",   10)\n"
  	"                                        \n"
  	"                                        atPut(\"and\", 11)\n"
  	"                                        atPut(\"&&\",  11)\n"
  	"                                        \n"
  	"                                        atPut(\"or\",  12)\n"
  	"                                        atPut(\"||\",  12)\n"
  	"                                        \n"
  	"                                        atPut(\"..\",  13)\n"
  	"                                        \n"
  	"                                        atPut(\"=\",   14)\n"
  	"                                        atPut(\"+=\",  14)\n"
  	"                                        atPut(\"-=\",  14)\n"
  	"                                        atPut(\"*=\",  14)\n"
  	"                                        atPut(\"/=\",  14)\n"
  	"                                        atPut(\"%=\",  14)\n"
  	"                                        atPut(\"&=\",  14)\n"
  	"                                        atPut(\"^=\",  14)\n"
  	"                                        atPut(\"|=\",  14)\n"
  	"                                        atPut(\"<<=\", 14)\n"
  	"                                        atPut(\">>=\", 14)\n"
  	"                                        atPut(\":=\",  14)\n"
  	"                                        atPut(\"<-\",  14)\n"
  	"                                        atPut(\"<->\", 14)\n"
  	"                                        atPut(\"->\",  14)\n"
  	"                                        \n"
  	"                                        atPut(\"return\", 15)\n"
  	"                                      \n"
  	"                                        atPut(\",\", 16)\n"
  	"\n"
  	"                                        updateSlot(\"maxPrecedence\", 16)\n"
  	"                                )\n"
  	"                        )\n"
  	"                )\n"
  	"        )\n"
  	"\n"
  	"        setSlot(\"Levels\",\n"
  	"                Object clone do(\n"
  	"                        # TODO: Speed up by reusing Level objects (removeAllSlots)\n"
  	"                        # Have a pool of level objects to reuse\n"
  	"                        setSlot(\"stack\", nil)\n"
  	"\n"
  	"                        setSlot(\"init\",\n"
  	"                                method(\n"
  	"                                        reset\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"reset\",\n"
  	"                                method(\n"
  	"                                        updateSlot(\"stack\", List clone with(Level clone setRootLevel))\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"nextMessage\",\n"
  	"                                method(\n"
  	"                                        stack reverseForeach(msg, msg finish)\n"
  	"                                        reset\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"currentLevel\",\n"
  	"                                method(\n"
  	"                                        stack last\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"currentPrecedence\",\n"
  	"                                method(\n"
  	"                                        currentLevel precedence\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"popDownTo\",\n"
  	"                                method(targetLevel,\n"
  	"                                        while(currentPrecedence <=(targetLevel) and(currentLevel isNotAttachingArgs),\n"
  	"                                                currentLevel finish\n"
  	"                                                stack pop\n"
  	"                                        )\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"attachToTopAndPush\",\n"
  	"                                method(msg,\n"
  	"                                        currentLevel attachAndReplace(msg)\n"
  	"                                        stack push(Level clone setAwaitingFirstArg(msg))\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"attach\",\n"
  	"                                method(msg, expressions,\n"
  	"                                        if(msg isLeftOperator,\n"
  	"                                                attachLeftOperator(msg, expressions)\n"
  	"                                                return\n"
  	"                                        )\n"
  	"                                        if(msg isRightOperator,\n"
  	"                                                attachRightOperator(msg)\n"
  	"                                                return\n"
  	"                                        )\n"
  	"\n"
  	"                                        currentLevel attachAndReplace(msg)\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"attachRightOperator\",\n"
  	"                                method(msg,\n"
  	"                                        if(msg argCount >(0),\n"
  	"                                                currentLevel setAlreadyHasArgs(msg)\n"
  	"                                        ,\n"
  	"                                                popDownTo(msg operatorPrecedence)\n"
  	"                                                attachToTopAndPush(msg)\n"
  	"                                        )\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"attachLeftOperator\",\n"
  	"                                method(msg, expressions,\n"
  	"                                        setSlot(\"attaching\", currentLevel msg)\n"
  	"\n"
  	"                                        attaching ifNil(\n"
  	"                                                Exception raise(\"compile error: \" ..(msg name) ..(\" requires a symbol to its left.\"))\n"
  	"                                        )\n"
  	"\n"
  	"                                        if(attaching argCount >(0),\n"
  	"                                                Exception raise(\"compile error: The symbol to the left of \" ..(msg name) ..(\" cannot have arguments.\"))\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"slotName\", attaching name)\n"
  	"                                        setSlot(\"quotedSlotName\", slotName Sequence clone appendSeq(\"\\\"\", slotName asMutable replaceSeq(\"\\\"\", \"\\\\\\\"\"), \"\\\"\"))\n"
  	"                                        setSlot(\"slotNameMessage\", Message clone setName(quotedSlotName) setCachedResult(slotName))\n"
  	"                                        \n"
  	"                                        attaching appendArg(slotNameMessage)\n"
  	"\n"
  	"                                        setSlot(\"setSlotName\",\n"
  	"                                                if(msg name ==(\":=\"),\n"
  	"                                                        if(slotName at(0) isUppercase, \"setSlotWithType\", \"setSlot\")\n"
  	"                                                ,\n"
  	"                                                        \"updateSlot\"\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        attaching setName(setSlotName)\n"
  	"                                        currentLevel setAssignment\n"
  	"\n"
  	"                                        if(msg argCount >(0),\n"
  	"                                                attaching appendArg(\n"
  	"                                                        Message clone setName(\"\") appendArg(msg argAt(0)) setAttached(msg attached)\n"
  	"                                                )\n"
  	"                                        ,\n"
  	"                                                msg attached ifNil(\n"
  	"                                                        Exception raise(\"compile error: \" ..(msg name) ..(\" must be followed by a value.\"))\n"
  	"                                                )\n"
  	"\n"
  	"                                                attaching appendArg(msg attached)\n"
  	"                                        )\n"
  	"\n"
  	"                                        expressions append(msg attached)\n"
  	"\n"
  	"                                        attaching setAttached(nil) removeCachedResult\n"
  	"                                        msg setAttached(nil)\n"
  	"                                )\n"
  	"                        )\n"
  	"\n"
  	"                        setSlot(\"Level\",\n"
  	"                                Object clone do(\n"
  	"                                        setSlot(\"maxPrecedence\", 18)\n"
  	"\n"
  	"                                        setSlot(\"msg\", nil)\n"
  	"                                        setSlot(\"precedence\", nil)\n"
  	"                                        setSlot(\"attach\", nil)\n"
  	"                                        setSlot(\"attachBehaviourName\", nil)\n"
  	"\n"
  	"                                        setSlot(\"finish\",\n"
  	"                                                method(\n"
  	"                                                        if(msg, msg setAttached(nil))\n"
  	"                                                        changeAttachBehaviour(\"attachNop\")\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"changeAttachBehaviour\",\n"
  	"                                                method(name,\n"
  	"                                                        updateSlot(\"attachBehaviourName\", name)\n"
  	"                                                        updateSlot(\"attach\", self getSlot(name))\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"attachAttach\", method(m, msg setAttached(m)))\n"
  	"                                        setSlot(\"attachArg\", method(m, msg appendArg(m)))\n"
  	"                                        setSlot(\"attachNew\", method(m, updateSlot(\"msg\", m)))\n"
  	"                                        setSlot(\"attachNop\", nil)\n"
  	"                                        \n"
  	"                                        changeAttachBehaviour(\"attachNop\")\n"
  	"\n"
  	"                                        setSlot(\"attachAndReplace\",\n"
  	"                                                method(m,\n"
  	"                                                        attach(m)\n"
  	"                                                        updateSlot(\"msg\", m)\n"
  	"                                                        changeAttachBehaviour(\"attachAttach\")\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"setAwaitingFirstArg\",\n"
  	"                                                method(m,\n"
  	"                                                        updateSlot(\"msg\", m)\n"
  	"                                                        self updateSlot(\"precedence\", m operatorPrecedence)\n"
  	"                                                        changeAttachBehaviour(\"attachArg\")\n"
  	"                                                        self\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"setAlreadyHasArgs\",\n"
  	"                                                method(m,\n"
  	"                                                        changeAttachBehaviour(\"attachAttach\")\n"
  	"                                                        updateSlot(\"msg\", m)\n"
  	"                                                        self\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"setRootLevel\",\n"
  	"                                                method(\n"
  	"                                                        updateSlot(\"precedence\", maxPrecedence)\n"
  	"                                                        changeAttachBehaviour(\"attachNew\")\n"
  	"                                                        self\n"
  	"                                                )\n"
  	"                                        )\n"
  	"\n"
  	"                                        setSlot(\"setAssignment\", method(changeAttachBehaviour(\"attachAttach\")))\n"
  	"\n"
  	"                                        setSlot(\"isNotAttachingArgs\",\n"
  	"                                                method(self getSlot(\"attachArg\") !=(self getSlot(\"attach\")))\n"
  	"                                        )\n"
  	"                                )\n"
  	"                        )\n"
  	"                )\n"
  	"        )\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/A1_optransform.io");

	s = "/*\n"
  	"nil ioDoc(\n"
  	"  docCopyright(\"Steve Dekorte\", 2002)\n"
  	"  docLicense(\"BSD revised\")\n"
  	"  docObject(\"nil\")\n"
  	"  docDescription(\"nil is a singleton object that is used as a placeholder and to mean false in Io.\")\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"     docSlot(\"clone\", \"returns self since nil is a singleton.\")\n"
  	"	clone := nil\n"
  	"\n"
  	"	docSlot(\"and(expression)\", \"Returns nil without evaluating expression.\")\n"
  	"	setSlot(\"and\", nil)\n"
  	"\n"
  	"	elseif := Object getSlot(\"if\")\n"
  	"\n"
  	"	docSlot(\"then(expression)\", \"Returns nil without evaluating expression.\")\n"
  	"	setSlot(\"then\", nil)\n"
  	"\n"
  	"	docSlot(\"else(expression)\", \"Returns nil without evaluating expression.\")\n"
  	"	setSlot(\"else\", method(v, v))\n"
  	"\n"
  	"	docSlot(\"or(anObject)\", \"Returns anObject if anObject is not nil. Otherwise returns nil.\")\n"
  	"	setSlot(\"or\", method(v, if(v, v, nil)))\n"
  	"\n"
  	"	docSlot(\"print\", \"Prints 'nil'. Returns self.\")\n"
  	"	print := method(write(\"nil\"))\n"
  	"\n"
  	"	setSlot(\"==\", method(v, self isIdenticalTo(v))\n"
  	"	setSlot(\"!=\", method(v, self isIdenticalTo(v) not)\n"
  	"\n"
  	"	docSlot(\"isNil\", \"Returns Lobby.\")\n"
  	"	isNil := Lobby\n"
  	"\n"
  	"	docSlot(\"ifNil(expression)\", \"Evaluates message.\")\n"
  	"	ifNil := method(v, v)  \n"
  	")\n"
  	"*/\n"
  	"\n"
  	"// if(a == 1) then(b) elseif(b == c) then(d) else(f)\n"
  	"// (a == 1) ifTrue(b) ifFalse(c)\n"
  	"\n"
  	"true do(\n"
  	"	then    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"	elseif  := true\n"
  	"	else    := true\n"
  	"	ifTrue  := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	ifFalse := true\n"
  	"	setSlot(\"and\", Object getSlot(\"evalArg\"))\n"
  	"	setSlot(\"or\", true)\n"
  	"	asString := \"true\"\n"
  	"	asSimpleString := \"true\"\n"
  	"	not := false\n"
  	"	clone := true\n"
  	")\n"
  	"\n"
  	"false do(\n"
  	"	then    := false\n"
  	"	elseif  := Object getSlot(\"if\")\n"
  	"	else    := Object getSlot(\"evalArgAndReturnNil\")\n"
  	"	ifTrue  := false\n"
  	"	ifFalse := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	setSlot(\"and\", false)\n"
  	"	setSlot(\"or\", Object getSlot(\"evalArg\"))\n"
  	"	\n"
  	"	type := \"false\"\n"
  	"	asString := \"false\"\n"
  	"	asSimpleString := \"false\"\n"
  	"	not := true\n"
  	"	clone := false\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	isNil := true\n"
  	"	\n"
  	"	ifNonNil := Object getSlot(\"thisContext\")\n"
  	"    ifNil := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	\n"
  	"	ifNilEval    := Object getSlot(\"evalArg\")\n"
  	"	ifNonNilEval := Object getSlot(\"thisContext\")	\n"
  	"	\n"
  	"	type := \"nil\"\n"
  	"	asString := type\n"
  	"	asSimpleString := type\n"
  	"	\n"
  	"	setSlot(\"and\", false)\n"
  	"	setSlot(\"or\", Object getSlot(\"evalArg\"))\n"
  	"	then := nil\n"
  	"	else := nil\n"
  	"	elseif := nil\n"
  	"	clone := nil\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	isNil := false\n"
  	"	\n"
  	"	ifNil := Object getSlot(\"thisContext\")\n"
  	"    ifNonNil := Object getSlot(\"evalArgAndReturnSelf\")\n"
  	"	\n"
  	"	ifNonNilEval := Object getSlot(\"evalArg\")\n"
  	"	ifNilEval    := Object getSlot(\"thisContext\")	\n"
  	"	\n"
  	"	setSlot(\"and\", Object getSlot(\"evalArg\"))\n"
  	"	setSlot(\"or\", true)\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"    makeFirstCharacterLowercase := method(\n"
  	"	   if(self size > 0, self atPut(0, self at(0) asLowercase))\n"
  	"    )\n"
  	"\n"
  	"    makeFirstCharacterUppercase := method(\n"
  	"	   if(self size > 0, self atPut(0, self at(0) asUppercase))\n"
  	"    )\n"
  	"\n"
  	"    slicesBetween := method(startSeq, endSeq,\n"
  	"        chunks := List clone\n"
  	"        lastIndex := 0\n"
  	"        while (startIndex := self findSeq(startSeq, lastIndex),\n"
  	"            endIndex := self findSeq(endSeq, startIndex + startSeq size)\n"
  	"            endIndex ifNil(break)\n"
  	"            chunks append(self slice(startIndex + startSeq size, endIndex))\n"
  	"            lastIndex := endIndex + endSeq size\n"
  	"        )\n"
  	"        chunks\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"    hasSlot := method(n,\n"
  	"        getSlot(\"self\") hasLocalSlot(n) or(getSlot(\"self\") ancestorWithSlot(n) != nil)\n"
  	"    )\n"
  	"\n"
  	"    docsSlot := method(\n"
  	"	   if(getSlot(\"self\") hasLocalSlot(\"docs\"), \n"
  	"	   getSlot(\"self\") docs, \n"
  	"	   getSlot(\"self\") docs := Object clone do(slots := Object clone)\n"
  	"	   )\n"
  	"    )\n"
  	"    \n"
  	"    docSlot := method(k, v, \n"
  	"        entry := Object clone \n"
  	"        entry description := v asSymbol\n"
  	"        if (k containsSeq(\"(\"), \n"
  	"            entry args := k afterSeq(\"(\") beforeSeq(\")\") split(\",\") map(strip)\n"
  	"        )	\n"
  	"        getSlot(\"self\") docsSlot slots setSlot(k beforeSeq(\"(\"), entry)\n"
  	"    \n"
  	"        //self docsSlot slots setSlot(k beforeSeq(\"(\"), v)\n"
  	"        //writeln(\"docSlot(\", k, \", \", self docsSlot slots getSlot(k), \")\")\n"
  	"    )\n"
  	"    \n"
  	"    //docSlot := nil\n"
  	"    \n"
  	"    docCopyright := method(v, \n"
  	"	   k := call message name asMutable removePrefix(\"doc\") makeFirstCharacterLowercase\n"
  	"	   getSlot(\"self\") docsSlot setSlot(k, v)\n"
  	"    )\n"
  	" \n"
  	"    //list(\"docLicense\", \"docObject\", \"docDescription\", \"docCredits\", \"docInclude\", \"docDependsOn\", \"docCategory\") foreach(name, setSlot(name, getSlot(\"docCopyright\")))\n"
  	"    docLicense := getSlot(\"docCopyright\")\n"
  	"    docObject := getSlot(\"docCopyright\")\n"
  	"    docDescription := getSlot(\"docCopyright\")\n"
  	"    docCredits := getSlot(\"docCopyright\")\n"
  	"    docInclude := getSlot(\"docCopyright\")\n"
  	"    docDependsOn := getSlot(\"docCopyright\")\n"
  	"    docCategory := getSlot(\"docCopyright\")\n"
  	"\n"
  	"    ioDoc := method(\n"
  	"	   //docsSlot\n"
  	"	   if(call argAt(0), getSlot(\"self\") doMessage(call argAt(0)))\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"list(...)\", \"Returns a List containing the arguments.\")\n"
  	"    list := method(call message argsEvaluatedIn(call sender))\n"
  	"    \n"
  	"    docSlot(\"..(arg)\", \".. is an alias for: method(arg, self asString append(arg asString))\")\n"
  	"    setSlot(\"..\", method(arg, getSlot(\"self\") asString .. arg asString))\n"
  	"    \n"
  	"    Map addKeysAndValues := method(keys, values, keys foreach(i, k, self atPut(k, values at(i))); self)\n"
  	"    \n"
  	"    slotDescriptionMap := method(\n"
  	"        slotNames := getSlot(\"self\") slotNames sort \n"
  	"        slotDescs := slotNames map(name, getSlot(\"self\") getSlot(name) asSimpleString)\n"
  	"        Map clone addKeysAndValues(slotNames, slotDescs) \n"
  	"    )\n"
  	"    \n"
  	"    slotSummary := method(\n"
  	"        if(getSlot(\"self\") type == \"Block\", return getSlot(\"self\") asSimpleString)\n"
  	"        s := Sequence clone\n"
  	"        s appendSeq(\" \", getSlot(\"self\") asSimpleString, \":\\n\")\n"
  	"        slotDescriptionMap foreach(k, v, s appendSeq(\"  \", k alignLeft(16), \" = \", getSlot(\"v\"), \"\\n\"))\n"
  	"        s\n"
  	"    )\n"
  	"    \n"
  	"    asString := getSlot(\"slotSummary\")\n"
  	"    \n"
  	"    //asSimpleString := method(getSlot(\"self\") type)\n"
  	"    asSimpleString := method(getSlot(\"self\") type .. \"_\" .. getSlot(\"self\") uniqueHexId)\n"
  	"    \n"
  	"    docSlot(\"newSlot(slotName, aValue)\", \n"
  	"    \"\"\"Creates a getter and setter for the slot with the name slotName \n"
  	"    and sets it's default the value aValue. Returns self. For example, \n"
  	"    newSlot(\"foo\", 1) would create slot named foo with the value 1 as well as a setter method setFoo().\"\"\")\n"
  	"\n"
  	"    newSlot := method(name, value, doc,\n"
  	"		getSlot(\"self\") setSlot(name, value)\n"
  	"		getSlot(\"self\") setSlot(\"set\" .. name asCapitalized, \n"
  	"			doString(\"method(\" .. name .. \" = call evalArgAt(0); self)\"))\n"
  	"			if(doc, getSlot(\"self\") docSlot(name, doc))\n"
  	"		value\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"launchFile(pathString)\", \n"
  	"    \"Eval file at pathString as if from the command line in it's folder.\")\n"
  	"    \n"
  	"    launchFile := method(path, args,\n"
  	"        args ifNil(args = List clone)\n"
  	"        Lobby args := args\n"
  	"        Lobby launchPath :=  path pathComponent\n"
  	"        Directory setCurrentWorkingDirectory(Lobby launchPath)\n"
  	"        self doFile(path)\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"println\", \"Same as print, but also prints a new line. Returns self.\")\n"
  	"    println := method(self print; write(\"\\n\"); self)\n"
  	"\n"
  	"    docSlot(\"?(aMessage)\", \"\"\"\n"
  	"    description: Sends the message aMessage to the receiver if it can respond to it. Example:\n"
  	"    <pre>\n"
  	"    MyObject test // performs test\n"
  	"    MyObject ?test // performs test if MyObject has a slot named test\n"
  	"    </pre>\n"
  	"    The search for the slot only follows the receivers proto chain. \n"
  	"    \"\"\")\n"
  	"\n"
  	"    setSlot(\"?\", method(\n"
  	"	   m := call argAt(0)\n"
  	"	   if (self getSlot(m name) != nil, self doMessage(m, call sender), nil)\n"
  	"    ))\n"
  	"\n"
  	"    docSlot(\"ancestors\", \n"
  	"    \"Returns a list of all of the receiver's ancestors as found by recursively following the protos links.\") \n"
  	"\n"
  	"    ancestors := method(a, \n"
  	"        if(a, if(a detect(x, x isIdenticalTo(self)), return a), a = List clone)\n"
  	"        a append(self)\n"
  	"        self protos foreach(ancestors(a))\n"
  	"        a\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"isKindOf(anObject)\", \"Returns true if anObject is in the receiver's ancestors.\") \n"
  	"\n"
  	"    isKindOf := method(anObject, getSlot(\"self\") ancestors contains(getSlot(\"anObject\")))\n"
  	"    \n"
  	"    docSlot(\"super(aMessage)\", \n"
  	"    \"\"\"Sends the message aMessage to the receiver's proto with the context of self. Example:\n"
  	"    <pre>\n"
  	"    self test(1, 2)   // performs test(1, 2) on self\n"
  	"    super(test(1, 2)) // performs test(1, 2) on self proto but with the context of self\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"\n"
  	"  setSlot(\"super\", method(\n"
  	"    senderSlotContext := call sender call slotContext\n"
  	"	m := call argAt(0)\n"
  	"	m ifNil(Exception raise(\"Object super requires an argument\"))\n"
  	"	senderSlotContext ifNil(Exception raise(\"Object super called outside of block context\"))\n"
  	"	slotName := m name\n"
  	"	ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"    if(ancestor == nil,\n"
  	"        slotName = \"forward\"\n"
  	"        ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"    )\n"
  	"	if(ancestor isIdenticalTo(senderSlotContext), Exception raise(\"Object super slot \" .. slotName .. \" not found\"))\n"
  	"	b := ancestor getSlot(slotName)\n"
  	"	if(getSlot(\"b\") isActivatable == false, \n"
  	"	   b, \n"
  	"	   getSlot(\"b\") performOn(call sender call target, call sender, m, ancestor)\n"
  	"	   //ancestor doMessage(slotName, call sender, self)\n"
  	"	)\n"
  	"  ))\n"
  	"\n"
  	"    docSlot(\"resend\", \n"
  	"    \"\"\"Send the message used to activate the current method to the Object's proto.\n"
  	"    For example;\n"
  	"    <pre>\n"
  	"    Dog := Mammal clone do(\n"
  	"	init := method(\n"
  	"	    resend\n"
  	"	)\n"
  	"    )\n"
  	"    </pre>\n"
  	"    calling Dog init will send an init method to Mammal, but using the Dog's context.\n"
  	"    \"\"\")\n"
  	"\n"
  	"	setSlot(\"resend\", method(\n"
  	"		senderSlotContext := call sender call slotContext\n"
  	"		senderSlotContext ifNil(Exception raise(\"Object resend called outside of block context\"))\n"
  	"		m := call sender call message\n"
  	"		slotName := m name\n"
  	"		ancestor := senderSlotContext ancestorWithSlot(slotName)\n"
  	"		\n"
  	"        if(ancestor isIdenticalTo(nil),\n"
  	"            slotName = \"forward\"\n"
  	"            ancestor = senderSlotContext ancestorWithSlot(slotName)\n"
  	"        )\n"
  	"\n"
  	"        if(ancestor isIdenticalTo(senderSlotContext),\n"
  	"            Exception raise(\"Object resend slot \" .. slotName .. \" not found\")\n"
  	"        )\n"
  	"        \n"
  	"        b := ancestor getSlot(slotName) \n"
  	"        if(getSlot(\"b\") != nil, \n"
  	"            getSlot(\"b\") performOn(call sender getSlot(\"self\"), call sender call sender, m, ancestor)\n"
  	"        , \n"
  	"            getSlot(\"b\")\n"
  	"        )\n"
  	"    ))\n"
  	"\n"
  	"\n"
  	"    docSlot(\"list(...)\", \"Returns a List containing the arguments.\")\n"
  	"    list := method(call message argsEvaluatedIn(call sender))\n"
  	"\n"
  	"    Object print := method(write(getSlot(\"self\") asString))\n"
  	"\n"
  	"    docSlot(\"println\", \"Same as print, but also prints a new line. Returns self.\")\n"
  	"    println := method(getSlot(\"self\") print; write(\"\\n\"); getSlot(\"self\"))\n"
  	"\n"
  	"    docSlot(\"in(aList)\", \"Same as: aList contains(self)\")\n"
  	"    in := method(aList, aList contains(self)) \n"
  	"\n"
  	"	uniqueHexId := method(\"0x\" .. getSlot(\"self\") uniqueId asString toBase(16))\n"
  	"	\n"
  	"	lazySlot := method(name,\n"
  	"		m := ((\"self setSlot(\\\"\" .. name .. \"\\\", \" .. call message argAt(1) code .. \")\") asMessage)\n"
  	"        self setSlot(name, method(1) setMessage(m))\n"
  	"        nil\n"
  	"	)\n"
  	"	\n"
  	"	foreachSlot := method(\n"
  	"		self slotNames sort foreach(n,\n"
  	"			call sender setSlot(call message argAt(0) name, n)\n"
  	"			call sender setSlot(call message argAt(1) name, getSlot(\"self\") getSlot(n))\n"
  	"			call sender doMessage(call message argAt(2))\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/A2_Object.io");

	s = "\n"
  	"List do(\n"
  	"    docSlot(\"sum\", \"Returns the sum of the items.\")\n"
  	"    sum := method(s := 0; self foreach(v, s = s + v); s)\n"
  	"\n"
  	"    docSlot(\"average\", \"Returns the average of the items.\")\n"
  	"    average := method(self sum / self size)\n"
  	"\n"
  	"    docSlot(\"shuffle\", \"Randomizes the order of the elements in the receiver. Returns self.\")\n"
  	"    shuffle := method(for(i, 0, size - 1, swapIndices(i, Random value(i, size) floor)))\n"
  	"\n"
  	"    docSlot(\"anyOne\", \"Returns a random element of the receiver or nil if the receiver is empty.\")\n"
  	"    anyOne := method(at(Random value(0, size) floor))\n"
  	" \n"
  	"    docSlot(\"removeFirst\", \"Returns the first item and removes it from the list. nil is returned if the list is empty.\")\n"
  	"    removeFirst := method(if(self size != 0, removeAt(0), nil))\n"
  	"\n"
  	"    docSlot(\"removeLast\", \"Returns the last item and removes it from the list. nil is returned if the list is empty.\")\n"
  	"    removeLast := method(self pop)\n"
  	"\n"
  	"    docSlot(\"removeSeq\", \"Removes each of the items from the current list which are contained in the sequence passed in.\")\n"
  	"    removeSeq := method(seq,\n"
  	"	    seq foreach(x, self remove(x))\n"
  	"	    self\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"join(optionalString)\", \"Returns a Sequence of the concatenated items with optionalString between each item or simply the concatenation of the items if no optionalString is supplied.\")\n"
  	"    join := method(arg,\n"
  	"        s := if(self first type == \"List\", List clone, Sequence clone)\n"
  	"\n"
  	"		if(arg) then(\n"
  	"			max := self size - 1\n"
  	"			self foreach(i, v, s appendSeq(v); if(i != max, s appendSeq(arg)))\n"
  	"		) else(\n"
  	"			self foreach(v, s appendSeq(v))\n"
  	"		)\n"
  	"		\n"
  	"		s\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"insertAfter(item, afterItem)\", \"Inserts item after first occurance of afterItem and returns self. If afterItem is not found, item is appended to the end of the list.\")\n"
  	"    insertAfter := method(item, afterItem,\n"
  	"       i := self indexOf(afterItem) \n"
  	"       if(i, self atInsert(i + 1, item), self append(item))\n"
  	"       self\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"insertBefore(item, beforeItem)\", \"Inserts item before first occurance of beforeItem or to the end of the list if beforeItem is not found. Returns self.\")\n"
  	"    insertBefore := method(item, beforeItem,\n"
  	"       i := self indexOf(beforeItem)\n"
  	"       if(i, self atInsert(i, item), self append(item))\n"
  	"       self\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"insertAt(item, index)\", \"Inserts item at the specified index. Raises an exception if the index is out of bounds. Returns self.\")\n"
  	"    insertAt := method(item, index, self atInsert(index, item))\n"
  	"    \n"
  	"    asString := method(\n"
  	"    	s := \"list(\" asMutable\n"
  	"    	self foreach(i, v, \n"
  	"    		s appendSeq(getSlot(\"v\") asSimpleString)\n"
  	"    		if (i != self size - 1, s appendSeq(\", \"))\n"
  	"    	)\n"
  	"     	s appendSeq(\")\")\n"
  	"     )\n"
  	"     \n"
  	"     max := method(\n"
  	"     	m := call argAt(0) \n"
  	"     	obj := self first\n"
  	"     	self foreach(o, \n"
  	"     		v1 := if(m, o doMessage(m, call sender), o)\n"
  	"     		v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"     		if(v1 > v2, obj := o)\n"
  	"     	)\n"
  	"     	obj\n"
  	"     )\n"
  	"     \n"
  	"     min := method(\n"
  	"     	m := call argAt(0) \n"
  	"     	obj := self first\n"
  	"     	self foreach(o, \n"
  	"     		v1 := if(m, o doMessage(m, call sender), o)\n"
  	"     		v2 := if(m, obj doMessage(m, call sender), obj)\n"
  	"     		if(v1 < v2, obj := o)\n"
  	"     	)\n"
  	"     	obj\n"
  	"     )\n"
  	"     \n"
  	"  docSlot(\"flatten\", \"\"\"Creates a new list, with all contained lists flattened into the new list. For example:\n"
  	"<pre>\n"
  	"list(1,2,list(3,4,list(5))) flatten\n"
  	"==> list(1, 2, 3, 4, 5)\n"
  	"</pre>\n"
  	"  \"\"\")\n"
  	"  List flatten := method(\n"
  	"    l := List clone\n"
  	"    self foreach(v,\n"
  	"      if(getSlot(\"v\") type == \"List\",\n"
  	"        l appendSeq(getSlot(\"v\") flatten)\n"
  	"      ,\n"
  	"        l append(getSlot(\"v\")))\n"
  	"      )\n"
  	"    l\n"
  	"  )\n"
  	"\n"
  	"	docSlot(\"asMessage\", \"Converts each element in the list to unnamed messages with their cached result set to the value of the element (without activating). Returns an unnamed message whose arguments map 1:1 with the elements (after being converted to messages themselves).\")\n"
  	"	asMessage := method(\n"
  	"		m := Message clone\n"
  	"		foreach(elem,\n"
  	"			m setArguments(\n"
  	"				m arguments append(Message clone setCachedResult(getSlot(\"elem\")))\n"
  	"			)\n"
  	"		)\n"
  	"		m\n"
  	"	)\n"
  	"     \n"
  	"	docSlot(\"select(optionalIndex, value, message)\", \n"
  	"		   \"Like foreach, but the values for which the result of \n"
  	"message are non-Nil are returned in a new List. Example:\n"
  	"<pre>list(1, 5, 7, 2) select(i, v, v > 3) print\n"
  	"==> 5, 7\n"
  	"\n"
  	"list(1, 5, 7, 2) select(v, v > 3) print\n"
  	"==> 5, 7</pre>\")     \n"
  	"     \n"
  	"	docSlot(\"detect(optionalIndex, value, message)\", \n"
  	"		   \"Returns the first value for which the message evaluates to a non-Nil. Example:\n"
  	"<pre>list(1, 2, 3, 4) detect(i, v, v > 2)\n"
  	"==> 3\n"
  	"\n"
  	"list(1, 2, 3, 4) detect(v, v > 2)\n"
  	"==> 3</pre>\")\n"
  	"\n"
  	"	docSlot(\"map(optionalIndex, value, message)\", \"Same as calling mapInPlace() on a clone of the receiver, but more efficient.\")\n"
  	"	\n"
  	"	docSlot(\"cusor\", \"Returns a ListCursor for the receiver.\")\n"
  	"	cursor := method(ListCursor clone setCollection(self)) \n"
  	"\n"
  	"    docSlot(\"containsAll(list)\", \"Returns true the target contains all of the items in the argument list.\")\n"
  	"    containsAll := method(c, c detect(i, contains(i) not) == nil) \n"
  	"\n"
  	"    docSlot(\"containsAny(list)\", \"Returns true the target contains any of the items in the argument list.\")\n"
  	"    containsAny := method(c, c detect(i, contains(i)) != nil) \n"
  	"\n"
  	"    docSlot(\"intersect(list)\", \"Returns a new list containing the common values from the target and argument lists.\")\n"
  	"    intersect := method(c, c select(i, contains(i)))\n"
  	"\n"
  	"    docSlot(\"difference(list)\", \"Returns a new list containing items from the target list which aren't in the argument list.\")\n"
  	"    difference := method(c, select(i, c contains(i) not))\n"
  	"\n"
  	"    docSlot(\"union(list)\", \"Returns a new list containing items from the target and items which are only in the argument list.\")\n"
  	"    union := method(c, self clone appendSeq(c difference(self)))\n"
  	"\n"
  	"    docSlot(\"unique\", \"Returns a new list containing all the values in the target, but no duplicates.\")\n"
  	"    unique := method(a := list; self foreach(v, a appendIfAbsent(v)); a)\n"
  	"\n"
  	"		docSlot(\"reduce\", \"Also known as foldl or inject. Combines values in target start on the left. reduce(+) or reduce(x, y, x + y).\")\n"
  	"		reduce := method(\n"
  	"			accu := first\n"
  	"			if(call message arguments size == 1,\n"
  	"				args := list(nil)\n"
  	"				meth := call argAt(0) name\n"
  	"				slice(1) foreach(x, accu = accu performWithArgList(meth, args atPut(0, x)))\n"
  	"			,\n"
  	"				aName := call argAt(0) name\n"
  	"				bName := call argAt(1) name\n"
  	"				body := call argAt(2)\n"
  	"				slice(1) foreach(x,\n"
  	"					call sender setSlot(aName, accu)\n"
  	"					call sender setSlot(bName, x)\n"
  	"					accu = call sender doMessage(body, call sender)\n"
  	"				)\n"
  	"			)\n"
  	"			accu\n"
  	"		)\n"
  	"\n"
  	"		docSlot(\"reverseReduce\", \"Also known as foldr and inject. Combines values in target starting on the right. reverseReduce(+) or reverseReduce(x, y, x + y).\")\n"
  	"		reverseReduce := method(\n"
  	"			accu := last\n"
  	"			if(call message arguments size == 1,\n"
  	"				args := list(nil)\n"
  	"				meth := call argAt(0) name\n"
  	"				slice(0, -1) reverseForeach(x, accu = x performWithArgList(meth, args atPut(0, accu)))\n"
  	"			,\n"
  	"				aName := call argAt(0) name\n"
  	"				bName := call argAt(1) name\n"
  	"				body := call argAt(2)\n"
  	"				slice(0, -1) reverseForeach(x,\n"
  	"					call sender setSlot(aName, x)\n"
  	"					call sender setSlot(bName, accu)\n"
  	"					accu = call sender doMessage(body, call sender)\n"
  	"				)\n"
  	"			)\n"
  	"			accu\n"
  	"		)\n"
  	"		\n"
  	"		\n"
  	"		mapFromKey := method(\n"
  	"		  e := call argAt(0)\n"
  	"		  m := Map clone\n"
  	"		  self foreach(v,		      \n"
  	"		      k := getSlot(\"v\") doMessage(e) \n"
  	"		      l := m at(k) \n"
  	"		      if(l, l append(getSlot(\"v\")), m atPut(k, list(getSlot(\"v\"))))\n"
  	"		  )\n"
  	"		  m\n"
  	"		)\n"
  	")\n"
  	"\n"
  	"List ListCursor := Object clone do(\n"
  	"	newSlot(\"index\", 0)\n"
  	"	newSlot(\"collection\")\n"
  	"	next := method(index = index + 1; max := (collection size - 1); if(index > max, index = max; false, true))\n"
  	"	previous := method(index = index - 1; if(index < 0, index = 0; false, true))\n"
  	"	value := method(collection at(index))\n"
  	"	insert := method(v, collection atInsert(index, getSlot(\"v\")))\n"
  	"	remove := method(v, collection removeAt(index))\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/A3_List.io");

	s = "Call do(\n"
  	"	docSlot(\"description\", \"Returns a description of the receiver as a String.\")\n"
  	"\n"
  	"	description := method(\n"
  	"		m := self message\n"
  	"		s := self target type .. \" \" .. m name\n"
  	"                s alignLeft(36) .. m label lastPathComponent .. \" \" .. m lineNumber\n"
  	"	)\n"
  	"\n"
  	"	delegateTo := method(target, altSender,\n"
  	"		target doMessage(self message clone setNext, altSender ifNilEval(self sender))\n"
  	"	)\n"
  	"\n"
  	"        delegateToMethod := method(target, methodName,\n"
  	"                target doMessage(self message clone setNext setName(methodName), self sender)\n"
  	"        )\n"
  	"\n"
  	"	evalArgs := method(\n"
  	"		self message argsEvaluatedIn(sender)\n"
  	"	)\n"
  	"\n"
  	"        hasArgs := method(\n"
  	"                argCount > 0\n"
  	"        )\n"
  	"\n"
  	"        argCount := method(\n"
  	"                self message argCount\n"
  	"        )\n"
  	")\n"
  	"\n"
  	"Message description := method(\n"
  	"	self name alignLeft(36) .. self label lastPathComponent .. \" \" .. self lineNumber	\n"
  	")\n"
  	"	\n"
  	"Scheduler := Object clone do(\n"
  	"	newSlot(\"yieldingCoros\", List clone)\n"
  	"	newSlot(\"timers\", List clone)\n"
  	"	currentCoroutine := method(Coroutine currentCoroutine)\n"
  	")\n"
  	"\n"
  	"Coroutine do(\n"
  	"	type := \"Coroutine\"\n"
  	"	newSlot(\"exception\", nil)\n"
  	"	newSlot(\"parentCoroutine\", nil)\n"
  	"	newSlot(\"runTarget\", nil)\n"
  	"	newSlot(\"runLocals\", nil)\n"
  	"	newSlot(\"runMessage\", nil)\n"
  	"	newSlot(\"result\", nil)\n"
  	"	newSlot(\"label\", \"\")\n"
  	"	newSlot(\"inException\", false)\n"
  	"	\n"
  	"	newSlot(\"yieldingCoros\", List clone)\n"
  	"	\n"
  	"	label := method(self uniqueId)\n"
  	"	\n"
  	"	showYielding := method(s,\n"
  	"		writeln(\"   \", label, \" \", s)\n"
  	"		yieldingCoros foreach(v, writeln(\"    \", v uniqueId))\n"
  	"	)\n"
  	"	\n"
  	"	resumeLater := method(\n"
  	"        yieldingCoros remove(self)\n"
  	"		yieldingCoros atInsert(0, self)\n"
  	"	)\n"
  	"\n"
  	"    isYielding := method(\n"
  	"        yieldingCoros contains(self)\n"
  	"    )\n"
  	"    \n"
  	"	yield := method(\n"
  	"		//showYielding(\"yield\")\n"
  	"		//writeln(\"Coro \", self uniqueId, \" yielding - yieldingCoros = \", yieldingCoros size)\n"
  	"		yieldingCoros remove(self)\n"
  	"		yieldingCoros atInsert(0, self)\n"
  	"		next := yieldingCoros removeFirst \n"
  	"		//writeln(\"Coro \", next uniqueId, \" resume\")\n"
  	"		if(next, next resume)	\n"
  	"	)\n"
  	"	\n"
  	"	pause := method(\n"
  	"		//showYielding(\"pause\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		if(isCurrent,\n"
  	"			next := yieldingCoros removeFirst \n"
  	"            //writeln(\"next = \", next)\n"
  	"			if(next, \n"
  	"			     next resume, \n"
  	"				writeln(\"Scheduler: nothing left to resume so we are exiting\")\n"
  	"				System exit\n"
  	"			)\n"
  	"			,\n"
  	"			writeln(\"not current coroutine\")\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	yieldCurrentAndResumeSelf := method(\n"
  	"		//showYielding(\"yieldCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"	\n"
  	"	pauseCurrentAndResumeSelf := method(\n"
  	"		//showYielding(\"pauseCurrentAndResumeSelf\")\n"
  	"		yieldingCoros remove(self)\n"
  	"		isCurrent ifFalse(resume)\n"
  	"	)\n"
  	"\n"
  	"	//typeId := method(self type .. \"_0x\" .. self uniqueId asString toBase(16) .. \" \" .. self label)\n"
  	"	typeId := method(self type .. \"_0x\" .. self uniqueId asString toBase(16))\n"
  	"\n"
  	"	callStack := method(\n"
  	"		stack := ioStack\n"
  	"		stack selectInPlace(v, Object argIsCall(getSlot(\"v\"))) reverse \n"
  	"		stack selectInPlace(v, (v target type == \"Coroutine\" and v message name == \"setResult\") not)  \n"
  	"		stack selectInPlace(v, (v target type == \"Coroutine\" and v message name == \"main\") not)  \n"
  	"		stack foreach(i, v, if(v target type == \"Importer\" and v message name == \"find\", stack sliceInPlace(i+1); break) )\n"
  	"		//stack foreach(v, writeln(v type)) \n"
  	"		//System exit\n"
  	"		stack\n"
  	"	)\n"
  	"	\n"
  	"	backTraceString := method(\n"
  	"		if(Coroutine inException, \n"
  	"			writeln(\"\\n\", exception type, \": \", exception error, \"\\n\\n\")\n"
  	"			writeln(\"Coroutine Exception loop detected\"); \n"
  	"			System exit\n"
  	"		)\n"
  	"		Coroutine setInException(true)\n"
  	"		buf := Sequence clone\n"
  	"		\n"
  	"		if(getSlot(\"CGI\") != nil and CGI isInWebScript, buf appendSeq(\"<pre>\"))\n"
  	"		\n"
  	"		if(exception, buf appendSeq(\"\\n  \", exception type, \": \", exception error, \"\\n\"))\n"
  	"		//buf appendSeq(\"  \", self typeId, \" stack trace\")\n"
  	"		\n"
  	"		if(callStack size > 0) then(\n"
  	"			buf appendSeq(\"  ---------\\n\")\n"
  	"			\n"
  	"			if(exception and exception caughtMessage, \n"
  	"				buf appendSeq(\"  \", exception caughtMessage description, \"\\n\")\n"
  	"			)\n"
  	"			\n"
  	"			callStack foreach(v, buf appendSeq(\"  \", v description, \"\\n\"))\n"
  	"			buf appendSeq(\"\\n\")\n"
  	"		) else(\n"
  	"			//buf appendSeq(\"    no call stack found\\n\")\n"
  	"			buf appendSeq(\"\\n\")\n"
  	"		)\n"
  	"\n"
  	"		Coroutine setInException(false)\n"
  	"		buf\n"
  	"	)\n"
  	"	\n"
  	"	showStack := method(write(backTraceString))\n"
  	"\n"
  	"	resumeParentCoroutine := method(\n"
  	"		if(parentCoroutine, parentCoroutine pauseCurrentAndResumeSelf)\n"
  	"	)\n"
  	"\n"
  	"	main := method(\n"
  	"		setResult(runTarget doMessage(runMessage, runLocals))\n"
  	"		resumeParentCoroutine\n"
  	"	    //writeln(\"Coroutine error: attempt to return from Coroutine\")\n"
  	"	    pause\n"
  	"	)\n"
  	"\n"
  	"	raiseException := method(e, \n"
  	"		self setException(e)\n"
  	"		resumeParentCoroutine\n"
  	"	)\n"
  	"	\n"
  	")\n"
  	"\n"
  	"Object wait := method(s, \n"
  	"	endDate := Date clone now + Duration clone setSeconds(s)\n"
  	"	loop(endDate isPast ifTrue(break); yield)\n"
  	")\n"
  	"\n"
  	"Message do(\n"
  	"	codeOfLength := method(length,\n"
  	"		c := self code\n"
  	"		if (c size < length, c, c slice(0, length) .. \"...\") asMutable replaceSeq(\"\\n\", \";\")\n"
  	"	)\n"
  	"\n"
  	"	asStackEntry := method(\n"
  	"		label := label lastPathComponent fileName\n"
  	"        label alignLeft(19) .. lineNumber asString alignLeft(7) .. name\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	try := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setParentCoroutine(Scheduler currentCoroutine) \n"
  	"		coro setRunTarget(call sender) \n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0)) \n"
  	"		coro run\n"
  	"		if(coro exception, coro exception, nil)\n"
  	"	)\n"
  	"	\n"
  	"	coroDo := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self) \n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0)) \n"
  	"		Coroutine yieldingCoros atInsert(0, Scheduler currentCoroutine)\n"
  	"		coro run\n"
  	"		coro\n"
  	"	)\n"
  	"	\n"
  	"    coroDoLater := method(\n"
  	"		coro := Coroutine clone\n"
  	"		coro setRunTarget(self) \n"
  	"		coro setRunLocals(call sender)\n"
  	"		coro setRunMessage(call argAt(0)) \n"
  	"		Coroutine yieldingCoros atInsert(0, Scheduler currentCoroutine)\n"
  	"		coro\n"
  	"	)\n"
  	"	\n"
  	"	currentCoro := method(Coroutine currentCoroutine)\n"
  	")\n"
  	"\n"
  	"nil do(\n"
  	"	catch := nil\n"
  	"	pass := nil\n"
  	")\n"
  	"\n"
  	"Protos Exception do(\n"
  	"	type := \"Exception\"\n"
  	"	newSlot(\"error\", nil)\n"
  	"	newSlot(\"coroutine\", nil)\n"
  	"	newSlot(\"caughtMessage\", nil)\n"
  	"    newSlot(\"nestedException\", nil)\n"
  	"	\n"
  	"	raise := method(error, nestedException,\n"
  	"		coro := Scheduler currentCoroutine\n"
  	"		coro raiseException(self clone setError(error) setCoroutine(coro) setNestedException(nestedException))\n"
  	"	)\n"
  	"	\n"
  	"	catch := method(exceptionProto,\n"
  	"		if (self isKindOf(exceptionProto), call evalArgAt(1); nil, self)\n"
  	"	)\n"
  	"\n"
  	"	pass := method(Scheduler currentCoroutine raiseException(self)) \n"
  	"\n"
  	"	showStack := method(\n"
  	"        coroutine showStack\n"
  	"        if(nestedException,\n"
  	"                write(\"Nested Exception: '\", nestedException,  \"'\")\n"
  	"                nestedException showStack\n"
  	"        )\n"
  	"    )\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/A4_Exception.io");

	s = "Future := Object clone do(\n"
  	"    newSlot(\"runTarget\", nil)\n"
  	"    newSlot(\"runMessage\", nil)\n"
  	"    newSlot(\"waitingCoros\", nil)\n"
  	"    newSlot(\"hasTrigger\", false)\n"
  	"    \n"
  	"    futureProxy := method(\n"
  	"    	self waitingCoros := List clone\n"
  	"    	self proxy := Object clone\n"
  	"    	proxy _future := self\n"
  	"    	proxy forward := method(\n"
  	"			//writeln(\"proxy forwarding: \", call message )\n"
  	"    		//call delegateTo(_future getSlot(\"result\"))\n"
  	"			_future result doMessage(call message, call sender)\n"
  	"    	)\n"
  	"    	proxy removeAllProtos\n"
  	"    	proxy\n"
  	"    )\n"
  	"        \n"
  	"    setResult := method(r,\n"
  	"		if(waitingCoros, waitingCoros foreach(resumeLater))\n"
  	"		self result := getSlot(\"r\")\n"
  	"    )\n"
  	"    \n"
  	"    result := method(\n"
  	"  		waitingCoros append(Scheduler currentCoroutine)\n"
  	"    	Scheduler currentCoroutine pause\n"
  	"		self getSlot(\"result\")\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	yield := method(Coroutine currentCoroutine yield)\n"
  	"	pause := method(Coroutine currentCoroutine pause)\n"
  	"	//actorCoroutine := method(self actorCoroutine := self coroDo(yield; actorProcessQueue))\n"
  	"	\n"
  	"	actorRun := method(\n"
  	"		if(self hasLocalSlot(\"actorCoroutine\"),\n"
  	"        	if(actorQueue size == 0, self actorCoroutine resumeLater)\n"
  	"		,\n"
  	"			self actorQueue := List clone\n"
  	"			// need to yield in coroDo to allow future to be added to queue\n"
  	"        	self actorCoroutine := self coroDoLater(yield; actorProcessQueue)\n"
  	"       	    self actorCoroutine run\n"
  	"        )\n"
  	"	)\n"
  	" \n"
  	" 	actorProcessQueue := method(\n"
  	"        //writeln(self type, \"_\", self uniqueId, \" actorProcessQueue\")\n"
  	"        \n"
  	"		if(Coroutine currentCoroutine isIdenticalTo(self actorCoroutine) not, \n"
  	"			writeln(\"actorProcessQueue called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", actorCoroutine uniqueId)\n"
  	"			System exit\n"
  	"		)\n"
  	"            		\n"
  	"		loop(\n"
  	"			while(future := actorQueue removeFirst,			    \n"
  	"				e := try(\n"
  	"				    future setResult(self doMessage(future runMessage))\n"
  	"				)\n"
  	"				\n"
  	"				if(e, handleActorException(e))\n"
  	"				yield\n"
  	"			)\n"
  	"\n"
  	"		  if(Coroutine currentCoroutine isIdenticalTo(self actorCoroutine) not, \n"
  	"			writeln(\"actorProcessQueue1 called from coro \", Coroutine currentCoroutine uniqueId, \" instead of \", self actorCoroutine uniqueId)\n"
  	"			System exit\n"
  	"            )\n"
  	"			self actorCoroutine pause\n"
  	"        )\n"
  	"	)\n"
  	"	\n"
  	"	handleActorException := method(e, e showStack)\n"
  	"	\n"
  	"	setSlot(\"@\", method(\n"
  	"	    //writeln(\"@ \", call argAt(0))\n"
  	"        m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"        f := Future clone setRunTarget(self) setRunMessage(m)\n"
  	"		self actorRun\n"
  	"        self actorQueue append(f)\n"
  	"        f futureProxy\n"
  	"	))\n"
  	" \n"
  	"	setSlot(\"@@\", method(\n"
  	"	    //writeln(self type , \"_\", self uniqueId, \" @@\", call argAt(0)) //, \" \", call argAt(0) label)\n"
  	"        m := call argAt(0) asMessageWithEvaluatedArgs(call sender)\n"
  	"        f := Future clone setRunTarget(self) setRunMessage(m) \n"
  	"		self actorRun\n"
  	"        self actorQueue append(f)\n"
  	"        nil\n"
  	"	))\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Actor.io");

	s = "Addon := Object clone do(\n"
  	"    newSlot(\"rootPath\")\n"
  	"    newSlot(\"name\")\n"
  	"\n"
  	"    platform := method(System platform asLowercase)\n"
  	"    dllSuffix := method(\n"
  	"      if(platform == \"darwin\", return \"dylib\")\n"
  	"      if(platform containsSeq(\"windows\"), return \"dll\")\n"
  	"      \"so\"\n"
  	"    )\n"
  	"    dllName := method(\"libIo\" .. name .. \".\" .. dllSuffix)\n"
  	"    addonPath := method(Path with(rootPath, name))\n"
  	"    dllPath := method(Path with(addonPath, \"_build/dll\", dllName))\n"
  	"    \n"
  	"    ioFiles := method(\n"
  	"        d := Directory with(addonPath) folderNamed(\"io\")\n"
  	"        files := d files select(path endsWithSeq(\".io\"))\n"
  	"        files map(name) sort map(name, d fileNamed(name))\n"
  	"    )\n"
  	"\n"
  	"    dependencies := method(\n"
  	"        File with(Path with(addonPath, \"depends\")) contents split(\" \")\n"
  	"    )\n"
  	"\n"
  	"    loadDependencies := method(\n"
  	"        //writeln(name, \" depends on \", dependencies)\n"
  	"        dependencies foreach(d,\n"
  	"            if(Lobby getSlot(d) == nil, \n"
  	"                //writeln(\"loading dependency \", d)\n"
  	"                AddonLoader loadAddonNamed(d)\n"
  	"            )\n"
  	"        )\n"
  	"    )\n"
  	"\n"
  	"    load := method(\n"
  	"        //writeln(\"Addon \", name, \" loading from \", addonPath)\n"
  	"        loadDependencies\n"
  	"        context := Object clone\n"
  	"        Protos Addons setSlot(name, context)\n"
  	"        Protos appendProto(context)\n"
  	"        //writeln(dllPath)\n"
  	"        DynLib clone setPath(dllPath) open call(\"Io\" .. name .. \"Init\", context)\n"
  	"        //ioFiles foreach(f, writeln(\"loading \", f path))\n"
  	"        ioFiles foreach(file, context doFile(file path))\n"
  	"        Lobby getSlot(name)\n"
  	"    )\n"
  	"\n"
  	"    exists := method(Directory with(addonPath) exists)\n"
  	"    \n"
  	"    addonProtos := method(\n"
  	"        f := File with(Path with(addonPath, \"protos\")) \n"
  	"        if(f exists, f contents split, list())\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"AddonLoader := Object clone do(\n"
  	"    debug := false\n"
  	"\n"
  	"    searchPaths := list(\".\", System installPrefix .. \"/lib/io/addons\")\n"
  	"    appendSearchPath := method(p, searchPaths appendIfAbsent(p); self)\n"
  	"\n"
  	"    addons := method(\n"
  	"        searchFolders := searchPaths map(path, Directory with(path))\n"
  	"        addonFolders := searchFolders map(folders) flatten select(isAccessible) select(fileNames contains(\"build.io\"))\n"
  	"        addons := addonFolders map(f, Addon clone setRootPath(f path pathComponent) setName(f path lastPathComponent))\n"
  	"        addons\n"
  	"    )\n"
  	"    \n"
  	"    addonFor := method(name, \n"
  	"        r := addons detect(name == name)\n"
  	"        if(r, return r)\n"
  	"        addons detect(addonProtos contains(name))\n"
  	"    )\n"
  	"    \n"
  	"    hasAddonNamed := method(name, addonFor(name) != nil)\n"
  	"\n"
  	"    loadAddonNamed := method(name,\n"
  	"        addon := addonFor(name)\n"
  	"        if(addon, addon load, nil)\n"
  	"        Lobby getSlot(name)\n"
  	"    )\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/AddonLoader.io");

	s = "\n"
  	"getSlot(\"Block\") do(\n"
  	"	asSimpleString := method(\n"
  	"                if(scope, \"block\", \"method\") .. \"(\" .. argumentNames append(\"...\") join(\", \") .. \")\"\n"
  	"        )\n"
  	"	asString := method(getSlot(\"self\") code)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Block.io");

	s = "\n"
  	"Lobby Protos do(\n"
  	"	ImmutableSequence := \"\"\n"
  	"	String := ImmutableSequence\n"
  	")\n"
  	"\n"
  	"Sequence do(\n"
  	"\n"
  	"	setSlot(\"..\", method(arg, self asString cloneAppendSeq(arg asString)))\n"
  	"\n"
  	"    docSlot(\"repeated(n)\", \"Returns a new sequence containing the receiver repeated n number of times.\")\n"
  	"    repeated := method(n,\n"
  	"        s := Sequence clone\n"
  	"        n repeatTimes(s appendSeq(self))\n"
  	"        s \n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"alignLeftInPlace(width, [padding])\", \"Same as align left but operation is performed on the receiver.\")\n"
  	"    alignLeftInPlace := method(width, padding,\n"
  	"        originalSize := size\n"
  	"        padding = padding ifNilEval(\" \")\n"
  	"        ((width - size) / padding size) ceil repeatTimes(appendSeq(padding))\n"
  	"        setSize(width max(originalSize))\n"
  	"    )\n"
  	"    \n"
  	"    docSlot(\"removeSeq(aSequence)\", \"Removes occurances of aSequence from the receiver.\")\n"
  	"    removeSeq := method(s, self replaceSeq(s, \"\"))\n"
  	"\n"
  	"    docSlot(\"alignLeft(width, [padding])\", \"\"\"\n"
  	"    Example:\n"
  	"    <pre>\n"
  	"    Io> \"abc\" alignLeft(10, \"-\")\n"
  	"    ==> abc-------\n"
  	"    Io> \"abc\" alignLeft(10, \"-=\")\n"
  	"    ==> abc-=-=-=-\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"    alignLeft := method(width, padding,\n"
  	"        asMutable alignLeftInPlace(width, padding)\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"alignRight(width, [padding])\", \"\"\"\n"
  	"    Example:\n"
  	"    <pre>\n"
  	"    Io> \"abc\" alignRight(10, \"-\")\n"
  	"    ==> -------abc\n"
  	"    Io> \"abc\" alignRight(10, \"-=\")\n"
  	"    ==> -=-=-=-abc\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"    alignRight := method(width, padding,\n"
  	"        Sequence clone alignLeftInPlace(width - size, padding) appendSeq(self)\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"alignCenter(width, [padding])\", \"\"\"\n"
  	"    Example:\n"
  	"    <pre>\n"
  	"    Io> \"abc\" alignCenter(10, \"-\")\n"
  	"    ==> ---abc----\n"
  	"    Io> \"abc\" alignCenter(10, \"-=\")\n"
  	"    ==> -=-abc-=-=\n"
  	"    </pre>\n"
  	"    \"\"\")\n"
  	"    alignCenter := method(width, padding,\n"
  	"        alignRight(((size + width) / 2) floor, padding) alignLeftInPlace(width, padding)\n"
  	"    )\n"
  	"    \n"
  	"    asSimpleString := method(\"\\\"\" .. self asString .. \"\\\"\")\n"
  	"\n"
  	"	splitNoEmpties := method(\n"
  	"		docSlot(\"split(optionalArg1, optionalArg2, ...)\", \"\"\"\n"
  	"		Returns a list containing the non-empty sub-sequences of the receiver divided by the given arguments.\n"
  	"		If no arguments are given the sequence is split on white space.\n"
  	"		Examples:\n"
  	"		<pre>\n"
  	"		\"a   b  c d\" splitNoEmpties => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b**c*d\" splitNoEmpties(\"*\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		\"a***b||c,d\" splitNoEmpties(\"*\", \"|\", \",\") => list(\"a\", \"b\", \"c\", \"d\")\n"
  	"		</pre>\n"
  	"		\"\"\")\n"
  	"	\n"
  	"		self performWithArgList(\"split\", call evalArgs) selectInPlace(size != 0)\n"
  	"	)\n"
  	"\n"
  	"  docSlot(\"findNthSeq(aSequence, n)\", \"Returns a number with the nth occurence of aSequence\")\n"
  	"  findNthSeq := method(str, n,\n"
  	"    num := self findSeq(str)\n"
  	"    if(num isNil, return nil)\n"
  	"    if(n == 1, return num)\n"
  	"    num + self slice(num + 1, self size) findNthSeq(str, n - 1)\n"
  	"  ) \n"
  	"\n"
  	"	docSlot(\"interpolate(ctx)\", \"Returns immutable copy of self with interpolateInPlace(ctx) passed to the copy.\")\n"
  	"	interpolate := method(context,\n"
  	"		if(context isNil, context = call sender)\n"
  	"		self asMutable interpolateInPlace(context) asSymbol\n"
  	"	)\n"
  	"	\n"
  	"        orderedSplit := method(\n"
  	"            separators := call evalArgs\n"
  	"            if(separators size == 0, return list(self))\n"
  	"            i := 0\n"
  	"            skipped := 0\n"
  	"            r := list\n"
  	"            separators foreach(separator,\n"
  	"                j := findSeq(separator, i) ifNil(\n"
  	"                    skipped = skipped + 1\n"
  	"                    continue\n"
  	"                )\n"
  	"                r append(slice(i, j))\n"
  	"                if(skipped > 0,\n"
  	"                    skipped repeatTimes(r append(nil))\n"
  	"                    skipped = 0\n"
  	"                )\n"
  	"                i = j + separator size\n"
  	"            )\n"
  	"            if(size == 0,\n"
  	"                r append(nil)\n"
  	"            ,\n"
  	"                r append(slice(i))\n"
  	"            )\n"
  	"            skipped repeatTimes(r append(nil))\n"
  	"            r\n"
  	"        )\n"
  	"\n"
  	"	docSlot(\"prependSeq(aSequence1, aSequence2, ...)\", \"Prepends given sequences in reverse order to the receiver.  Returns self.\")\n"
  	"	prependSeq := method(\n"
  	"		(call argCount < 1) ifTrue(return self)\n"
  	"		toPrepend := \"\" asMutable\n"
  	"		0 to(call argCount - 1) foreach(argIndex,\n"
  	"			arg := call evalArgAt(argIndex)\n"
  	"			if(arg isKindOf(self) or arg isKindOf(ImmutableSequence),\n"
  	"				toPrepend appendSeq(arg)\n"
  	"			,\n"
  	"				Exception raise(\"Arguments to Sequence prependSeq must be of type Sequence.\")\n"
  	"			)\n"
  	"		)\n"
  	"		if(size + toPrepend size == 0, return self)\n"
  	"		toPrepend size repeatTimes(self appendSeq(\" \"))\n"
  	"		0 to(size - toPrepend size - 1) asList reverseForeach(v,\n"
  	"			atPut(v + toPrepend size, at(v))\n"
  	"		)\n"
  	"		toPrepend foreach(i, v, atPut(i, v))\n"
  	"		self\n"
  	"	)\n"
  	"\n"
  	"	sequenceSets := Map clone do(\n"
  	"		atPut(\"lowercaseSequence\",\n"
  	"			lst := list\n"
  	"			\"abcdefghijklmnopqrstuvwxyz\" foreach(v, lst append(v))\n"
  	"			lst\n"
  	"		)\n"
  	"		atPut(\"uppercaseSequence\",\n"
  	"			lst := list\n"
  	"			at(\"lowercaseSequence\") foreach(v, lst append(v asUppercase))\n"
  	"			lst\n"
  	"		)\n"
  	"		atPut(\"digitSequence\",\n"
  	"			lst := list\n"
  	"			\"0123456789\" foreach(v, lst append(v))\n"
  	"			lst\n"
  	"		)\n"
  	"		removeSlot(\"lst\")\n"
  	"		removeSlot(\"v\")\n"
  	"	)\n"
  	"	\n"
  	"	docSlot(\"nextInSequence(skipVal)\", \"Returns the next item in the sequence.  The optional skipVal parameter allows you to skip ahead skipVal places.\")\n"
  	"	nextInSequence := method(skipVal,\n"
  	"		str := self clone asMutable\n"
  	"		skipVal ifNil(skipVal = 1)\n"
  	"		\n"
  	"		(size < 1) or (skipVal < 1) ifTrue(return str asSymbol)\n"
  	"		\n"
  	"		leadingNonNextableChars := 0\n"
  	"		str foreach(char,\n"
  	"			done := false\n"
  	"			countIt := true\n"
  	"			sequenceSets foreach(set,\n"
  	"				set indexOf(char) ifNonNil(countIt = false; done = true)\n"
  	"			)\n"
  	"			if(countIt, leadingNonNextableChars = leadingNonNextableChars + 1)\n"
  	"			if(done, break)\n"
  	"		)\n"
  	"		(leadingNonNextableChars == str size) ifTrue(return str asSymbol)\n"
  	"		\n"
  	"		str := str splitAt(leadingNonNextableChars)\n"
  	"		leadingNonNextables := str at(0)\n"
  	"		str := str at(1) asMutable\n"
  	"		\n"
  	"		0 to(str size - 1) asList reverseForeach(index,\n"
  	"			done := false\n"
  	"			sequenceSets foreach(setName, set,\n"
  	"				x := set indexOf(str at(index))\n"
  	"				if(x,\n"
  	"					x = x + 1\n"
  	"				,\n"
  	"					continue\n"
  	"				)\n"
  	"				if(x == set size,\n"
  	"					str atPut(index, set at(0))\n"
  	"					if(index == 0,\n"
  	"						str prependSeq(set at(if(setName == \"digitSequence\", 1, 0)) asCharacter)\n"
  	"						done = true\n"
  	"					)\n"
  	"				,\n"
  	"					str atPut(index, set at(x))\n"
  	"					done = true\n"
  	"				)\n"
  	"				break\n"
  	"			)\n"
  	"			if(done, break)\n"
  	"		)\n"
  	"		\n"
  	"		str = leadingNonNextables .. str\n"
  	"		skipVal = skipVal - 1\n"
  	"		if(skipVal < 1,\n"
  	"			str asSymbol\n"
  	"		,\n"
  	"			str nextInSequence(skipVal)\n"
  	"		)\n"
  	"	)\n"
  	"/*	\n"
  	"	docSlot(\"reverse\", \"Returns a reversed copy of the receiver.\")\n"
  	"	reverse := method(\n"
  	"		asMutable reverseInPlace\n"
  	"	)\n"
  	"\n"
  	"    Moved to C	\n"
  	"	docSlot(\"reverseInPlace\", \"Reverses the reveiver.  Returns self.\")\n"
  	"	reverseInPlace := method(\n"
  	"		if(size < 2, return self)\n"
  	"		s := Sequence clone\n"
  	"		0 to(size - 1) asList reverseForeach(index,\n"
  	"			s appendSeq(self at(index) asCharacter)\n"
  	"		)\n"
  	"		self = s\n"
  	"	)\n"
  	"*/\n"
  	"	docSlot(\"to(endpoint)\", \"Convenience constructor that returns a range of sequences from the receiver to the endpoint argument. Increments over each item in that range by 1.\")\n"
  	"	to := method(e, toBy(e, 1))   \n"
  	"\n"
  	"	docSlot(\"toBy(endpoint, increment)\", \"Convenience constructor that returns a range of sequences from the receiver to the endpoint argument. Increments over each item in that range by the value of the increment parameter. The increment parameter must be positive.\")\n"
  	"	toBy := method(e, i,\n"
  	"		toByCompare := method(a, b,\n"
  	"			(a size == b size) ifTrue(return a compare(b))\n"
  	"			nulls := \"\" asMutable\n"
  	"			(a size - b size) abs repeatTimes(nulls appendSeq(\"\\0\"))\n"
  	"			if(a size < b size,\n"
  	"				a = nulls .. a\n"
  	"			,\n"
  	"				b = nulls .. b\n"
  	"			)\n"
  	"			a compare(b)\n"
  	"		)\n"
  	"		removeLeadingZerosAfterLeadingSymbols := method(str,\n"
  	"			if(str isMutable not, str = str asMutable)\n"
  	"			\n"
  	"			# skip over leading symbols\n"
  	"			from := 0\n"
  	"			str foreach(char,\n"
  	"				if(char isInASequenceSet, break, from = from + 1)\n"
  	"			)\n"
  	"			# slice off leading '0's\n"
  	"			to := from - 1\n"
  	"			str slice(from) foreach(char, if(char == \"0\" at(0), to = to + 1, break))\n"
  	"			if(from <= to, str removeSlice(from, to), str)\n"
  	"		)\n"
  	"		\n"
  	"\n"
  	"		from := removeLeadingZerosAfterLeadingSymbols(self asMutable strip)\n"
  	"		to := removeLeadingZerosAfterLeadingSymbols(e asMutable strip)\n"
  	"\n"
  	"		#if(i < 0, Exception raise(\"increment value must be non-negative\"))\n"
  	"		(i == 1) ifFalse(Exception raise(\"increment value must be 1\"))\n"
  	"		if(toByCompare(from, to) > 0, Exception raise(\"range must increase\"))\n"
  	"\n"
  	"		symbols := list\n"
  	"		1 to(from size min(to size)) foreach(index,\n"
  	"			index = 0 - index\n"
  	"			(from at(index) isInASequenceSet == to at(index) isInASequenceSet) ifFalse(\n"
  	"				Exception raise(\"invalid range\")\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		if(from size != to size,\n"
  	"			smaller := bigger := nil\n"
  	"			if(from size > to size,\n"
  	"				bigger = from; smaller = to\n"
  	"			,\n"
  	"				bigger = to; smaller = from\n"
  	"			)\n"
  	"			growthChars := bigger slice(0, bigger size - (smaller size))\n"
  	"			setOfFirstCharInSmaller := nil\n"
  	"			sequenceSets foreach(set,\n"
  	"				if(smaller at(0) in(set), setOfFirstCharInSmaller := set; break)\n"
  	"			)\n"
  	"			growthChars foreach(v,\n"
  	"				v in(setOfFirstCharInSmaller) ifFalse(\n"
  	"					Exception raise(\"invalid range\")\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"		Range clone setRange(from, to, i)\n"
  	"	)\n"
  	"\n"
  	"	docSlot(\"levenshtein(other)\", \"Returns the levenshtein distance to other.\")\n"
  	"	levenshtein := method(other,\n"
  	"		if(other size < self size, return other levenshtein(self))\n"
  	"		current := 0 to(self size) asList\n"
  	"		other foreach(i, otheri,\n"
  	"			previous := current\n"
  	"			current = List clone with(i + 1)\n"
  	"			self foreach(j, selfj,\n"
  	"				current append((current at(j) + 1) min(previous at(j + 1) + 1) min(previous at(j) + if(selfj == otheri, 0, 1)))\n"
  	"			)\n"
  	"		)\n"
  	"		current last\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/B_Sequence.io");

	s = "getSlot(\"CFunction\") do(\n"
  	"    type := \"CFunction\"\n"
  	"\n"
  	"    name := method(typeName ifNilEval(\"Object\") .. \"_\" .. uniqueName ifNilEval(\"<unnamed>\") .. \"()\")\n"
  	"    \n"
  	"    asSimpleString := method(name)\n"
  	"\n"
  	"    asString := getSlot(\"asSimpleString\")\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/CFunction.io");

	s = "Date do(\n"
  	"	docSlot(\"today\", \"Set the receiver to the current date, no time information\n"
  	"is included. See `now' for the current date and time.\")\n"
  	"	today := method(Date now setHour(0) setMinute(0) setSecond(0))\n"
  	"	\n"
  	"	docSlot(\"isToday\", \"Returns true if the receiver's date is today's date.\")\n"
  	"	isToday := method(\n"
  	"		now := Date clone now\n"
  	"		now year == year and now month == month and now day == day\n"
  	"	)\n"
  	"	\n"
  	"	docSlot(\"secondsToRun(expression)\", \"Evaluates message and returns a Number\n"
  	"whose value is the number of seconds taken to do the evaluation\")\n"
  	"	secondsToRun := method(\n"
  	"		t1 := Date clone now\n"
  	"		call evalArgAt(0)\n"
  	"		dt := Date clone now secondsSince(t1)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Number do(\n"
  	"	docSlot(\"years\", \"Returns Duration of receiver's years.\n"
  	"\n"
  	"Example:\n"
  	"<pre>\n"
  	"Io> 1 years\n"
  	"==> 1 years 00 days 00:00:0.000000\n"
  	"Io> 20 years\n"
  	"==> 20 years 00 days 00:00:0.000000\n"
  	"</pre>\n"
  	"\n"
  	"With this, you can do things such as:\n"
  	"<pre>\n"
  	"Io> Date clone now + 5 years\n"
  	"==> 2011-11-14 18:44:33 EST\n"
  	"Io> Date clone now + 2 years + 3 days + 22 minutes\n"
  	"==> 2008-11-17 19:06:54 EST\n"
  	"</pre>\n"
  	"\")\n"
  	"	years := method(Duration clone setYears(self))\n"
  	"	\n"
  	"	docSlot(\"days\", \"Returns Duration of receiver's days. See `years' for a\n"
  	"few examples.\")\n"
  	"	days := method(Duration clone setDays(self))\n"
  	"	\n"
  	"	docSlot(\"hours\", \"Returns Duration of receiver's hours. See `years' for a\n"
  	"few examples.\")\n"
  	"	hours := method(Duration clone setHours(self))\n"
  	"	\n"
  	"	docSlot(\"minutes\", \"Returns Duration of receiver's minutes. See `years' for\n"
  	"a few examples.\")\n"
  	"	minutes := method(Duration clone setMinutes(self))\n"
  	"	\n"
  	"	docSlot(\"seconds\", \"Returns Duration of receiver's seconds. See `years' for\n"
  	"a few examples.\")\n"
  	"	seconds := method(Duration clone setSeconds(self))\n"
  	")\n"
  	"\n"
  	"Duration do(\n"
  	"	docSlot(\"+\", \"Returns a new Duration of the two added.\")\n"
  	"	setSlot(\"+\", method(d, self clone += d))\n"
  	"	\n"
  	"	docSlot(\"-\", \"Returns a new Duration of the two subtracted.\")\n"
  	"	setSlot(\"-\", method(d, self clone -= d))\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Date.io");

	s = "Debugger do(\n"
  	"    docDescription(\"To start debugging a coroutine, call \n"
  	"    <pre>\n"
  	"    Coroutine currentCoroutine setMessageDebugging(true)\n"
  	"    </pre>\n"
  	"    Then each message sent within that coroutine will cause the Debugger vmWillSendMessage slot to be activated and the Debugger slots: messageCoroutine, messageSelf, messageLocals, and message will be set with the values related to the current message send. You can override vmWillSendMessage to implement your own debugging mechanisms.\")\n"
  	"\n"
  	"	start := method(\n"
  	"		self debuggerCoroutine := Coroutine currentCoroutine\n"
  	"		debuggerCoroutine pause\n"
  	"		loop(\n"
  	"			self vmWillSendMessage(self message name)\n"
  	"			messageCoroutine resume\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"    docSlot(\"vmWillSendMessage\", \"Override this method to implement your own debugging mechanisms.\")\n"
  	"    	\n"
  	"	vmWillSendMessage := method(\n"
  	"		writeln(\"Debugger vmWillSendMessage(\", self message name, \")\")\n"
  	"	)\n"
  	"	\n"
  	"	@@start\n"
  	"	yield\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Debugger.io");

	s = "\n"
  	"Directory do(\n"
  	"    docSlot(\"with(aPath)\", \"Returns a new instance with the provided path.\")\n"
  	"    with := method(path, self clone setPath(path))\n"
  	"\n"
  	"    parentDirectory := method(\n"
  	"		if(path == \".\", return nil)\n"
  	"		p := self path pathComponent	\n"
  	"		if(p == \"\", p = \".\")\n"
  	"		Directory clone setPath(p)\n"
  	"    )\n"
  	"\n"
  	"    folders := method(\n"
  	"		items select(item, item type ==(\"Directory\") and(item name != \".\") and(item name != \"..\"))\n"
  	"    )\n"
  	"\n"
  	"    isAccessible := method(\n"
  	"	        r := true\n"
  	"		e := try(items)\n"
  	"		e catch(Exception, r = false)\n"
  	"		r\n"
  	"    )\n"
  	"\n"
  	"    parents := method(\n"
  	"		list := List clone\n"
  	"		d := self\n"
  	"		while(d = d parentDirectory, list append(d))\n"
  	"		list reverse\n"
  	"    )\n"
  	"\n"
  	"    accessibleParents := method(\n"
  	"		parents select(p, p isAccessible)\n"
  	"    )\n"
  	"    \n"
  	"    files := method(\n"
  	"		//writebr(\"path = \", path)\n"
  	"		items select(v, v type == \"File\")\n"
  	"    )\n"
  	"    \n"
  	"    fileNames := method(\n"
  	"		files mapInPlace(i, v, v name)\n"
  	"    )\n"
  	"    \n"
  	"    fileNamed := method(name,\n"
  	"		//files detect(i, v, v name == name)\n"
  	"		File clone setPath(Path with(path, name))\n"
  	"    )\n"
  	"\n"
  	"    filesWithExtension := method(ext,\n"
  	"      if(ext containsSeq(\".\") not, ext = \".\" .. ext)\n"
  	"      files select(f, f name endsWithSeq(ext))\n"
  	"    )\n"
  	"\n"
  	"    folderNamed := method(name,\n"
  	"		folders detect(i, v, v name == name)\n"
  	"    )\n"
  	"\n"
  	"    remove := method(\n"
  	"        File clone setPath(self path) remove\n"
  	"    )\n"
  	"\n"
  	"    folderNamedCreateIfAbsent := method(name,\n"
  	"		f := folderNamed(name)\n"
  	"		if(f, return f)\n"
  	"		createSubdirectory(name)\n"
  	"		folderNamed(name)\n"
  	"    )\n"
  	"\n"
  	"    createFileNamed := method(name,\n"
  	"		f := fileNamed(name)\n"
  	"		if(f, return f)\n"
  	"		return File clone setPath(Path with(path, name))\n"
  	"    )\n"
  	")\n"
  	"\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Directory.io");

	s = "DynLib do(\n"
  	"	init := method(\n"
  	"		self forward := method(\n"
  	"			self performWithArgList(\"call\", list(call message name, call message arguments map(x, self doMessage(x))) flatten)\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/DynLib.io");

	s = "File do(\n"
  	"	docSlot(\"with(aPath)\", \"Returns a new instance with the provided path.\")\n"
  	"	with := method(path, self clone setPath(path))\n"
  	"\n"
  	"	newSlot(\"streamDestination\")\n"
  	"	newSlot(\"streamReadSize\", 1024*64)\n"
  	"	startStreaming := method(streamTo(streamDestination))\n"
  	"\n"
  	"	streamTo := method(streamDestination,\n"
  	"		b := Sequence clone\n"
  	"		self open\n"
  	"		while(isAtEnd not, \n"
  	"			b empty\n"
  	"			readToBufferLength(b, streamReadSize)\n"
  	"			streamDestination write(b)\n"
  	"			yield\n"
  	"		)\n"
  	"	)\n"
  	"\n"
  	"	asCSV := method(\n"
  	"		//file        = record *(CRLF record) [CRLF]\n"
  	"		//record      = field *(COMMA field)\n"
  	"		//field       = (escaped / non_escaped)\n"
  	"		//escaped     = DQUOTE *(TEXTDATA / COMMA / CR / LF / 2DQUOTE) DQUOTE\n"
  	"		//non_escaped = *TEXTDATA\n"
  	"		//COMMA       = %x2C\n"
  	"		//CR          = %x0D ;as per section 6.1 of RFC 2234 [2]\n"
  	"		//DQUOTE      = %x22 ;as per section 6.1 of RFC 2234 [2]\n"
  	"		//LF          = %x0A ;as per section 6.1 of RFC 2234 [2]\n"
  	"		//CRLF        = CR LF ;as per section 6.1 of RFC 2234 [2]\n"
  	"		//TEXTDATA    = %x20-21 / %x23-2B / %x2D-7E\n"
  	"\n"
  	"		records := List clone\n"
  	"		index := 0\n"
  	"\n"
  	"		file := method(\n"
  	"			record\n"
  	"			while(CRLF and self at(index), record)\n"
  	"		)\n"
  	"\n"
  	"		record := method(\n"
  	"			records append(List clone)\n"
  	"			field\n"
  	"			while(COMMA, field)\n"
  	"		)\n"
  	"\n"
  	"		field := method(\n"
  	"			records last append(Sequence clone)\n"
  	"			if(DQUOTE, escaped, non_escaped)\n"
  	"		)\n"
  	"\n"
  	"		escaped := method(\n"
  	"			while(DQUOTE not, TEXTDATA or COMMA or CR or LF or 2DQUOTE ; records last last append(self at(index - 1)))\n"
  	"		)\n"
  	"\n"
  	"		non_escaped := method(\n"
  	"			while(TEXTDATA, records last last append(self at(index - 1)))\n"
  	"		)\n"
  	"\n"
  	"		COMMA := method(\n"
  	"			if(self at(index) == 0x2C, index = index + 1 ; true, false)\n"
  	"		)\n"
  	"\n"
  	"		CR := method(\n"
  	"			if(self at(index) == 0x0D, index = index + 1 ; true, false)\n"
  	"		)\n"
  	"\n"
  	"		DQUOTE := method(\n"
  	"			if(self at(index) == 0x22, index = index + 1 ; true, false)\n"
  	"		)\n"
  	"\n"
  	"		2DQUOTE := method(\n"
  	"			save := index\n"
  	"			if(DQUOTE and DQUOTE, true, index = save ; false)\n"
  	"		)\n"
  	"\n"
  	"		LF := method(\n"
  	"			if(self at(index) == 0x0A, index = index + 1 ; true, false)\n"
  	"		)\n"
  	"\n"
  	"		CRLF := method(\n"
  	"			save := index\n"
  	"			if(CR and LF, true, index = save ; false)\n"
  	"		)\n"
  	"\n"
  	"		TEXTDATA := method(\n"
  	"			if(0x20 <= self at(index) and self at(index) <= 0x21, index = index + 1 ; return true)\n"
  	"			if(0x23 <= self at(index) and self at(index) <= 0x2B, index = index + 1 ; return true)\n"
  	"			if(0x2D <= self at(index) and self at(index) <= 0x7E, index = index + 1 ; return true)\n"
  	"			false\n"
  	"		)\n"
  	"\n"
  	"		file\n"
  	"		records\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Sequence asFile := method(File with(self))\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/File.io");

	s = "Map do(\n"
  	"	docSlot(\"asList\", \"Converts a Map to a list of lists. Each element in the returned list will be a list of two elements: the key, and the value.\")\n"
  	"	asList := method(\n"
  	"		l := list\n"
  	"		foreach(k, v, l append(list(k, v)))\n"
  	"		l\n"
  	"	)\n"
  	"	\n"
  	"	map := method(\n"
  	"        result := List clone\n"
  	"        key := call argAt(0)\n"
  	"        value := call argAt(1)\n"
  	"        body := call argAt(2)\n"
  	"        self foreach(k, v,\n"
  	"            call sender setSlot(key name, k)\n"
  	"            call sender setSlot(value name, v)\n"
  	"            result append(call sender doMessage(body))\n"
  	"        )\n"
  	"        result\n"
  	"    )\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Map.io");

	s = "Message do(\n"
  	"	docSlot(\"union(other)\", \"Creates a union of the receiver and the other parameter. Returns a new message object with the receivers message as the first argument of the returned message, and the other parameter's arguments as each successive argument to the new message.\")\n"
  	"	union := method(\n"
  	"		r := Message clone\n"
  	"		l := list(self)\n"
  	"		call message argAt(0) arguments foreach(arg, l append(arg))\n"
  	"		r setArguments(l)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Message.io");

	s = "Notifier := Object clone do(\n"
  	"	addListener := method(listener, \n"
  	"		if(self getSlot(\"listeners\") == nil, self listeners := List clone)\n"
  	"		listeners append(listener); \n"
  	"		self\n"
  	"	)\n"
  	"	\n"
  	"	removeListener := method(obj,\n"
  	"		if(?listeners, listeners remove(obj))\n"
  	"	)\n"
  	"	\n"
  	"	notifyListeners := method(\n"
  	"		if(?listeners, \n"
  	"			listeners foreach(l,\n"
  	"				if(l hasSlot(call argAt(0) name), \n"
  	"					l doMessage(call argAt(0), call sender)\n"
  	"				)\n"
  	"			)\n"
  	"		)\n"
  	"	)\n"
  	")";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Notifier.io");

	s = "Number do(\n"
  	"	docSlot(\"isInASequenceSet\", \"Return true if receiver is in one of the Sequence sequenceSets, otherwise false.\")\n"
  	"	isInASequenceSet := method(\n"
  	"		Sequence sequenceSets foreach(set,\n"
  	"			if(in(set), return true)\n"
  	"		)\n"
  	"		false\n"
  	"	)\n"
  	"	\n"
  	"  constants := Object clone do(\n"
  	"    docSlot(\"constants pi\", \"Returns the constant pi.\")\n"
  	"    pi := 3.14159265358979323846264338327950288\n"
  	"\n"
  	"    docSlot(\"constants nan\", \"Returns a infinity constant.\")    \n"
  	"    nan := method(Number constants nan := (0/0))\n"
  	"\n"
  	"    docSlot(\"constants inf\", \"Returns a not-a-number constant.\")    \n"
  	"    inf := method(Number constants inf := (1/0))\n"
  	"        \n"
  	"    docSlot(\"constants e\", \"Returns the constant e.\")\n"
  	"    e  := 2.71828182845904523536028747135266249\n"
  	"  )\n"
  	"\n"
  	"  asSimpleString := method(self asString)\n"
  	"\n"
  	"	docSlot(\"nextInSequence(skipVal)\", \"Returns the next item in the sequence counting away from zero. The optional skipVal parameter allows you to skip the number specified and get that value (the next value after self + skipVal).\")\n"
  	"	nextInSequence := method(skipVal,\n"
  	"		if(skipVal isNil, skipVal = 1)\n"
  	"		self + skipVal\n"
  	"	)\n"
  	"\n"
  	"  docSlot(\"to\", \"Convenience constructor that returns a cursor object representing the range of numbers from the receiver to the 'endingPoint' parameter. Increments over each item in that range by 1.\")\n"
  	"  to := method(e, self toBy(e, 1))\n"
  	"\n"
  	"  docSlot(\"toBy(endingPoint, incrementValue)\", \"Convenience constructor that returns a cursor object representing the range of numbers from the receiver to the 'endingPoint' parameter. Increments over each item in that range by the 'incrementValue' parameter.\")\n"
  	"  toBy := method(e, i,\n"
  	"    if(i < 0, Exception raise(\"increment value must be non-negative\"))\n"
  	"		if((e - self) < i, e = self)\n"
  	"		if(self > e, i = 0 - i)\n"
  	"    Range clone setRange(self, e, i)\n"
  	"  )\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Number.io");

	s = "Range do(\n"
  	"  docSlot(\"asList\", \"Returns a list containing all the items within and including the ranges starting and ending points.\")\n"
  	"  asList := method(\n"
  	"    lst := List clone\n"
  	"    self foreach(v, lst append(v))\n"
  	"    lst\n"
  	"  )\n"
  	"\n"
  	"  docSlot(\"contains\", \"Returns a boolean value if the range contains the argument. This works independant of any increment value.\")\n"
  	"	contains := method(v,\n"
  	"		start := self clone first\n"
  	"		end := self clone last\n"
  	"		(start == v or (start compare(v) < 0)) and (v == end or (v compare(end) < 0))\n"
  	"	)\n"
  	"\n"
  	"  docSlot(\"select\", \"Operates the same as 'List select'\")\n"
  	"  select := List getSlot(\"select\")\n"
  	"\n"
  	"  docSlot(\"map([value], body)\", \"Returns a new list which contains the result of the 'body' for every element stepped over in the range, from the starting point to the ending point inclusive.\")\n"
  	"  map := method(\n"
  	"    a1 := call argAt(0)\n"
  	"    if(a1 isNil,\n"
  	"      Exception raise(\"'map' requires at least 1 argument\")\n"
  	"      return\n"
  	"    )\n"
  	"    lst := List clone\n"
  	"    body := call argAt(1)\n"
  	"    if(body, valName := a1 name)\n"
  	"    if(a1 and body isNil, body = call argAt(0))\n"
  	"    loop(\n"
  	"      if(getSlot(\"valName\"), call sender setSlot(valName, value))\n"
  	"      lst append(if(call argAt(1) isNil, value, call sender) doMessage(body))\n"
  	"      if(next, nil, break)\n"
  	"    )\n"
  	"    lst\n"
  	"  )\n"
  	"\n"
  	"	docSlot(\"indexOf(aValue)\", \"Calculates each value, checking to see if it matches the aValue parameter. If so, return the position within the range. NOTE: This method rewinds the range before searching. If you need to revert back to your original position, make a duplicate of the range, and use indexOf on it instead.\")\n"
  	"	indexOf := method(aValue,\n"
  	"		rewind\n"
  	"		while(value != aValue,\n"
  	"			self = next ifNilEval(return nil)\n"
  	"		)\n"
  	"		index\n"
  	"	)\n"
  	"\n"
  	"	docSlot(\"at(position)\", \"Rewinds the range, skips forward until we're at the supplied position then returns the value at that position. Raises an exception if the position is out of bounds.\")\n"
  	"	at := method(pos,\n"
  	"		rewind\n"
  	"		while(index != pos,\n"
  	"			self = next ifNilEval(Exception raise(\"Index out of bounds\"))\n"
  	"		)\n"
  	"		value\n"
  	"	)\n"
  	"\n"
  	"	docSlot(\"slice(start, end, [by])\", \"Returns a list containing the values from the Range starting at the start parameter, ending at the end parameter, and optionally incremented by the by parameter.\")\n"
  	"	slice := method(s, e, b,\n"
  	"		if(e compare(s) < 0, Exception raise(\"Starting point must be greater than the ending point.\"))\n"
  	"		if(b isNil, b = 1)\n"
  	"		l := list\n"
  	"		s repeatTimes(self = self next)\n"
  	"		i := s\n"
  	"		while(i <= e,\n"
  	"			l append(value)\n"
  	"			self = next\n"
  	"			i = i + 1\n"
  	"		)\n"
  	"		l\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Range.io");

	s = "Sandbox do(\n"
  	"    docSlot(\"printCallback(string)\", \n"
  	"     \"default implementation is; method(string, string print)\")\n"
  	"    printCallback := method(string, string print)\n"
  	")";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Sandbox.io");

	s = "\n"
  	"nil   justSerialized := method(stream, stream write(\"nil\"))\n"
  	"true  justSerialized := method(stream, stream write(\"true\"))\n"
  	"false justSerialized := method(stream, stream write(\"false\"))\n"
  	"\n"
  	"Number justSerialized := method(stream,\n"
  	"	stream write(self asSimpleString)\n"
  	")\n"
  	"\n"
  	"Sequence justSerialized := method(stream,\n"
  	"	stream write(self asMutable escape asSimpleString)\n"
  	")\n"
  	"\n"
  	"List justSerialized := method(stream,\n"
  	"	stream write(\"list(\")\n"
  	"	stream write(self map(serialized) join(\", \"))\n"
  	"	stream write(\");\")\n"
  	")\n"
  	"\n"
  	"Map justSerialized := method(stream,\n"
  	"	stream write(\"Map clone do(\")\n"
  	"	self foreach(k, v,\n"
  	"		stream write(\"atPut(\" .. k serialized .. \", \" .. getSlot(\"v\") serialized .. \");\")\n"
  	"	)\n"
  	"	stream write(\");\")\n"
  	")\n"
  	"\n"
  	"Block justSerialized := method(stream,\n"
  	"		stream write(code, \"\\n\")\n"
  	")\n"
  	"\n"
  	"SerializationStream := Object clone do(\n"
  	"	init := method(\n"
  	"		self seen := Map clone\n"
  	"		self output := Sequence clone	\n"
  	"	)\n"
  	"	\n"
  	"	write := method(\n"
  	"		for(i, 0, call argCount - 1,\n"
  	"			//super(writeln(i, call argAt(i)))\n"
  	"			output appendSeq(call evalArgAt(i))\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Object do(\n"
  	"	serialized := method(stream,\n"
  	"		if(stream == nil, stream := SerializationStream clone)\n"
  	"		justSerialized(stream)\n"
  	"		stream output\n"
  	"	)\n"
  	"	\n"
  	"	justSerialized := method(stream,\n"
  	"		stream write(getSlot(\"self\") type, \" clone do(\\n\") \n"
  	"		self serializedSlots(stream)\n"
  	"		stream write(\")\\n\")\n"
  	"	)\n"
  	"\n"
  	"	serializedSlots := method(stream,\n"
  	"		self serializedSlotsWithNames(self slotNames, stream)\n"
  	"	)\n"
  	"	\n"
  	"	serializedSlotsWithNames := method(names, stream,\n"
  	"		names foreach(slotName, \n"
  	"			stream write(\"\\t\", slotName, \" := \")\n"
  	"			self getSlot(slotName) serialized(stream)\n"
  	"			stream write(\"\\n\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Serialize.io");

	s = "\n"
  	"\n"
  	"\n"
  	"System do(\n"
  	"    ioPath := \"/usr/local/lib/io\"\n"
  	"\n"
  	"	docSlot(\"getOptions(args)\", \"\n"
  	"	This primitive is used to get command line options similar to Cs getopt(). \n"
  	"	It returns a map in containing the left side of the argument, with the \n"
  	"	value of the right side. (The key will not contain\n"
  	"	the beginning dashes (--).\n"
  	" 	<p>\n"
  	"	Example:\n"
  	" 	<pre>\n"
  	"	options := System getOptions(args)\n"
  	"	options foreach(k, v,\n"
  	"	  if(v type == List type,\n"
  	"	    v foreach(i, j, writeln(\\\"Got unnamed argument with value: \\\" .. j))\n"
  	"	    continue\n"
  	"	  )\n"
  	"	  writeln(\\\"Got option: \\\" .. k .. \\\" with value: \\\" .. v)\n"
  	"	)\n"
  	" 	</pre>\n"
  	"\")\n"
  	"\n"
  	"  getOptions := method(arguments,\n"
  	"    opts := Map clone\n"
  	"    optname := Sequence clone\n"
  	"    optvalue := Sequence clone\n"
  	"    optsNoKey := List clone\n"
  	"  \n"
  	"    arguments foreach(i, arg,\n"
  	"      if(arg beginsWithSeq(\"--\") isNil) then(\n"
  	"        optsNoKey append(arg)\n"
  	"        continue\n"
  	"      )\n"
  	"      if(arg containsSeq(\"=\")) then(\n"
  	"        optname := arg clone asMutable\n"
  	"        optname clipAfterStartOfSeq(\"=\")\n"
  	"        optname clipBeforeEndOfSeq(\"--\")\n"
  	"        optvalue := arg clone asMutable\n"
  	"        optvalue clipBeforeEndOfSeq(\"=\")\n"
  	"      ) else(\n"
  	"        optname := arg clone asMutable\n"
  	"        optname clipBeforeEndOfSeq(\"--\")\n"
  	"        optvalue = \"\"\n"
  	"      )\n"
  	"      opts atPut(optname, optvalue)\n"
  	"    )\n"
  	"    if(optsNoKey last != nil, opts atPut(\"\", optsNoKey))\n"
  	"    opts\n"
  	"  )\n"
  	"  \n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/System.io");

	s = "UnitTest := Object clone do(\n"
  	"	type  := \"UnitTest\"\n"
  	"	docCategory(\"Testing\")\n"
  	"	setUp := method(nil)\n"
  	"	tearDown := method(nil)\n"
  	"	init := method(self exceptions := List clone)\n"
  	"	testSlotNames := method(self slotNames select(n, n beginsWithSeq(\"test\")) sortInPlace)\n"
  	"	\n"
  	"	testCount := method(testSlotNames size)\n"
  	"	\n"
  	"	run := method(\n"
  	"		testSlotNames foreach(n, \n"
  	"			self setUp\n"
  	"			writeln(\"    \", n)\n"
  	"			e := try(self doString(n))\n"
  	"			if(e, \n"
  	"				write(\"    \", n, \" - failed\")\n"
  	"				exceptions append(e)\n"
  	"				write(\"\\n\")\n"
  	"				writeln(e showStack)\n"
  	"				//System exit\n"
  	"			)\n"
  	"			//Scheduler currentCoroutine yield\n"
  	"			Collector collect; Collector collect\n"
  	"			//Collector collect; Collector collect\n"
  	"			self tearDown\n"
  	"			Collector collect\n"
  	"			Collector collect\n"
  	"		)\n"
  	"	)\n"
  	"    \n"
  	"    fail := method(Exception raise(\"fail\"))\n"
  	"    \n"
  	"	assertEquals := method(a, b, m,\n"
  	"		//writeln(\"assertEquals1 call message = \", call message type)\n"
  	"		mm := call message\n"
  	"		if(m == nil, m = mm)\n"
  	"		d := m argAt(0) code .. \" != \" .. call argAt(1) code\n"
  	"		if(a != b, Exception raise(\"[\" .. d .. \"] [\" .. a .. \" != \" .. b .. \"]\"))\n"
  	"		//writeln(\"assertEquals2\")\n"
  	"	)\n"
  	"\n"
  	"	assertNotEquals := method(a, b, if(a == b, Exception raise(a .. \" == \" .. b)))\n"
  	"\n"
  	"    assertSame    := method(a, b, assertEquals(a uniqueId, b uniqueId, call message))\n"
  	"    assertNotSame := method(a, b, assertNotEquals(a uniqueId, b uniqueId, call message))\n"
  	"    assertNil     := method(a, assertEquals(a, nil, call message))\n"
  	"    assertNotNil  := method(a, assertNotEquals(a, nil, call message))\n"
  	"    assertTrue    := method(a, assertEquals(a, true, call message))\n"
  	"    assertFalse   := method(a, assertEquals(a, false, call message))\n"
  	"\n"
  	"	assertRaisesException := method(\n"
  	"		e := try(\n"
  	"			call evalArgAt(0)\n"
  	"			writeln(\"Should have raised Exception\")\n"
  	"		)\n"
  	"		e ifNil(Exception raise(\"Should have raised Exception\"))\n"
  	"	)\n"
  	"    \n"
  	"	knownBug := method(writeln(\"  [known bug: \", call argAt(0) code, \"]\"))\n"
  	"  \n"
  	"	assertEqualsWithinDelta := method(expected, actual, delta,\n"
  	"		if(((expected - actual) abs > delta),\n"
  	"			Exception raise(\"expected \" .. expected .. \" but was \" .. actual .. \" (allowed delta: \" .. delta .. \")\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"TestSuite := Object clone do(\n"
  	"	type := \"TestSuite\"\n"
  	"	docCategory(\"Testing\")\n"
  	"	name := method(\n"
  	"		path asMutable pathComponent lastPathComponent\n"
  	"	)\n"
  	"	newSlot(\"path\", \".\")\n"
  	"	run := method(\n"
  	"		writeln(\"\\n\", name)\n"
  	"		unitTestFiles := Directory with(launchPath) files select(f, f name endsWithSeq(\"Test.io\"))\n"
  	"		exceptions := List clone\n"
  	"		testCount := 0\n"
  	"		\n"
  	"		unitTestFiles foreach(f, \n"
  	"			writeln(\"  \", f name fileName)\n"
  	"			test := Lobby doString(f contents, f path)\n"
  	"			test run\n"
  	"			testCount = testCount + test testCount\n"
  	"			exceptions appendSeq(test exceptions)\n"
  	"		)\n"
  	"		\n"
  	"		writeln(\"  ---------------\")\n"
  	"		Collector collect\n"
  	"		if(exceptions size > 0) then(\n"
  	"		  writeln(\"  \", testCount, \" tests, \", exceptions size, \" failures\\n\")\n"
  	"		) else(\n"
  	"		  writeln(\"  \", testCount, \" tests - all succeeded\\n\")\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/UnitTest.io");

	s = "Path := Object clone do(\n"
  	"	docCategory(\"FileSystem\")\n"
  	"\n"
  	"	hasDriveLetters := System platform containsAnyCaseSeq(\"Windows\") or System platform containsAnyCaseSeq(\"Cygwin\")\n"
  	"\n"
  	"	with := method(\n"
  	"		s := Sequence clone\n"
  	"		call message arguments foreach(arg,\n"
  	"            v := call sender doMessage(arg)\n"
  	"            //writeln(\"appendPathSeq(\", v type, \")\")\n"
  	"            if(v == nil, v = \"\")\n"
  	"            s appendPathSeq(v)\n"
  	"		)\n"
  	"		s asSymbol\n"
  	"	)\n"
  	"\n"
  	"    isPathAbsolute := method(p,\n"
  	"        absolute := false\n"
  	"        try (\n"
  	"            if (hasDriveLetters,\n"
  	"                absolute = p at(0) isLetter and p at(1) asCharacter == \":\" or p at(0) asCharacter == \"/\" or p at(0) asCharacter == \"\\\\\"\n"
  	"            ,\n"
  	"                absolute = p at(0) asCharacter == \"/\"\n"
  	"            )\n"
  	"        )\n"
  	"        absolute\n"
  	"    )        \n"
  	"        \n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Y_Path.io");

	s = "\n"
  	"CLI := Object clone do(\n"
  	"	type := \"CLI\"\n"
  	"	stdout := File clone standardOutput\n"
  	"	stdin  := File clone standardInput\n"
  	"	inPrompt  := \"Io> \"\n"
  	"	outPrompt := \"==> \"\n"
  	"	multiLine := true\n"
  	"	newSlot(\"evalContext\", method(Lobby))\n"
  	"	newSlot(\"isRunning\", true)\n"
  	"	\n"
  	"	stop := method(setIsRunning(false))\n"
  	"	\n"
  	"	runPath := method(path,\n"
  	"		//Lobby launchPath := path pathComponent\n"
  	"		Lobby launchPath := if(Path isPathAbsolute(path) , path,\n"
  	"			Directory currentWorkingDirectory asMutable appendPathSeq(path)\n"
  	"		) pathComponent\n"
  	"\n"
  	"		e := try(Lobby doFile(path))\n"
  	"		if(e, e showStack)\n"
  	"	)\n"
  	"\n"
  	"	run := method(\n"
  	"		Lobby launchPath := Directory currentWorkingDirectory\n"
  	"        Lobby exit := method(System exit)\n"
  	"        \n"
  	"		if(?args and(args size > 0), \n"
  	"			args foreach(i, arg,\n"
  	"			\n"
  	"				if(arg == \"-e\", \n"
  	"					writeln(evalContext doString(args slice(i + 1) join(\" \")))\n"
  	"					return\n"
  	"				)\n"
  	"				\n"
  	"				if(arg == \"-i\",\n"
  	"					if(args size == i + 1,\n"
  	"						if(File clone setPath(\"main.io\") exists,\n"
  	"							runPath(\"main.io\")\n"
  	"						)\n"
  	"					,\n"
  	"						nextArg := args at(i + 1) \n"
  	"						if(nextArg, runPath(nextArg))\n"
  	"					)\n"
  	"					return interactiveMultiline\n"
  	"				)\n"
  	"				\n"
  	"				runPath(arg)\n"
  	"				return\n"
  	"			)\n"
  	"		,\n"
  	"			if(File clone setPath(\"main.io\") exists,\n"
  	"				runPath(\"main.io\")\n"
  	"				return\n"
  	"			)\n"
  	"		)\n"
  	"\n"
  	"        interactiveMultiline\n"
  	"	)\n"
  	"	\n"
  	"	outputResult := method(result,\n"
  	"			writeln(\"\\n\", outPrompt, getSlot(\"result\"))\n"
  	"	)\n"
  	"	\n"
  	"	interactive := method(\n"
  	" 		writeln(System distribution, \" \", System version)\n"
  	" 		while(isRunning,\n"
  	"			write(inPrompt)\n"
  	"			line := stdin readLine\n"
  	"			if(stdin isAtEnd, writeln; Lobby exit)\n"
  	"			result := nil\n"
  	"			e := try(result = evalContext doString(line))\n"
  	"			if(e, e showStack)\n"
  	"			outputResult(getSlot(\"result\"))\n"
  	"		)\n"
  	"	)\n"
  	"	\n"
  	"	interactiveMultiline := method(\n"
  	"		writeln(System distribution, \" \", System version)\n"
  	"		errTriQuote	:= try(Compiler messageForString(\"\\\"\\\"\\\"\")) error\n"
  	"		errParen		:= try(Compiler messageForString(\"(\")) error\n"
  	"		errArg		:= try(Compiler messageForString(\"(x,\")) error\n"
  	"		errParen2	:= try(Compiler messageForString(\"1+(2+(\")) error\n"
  	"		mapContinueOnErr := Map clone\n"
  	"		mapContinueOnErr atPut(errTriQuote, \"\\\"-> \")\n"
  	"		mapContinueOnErr atPut(errParen, \")-> \")\n"
  	"		mapContinueOnErr atPut(errParen2, \"))> \")\n"
  	"\n"
  	"		while(isRunning,\n"
  	"			prompt := inPrompt\n"
  	"			line := \"\"\n"
  	"			loop(\n"
  	"				write(prompt)\n"
  	"				nextLine := stdin readLine\n"
  	"				if(stdin isAtEnd, writeln; Lobby exit)\n"
  	"				line := line .. \"\\n\" .. (nextLine)\n"
  	"				if(line endsWithSeq(\"\"\"\\\\\"\"\"),\n"
  	"					prompt = \"    \"\n"
  	"					continue\n"
  	"				)\n"
  	"				result := nil\n"
  	"				e := try(result = evalContext doString(line))\n"
  	"				if(e,\n"
  	"					err := e error\n"
  	"					if(prompt = mapContinueOnErr at(err),\n"
  	"						//err println\n"
  	"						continue\n"
  	"					)\n"
  	"					if(err ==(errArg) and(line asMutable strip endsWithSeq(\",\")),\n"
  	"						//err println\n"
  	"						prompt = \"a-> \"\n"
  	"						continue\n"
  	"					)\n"
  	"					e showStack\n"
  	"				)\n"
  	"				break\n"
  	"			)\n"
  	"			outputResult(getSlot(\"result\"))\n"
  	"		)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"/*\n"
  	"Shell := Object clone do(\n"
  	"	newSlot(\"directory\", Directory clone setPath(\".\"))\n"
  	"\n"
  	"    cd := method(dir,\n"
  	"        if(dir isKindOf(Sequence), \n"
  	"            setCurrentWorkingDirectory(dir),\n"
  	"            if(dir isKindOf(Directory) not) \n"
  	"            then(Exception raise(\"cd requires a directory or a path name as its argument\"))\n"
  	"            else(setDirectory(dir))\n"
  	"        )\n"
  	"    )\n"
  	"    \n"
  	"	ls := method(directory items foreach(name println))\n"
  	"\n"
  	"	open := method(name,\n"
  	"		item := directory at(call argAt(0) name)\n"
  	"		if(item isUserExecutable) then(\n"
  	"			// insert stuff to add args\n"
  	"			System system(item path)\n"
  	"		)	\n"
  	"	)\n"
  	"	\n"
  	"	forward := method(\n"
  	"		call delegateTo(directory)\n"
  	"		//item := directory at(call message name)\n"
  	"		//if(item == nil, writeln(\"no such path\"); return item)\n"
  	"	)\n"
  	")\n"
  	"\n"
  	"Lobby shell := method(\n"
  	"	CLI setEvalContext(Shell)\n"
  	"	//CLI outputResult := method(nil)\n"
  	")\n"
  	"*/\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Z_CLI.io");

	s = "Importer := Object clone do(\n"
  	"    docDescription(\"A simple search path based auto-importer.\")\n"
  	"\n"
  	"    paths := List clone append(\"\")\n"
  	"    debug := false\n"
  	"    \n"
  	"    addSearchPath    := method(p, paths appendIfAbsent(p asSymbol))\n"
  	"    removeSearchPath := method(p, paths remove(p asSymbol))\n"
  	"    \n"
  	"    extensions := list(\"io\")\n"
  	"\n"
  	"    executeString := method(name, s,\n"
  	"		Lobby doString(s, name)\n"
  	"		r := Lobby getSlot(name)\n"
  	"		if(r, return r)\n"
  	"		Exception raise(\"Importer slot '\" .. name .. \"' missing after file load\")\n"
  	"		nil    \n"
  	"    )\n"
  	"    \n"
  	"	execute_io := method(path, name, extension,\n"
  	"		p := Path with(path, name .. \".\" .. extension)\n"
  	"		s := File clone setPath(p) asBuffer\n"
  	"		executeString(name, s)\n"
  	"	)\n"
  	"\n"
  	"    find := method(message, theObject,\n"
  	"        name := message name\n"
  	"		p := ?launchPath\n"
  	"		if(debug, writeln(\"Importer find '\", name, \"' \", message label, \" \", message lineNumber, \" ---------------------------\"))\n"
  	"		if(p and(paths contains(p) not), paths atInsert(0, p))  \n"
  	"		if(name at(0) isUppercase, \n"
  	"            paths foreach(p, \n"
  	"                extensions foreach(extension,\n"
  	"                    if(Path isPathAbsolute(p)) then(\n"
  	"                        fullPath := Path with(p, name .. \".\" .. extension) asSymbol\n"
  	"                    ) else(\n"
  	"                        fullPath := Path with(Directory currentWorkingDirectory, p, name .. \".\" .. extension) asSymbol\n"
  	"                    )\n"
  	"                    //if(debug, writeln(\"Directory currentWorkingDirectory:\", Directory currentWorkingDirectory))\n"
  	"                    if(debug, \n"
  	"                        writeln(\"cwd:                  \", Directory currentWorkingDirectory)\n"
  	"                        writeln(\"p:                    \", p)\n"
  	"                        writeln(\"Importer looking for: \", fullPath)\n"
  	"                    )\n"
  	"                    //writeln(\"File clone setPath(\\\"\" .. fullPath .. \"\\\") exists = \", File clone setPath(fullPath) exists)\n"
  	"                    if(File clone setPath(fullPath) exists, \n"
  	"                        r := self perform(\"execute_\" .. extension, p, name, extension)\n"
  	"                        if (r, return r)\n"
  	"                    )\n"
  	"                )\n"
  	"			)\n"
  	"			\n"
  	"			if(AddonLoader hasAddonNamed(name),\n"
  	"                b := AddonLoader loadAddonNamed(name)\n"
  	"                if(b, return b)\n"
  	"                Exception raise(\"Importer slot '\" .. name .. \"' missing after dll load\")\n"
  	"            )\n"
  	"		)\n"
  	"		\n"
  	"		Exception raise(theObject type .. \" does not respond to '\" .. name .. \"'\")\n"
  	"    )\n"
  	"\n"
  	"    docSlot(\"turnOn\", \"Turns on the Importer. Returns self.\")    \n"
  	"    turnOn := method(Lobby forward := method(Importer find(call message, self)); self)\n"
  	"\n"
  	"    docSlot(\"turnOff\", \"Turns off the Importer. Returns self.\")    \n"
  	"    turnOff := method(Lobby removeSlot(\"forward\"); self)\n"
  	"    turnOn\n"
  	")\n"
  	"\n"
  	"";

	IoState_rawOn_doCString_withLabel_(self, context, s, "io/Z_Importer.io");

}

