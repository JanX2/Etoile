"
============================================================================
  ParserKit.st -- OMeta like parser implementation
/NS
  Copyright (C) 2011 Mathieu Suen <mathieu@nebu.li>

  The parser have the same syntax that the OMeta one. Although the semantic 
  could differ. For the time being to write expression use the 
  PKParseExpression class. See example at the bottom of the file.

    2012/03/08 Rule lookup can be optimize at runtime

    2012/03/05 Fix way input consuming. 

    2012/02/22 Many bug fix and start to implement a OMeta parser. 
      - Todo fix the way we walk throw the input. When to consume or not
    the input etc.
      - Some PK*Expression should be singleton

    2011/09/21 Beginning of the expression tree
      - Get the expression tree implementation inspire from OMGrammar
 
    2011/10/20 Beginning of the OMeta implementation
      - Adding the PKParserBase PKRules class

    2011/11/09 Todo merge PKRules with PKParserBase

============================================================================
"

NSObject subclass: PKTranscriptController [
	| +inDebugMode |

	+setDebugMode: value [ inDebugMode := value ]
	+isInDebugMode [ ^inDebugMode ]

]

ETTranscript extend [

	+setDebugMode: value [
		PKTranscriptController setDebugMode: value
	]
    +debug: output [
		 PKTranscriptController isInDebugMode ifTrue: [ self show: output]
	 ]

	+debugCr [
		PKTranscriptController isInDebugMode ifTrue: [ self cr]
	]
]

NSString extend [

	concat: other [
		^self stringByAppendingString: other
	]

	asInputStream [
		^PKInputStream alloc initWithStream: self
	]

	matchSize [ ^self length ]
	count [ ^self length]
	isEmpty [^self length = 0]
	isNotEmpty [^self length > 0 ]

	isLessThan: other [
		^(self integerValue) < (other integerValue)
	]
]

Symbole extend [

]

NSObject extend [
	canReduce [^false]
	matchSize [ ^1 ]
	isArray [^false]
	joinAll [ ^self ]
	sequenceAll [ ^self ]
]

NSObject subclass: NSDelayActionArray [
	| anArray |

	init [
		super init.
		anArray := NSMutableArray new.
	]

	addObject: anObject [
		anArray addObject: anObject
	]

	addAction: anObject [
		(anObject isArray and: (anObject == nil) not)
			ifTrue: [anObject do: [:each | self addObject: each]]
			ifFalse: [self addObject: anObject].
		^self
	]

	isArray [^true]

	do: aBlock [
		anArray do: aBlock
	]

	canReduce [^true]
	reduceOn: target [
		| result |
		result := anArray map: [:each | 
			each canReduce 
                   ifTrue: [each reduceOn: target]
				   ifFalse: [each]].
		(1 = (result count)) ifTrue: [ result := result objectAtIndex: 0 ].
		^result.
	]
	description [
		^anArray leftFoldWithInitialValue: 'Delay:'
		                        intoBlock: [ :acc :action |
			'Delay:' = acc ifTrue: [acc, ' ', action description]
		                   ifFalse: [acc, ', ', action description]
		]           	
	]
]

NSObject subclass: NSDelayInvocation [
	| selector args |
	
	+invocationWithSelector: aSelector arguments: someArgs [
		^self alloc initWithSelector: aSelector arguments: someArgs
	]
	initWithSelector: aSelector arguments: someArgs [
		selector := aSelector.
		args := someArgs
	]
	canReduce [^true]
	reduceOn: target [
		| reduceArgs anInvoc |
		reduceArgs := args map: [:each | each canReduce ifTrue: [
			| res | res := each reduceOn: target.
			(res == nil) ifTrue: [
				NSNull new
			] ifFalse: [
				res]
		] ifFalse: [each]].
		anInvoc := NSInvocation invocationWithTarget: target selector: selector arguments: reduceArgs.
		(target respondsToSelector: selector) ifFalse: [ ETTranscript debug: target description, ' does not recognize ', selector description; debugCr. ]. 
		anInvoc invoke.
		^anInvoc returnValueAsObject
		
	]

	description [
		| argList |
		argList := args leftFoldWithInitialValue: ''
		intoBlock: [ :acc :arg |
			'' = acc ifTrue: [arg description]
			        ifFalse: [ acc, ', ', arg description]
		].
		^ selector description, ' with args: (', argList, ')'
	]
]

NSObject subclass: PKParseAction [
	| selector argumentNames |
	
	initWithSelector: sel argumentNames: args [
		selector := sel.
		argumentNames := args.
	]

	invocationInEnvironment: env [
		| argsBuild |
		argsBuild := NSMutableArray new.
		argumentNames do: [:each |
			| value |
			value := env objectForKey: each.
			value == nil ifTrue: [NSException raise: 'ParserKit' format: 'Unknown binding: ', each].
			argsBuild addObject: value.
		].
		^NSDelayInvocation invocationWithSelector: selector arguments: argsBuild
	]
	
	messageString [
		| messageString |
		(selector description hasSuffix: ':') ifTrue: [
			| selectorParts |
			selectorParts := selector description componentsSeparatedByString: ':'.
			selectorParts := selectorParts zippedCollectionWithCollection: argumentNames andBlock: [ 
				:first :second |
				first, ': ', second
			].
			messageString := selectorParts componentsJoinedByString: ' '.
		] ifFalse: [
			messageString := selector description.
		].
		^(messageString hasPrefix: '#') ifTrue: [
			messageString substringWithRange: (NSValue rangeWithLocation: 1 length: (messageString length - 1))
		] ifFalse: [ messageString ].
	]

	description [ ^ '[', self messageString, ']' ]
]


PKParseAction subclass: PKParsePredicate [
	| targetName |
	initWithTargetName: trgt selector: sel argumentNames: args [
		super initWithSelector: sel argumentNames: args.
		targetName := trgt.
		^self
	]

	succeedsInEnvironment: env [
		| target arguments invocation |
		arguments := argumentNames mappedCollectionWithBlock: [ :argName |
			|value |
			value := env objectForKey: argName.
			"FIXME: This is a quick hack. If the value cannot be bound, we assume
			 that it should be interpreted as a literal value."
			value == nil ifTrue: [value := argName].
			value.
		].
		target := env objectForKey: targetName.
		target == nil ifTrue: [target := targetName].
		invocation := NSInvocation invocationWithTarget: target selector: selector arguments: arguments.
		invocation invoke.
		^invocation returnValueAsBool
	]
	
	description [
		^'?(', targetName, ' ', self messageString, ')'.
	]
]
	
		
			

NSObject subclass: PKParseMatch [
	| input range action delegate |

	+emptyMatch: input [
        ^self new initWithInput: input length: 0; 
			yourself
	]

	initWithInput: list length: length [
		super init.
		action := nil.
		input := list.
		range := (NSValue rangeWithLocation: input position length: length).
		input pushPosition: range length + range location.
		^self
	]
	
	copyInitWith: list range: aRange [
		input := list.
		range := aRange.
		action := nil
	]

	sequenceWith: match [
		| newMatch |
		input mergePosition.
		input lastPosition = range location ifFalse: [
			"Can be remove or rephrase later."
			NSException raise: 'ParseKit' format: 'Last position is not same as the location range, something is wrong here range loc: ', range location description, ' last input: ', input lastPosition description, ' match: ', match description, ' merge with: ', self description ].
		(range location + range length) = match range location
			ifFalse: [ NSException raise: 'ParserKit' format: 'Can not add the range, it is not contiguous'].
		newMatch := self class alloc copyInitWith: input range: (NSValue rangeWithLocation: range location length: (range length + match  range length)).
		(action == nil and: match matchAction == nil) ifFalse: [
			newMatch attachAction: NSDelayActionArray new.
			" It is important to attach the verbatim matches from matches that do not require actions,
			  but only if it's no the empty match (esp. since every sequence matching starts with the
			  empty match."
			(action == nil) ifTrue: [self isEmpty ifFalse: [ newMatch sequenceAction: self matchText ]]
			               ifFalse: [newMatch sequenceAction: action].
			(match matchAction == nil) ifTrue: [newMatch isEmpty ifFalse: [newMatch sequenceAction: match matchText]]
			                          ifFalse: [newMatch sequenceAction: match matchAction].
		].
		^newMatch
	]

	bind: name [
		action == nil 
            ifTrue: [input bind: name object: (input fromRange: range)]
			ifFalse: [input bind: name action: action match: self. action := nil]
	]
	
	setDelegate: anObject  [ delegate := anObject ]

	sequenceAction: anAction [ 
		action == nil 
			ifTrue:  [action := anAction]
			ifFalse: [ action := action addAction: anAction ]
	]

	attachAction: anAction [
		" There might still be an attached action if the result was not bound.
		  In this case, it is safe to assume that the result of the evaluation 
		  is irrelevant to reducing the expression at hand. 
		  FIXME: People might potentially be interested in the side-effects..."
		action := anAction.	
	]

	matchAction [^action]
	match  [ ^(input fromRange: range)]
	isEmpty [ ^range length = 0]
	isSuccess [ ^true ]
	isFailure [ ^false ]
	range [^range]
	reduce [^action == nil ifTrue: [nil] ifFalse: [action reduceOn: delegate]]
    stopPosition [^range length + range location]
	matchText [^ input fromRange: range]
	description [
		^'PKMatchSuccess  ( Recognized: ''', self matchText , ''' location: ', range description,' action: ', action description, ')\n' 
	]
]


NSObject subclass: PKParseFail [
	| input failedPosition describ delegate cause |

	initWithInput: list description: string cause: theCause [
		super init.
		describ := string.
		input := list.
		cause := theCause.
		failedPosition := input position.
		^self
	]
	initWithInput: list description: string [
		^self initWithInput: list description: string cause: nil
	]

	cause [
		^(nil == cause) ifTrue: [ self ]
		                ifFalse: [ cause cause ]
	]  
	setDelegate: anObject  [ delegate := anObject]
	stopPosition [^failedPosition]
	isFailure [ ^true ]
	isSuccess [ ^false ]
	matchAction [^nil]
	bind: name ["No sensible thing can be done here"]
	description [
		| desc |
		 desc := 'PKMatchFailure  ( At: ''',   failedPosition description, ''', ', input stream, ') ', describ, '\n'.
		(nil == cause) ifFalse: [desc := desc, 'Cause: ', self cause description, '\n'].
		^desc. 
	]
]


NSObject subclass: PKParseExpression [
	
	asExp [^self]

	bind: name [
		^PKBindExpression alloc initWithExp: self name: name
	]

	or: exp [
		| alternative |
		((exp isKindOfClass: PKNAryAlternateExpression class) or: (exp isKindOfClass: PKAlternateExpression class)) ifTrue: [
			alternative := PKNAryAlternateExpression new.
			alternative addExpression: self.
			alternative addExpressions: exp expressions.
		] ifFalse: [ alternative := PKAlternateExpression alloc initWithExp: self or: exp].
		^alternative
	]

	or: exp1 or: exp2 [
		^(self or: exp1) or: exp2
	]

	or: exp1 or: exp2 or: exp3 [
		^((self or: exp1) or: exp2) or: exp3
	]

	or: exp1 or:exp2 or: exp3 or: exp4 [
		^(((self or: exp1) or:exp2) or: exp3) or: exp4
	]

	not [
		^PKNegateExpression alloc initWithExp: self
	]

	repeat [
		^PKRepetitionExpression alloc initWithExpression: self canBeEmpty: true
	]

	repeatOneLeast [
		^PKRepetitionExpression alloc initWithExpression: self canBeEmpty: false
	]
	
	seq: exp [
		| sequence |
		((exp isKindOfClass: PKNArySequenceExpression class) or: (exp isKindOfClass: PKSequenceExpression class)) ifTrue: [
			sequence := PKNArySequenceExpression new.
			sequence addExpression: self.
			sequence addExpressions: exp expressions.
		] ifFalse: [ sequence := PKSequenceExpression alloc initWithFirst: self second: exp].
		^sequence
	]

	actionSelector: aSel arguments: args  [
		^self semanticAction: (PKParseAction alloc initWithSelector: aSel argumentNames: args).
	]

	semanticAction: action [
		^PKActionExpression alloc initWithExp: self action: action
	]

	parameterTarget: trgt selector: aSel arguments: args [
		^self parameter: (PKParsePredicate alloc initWithTargetName: trgt selector: aSel argumentNames: args).
	]

	parameter: predicate [	
		^PKParameterizedExpression alloc initWithExp: self predicate: predicate
	]	
	
	seq: exp1 seq: exp2 [
		^(self seq: exp1) seq: exp2
	]

	seq: exp1 seq: exp2 seq: exp3 [
		^(self seq: exp1 seq: exp2) seq: exp3
	]

	seq: exp1 seq: exp2 seq: exp3 seq: exp4 [
		^(self seq: exp1 seq: exp2 seq: exp3) seq: exp4
	]

	maybe [
		^PKMaybeExpression alloc initWithExp: self
	]

	lookahead [
		^PKLookAheadExpression alloc initWithExp: self
	]
	parseInput: sequence [
		^self subclassResponsibility
	]
		
	parseInput: list ifFailed: aBlock [
		| match |
		match := (self parseInput: list).
		^match isFailure ifTrue: [aBlock value]
						 ifFalse: [ match ]
	]

	isMemoizable [ ^true ]

	" We need a special memoizability check for lookups to non-terminals because
	  they might recursively refer to themselves."
	isMemoizableForNonTerminal: name inGrammar: grammar [ ^true ]
]

PKParseExpression subclass: PKDotExpression [
	parseInput: list [
		^list atEnd 
            ifTrue: [PKParseFail alloc initWithInput: list description: 'Unexpected end of stream']
			ifFalse: [PKParseMatch alloc initWithInput: list length: list head length]
	]

	description [
		^'.'
	]
]

PKParseExpression subclass: PKAlphabeticExpression [
	
	parseInput: list [
		^list head isEmpty 
			ifTrue: [PKParseFail alloc initWithInput: list description: 'Expected alphabetic character']
			ifFalse: [
				(list head characterAtIndex: 0) isAlphabetic
			        ifTrue: [PKParseMatch alloc initWithInput: list length: list head length]
			        ifFalse: [PKParseFail alloc initWithInput: list description: 'Expected alphabetic character']]
	]

	description [
		^'[a-zA-Z]'
	]
]

PKParseExpression subclass: PKRangeExpression [
	| from to |

	initFrom: fromChar to: toChar [
		(('0' = from) and: ('9' = to)) ifTrue: [^PKNumericExpression new].
		super init.
		from := fromChar.
		to := toChar.
		^self
	]

	parseInput: list [
		^list head isEmpty 
            ifTrue: [PKParseFail alloc initWithInput: list description: 'Expected character [', from, '-', to, ']']
			ifFalse: [
		         (((list head characterAtIndex: 0) >= ( from  characterAtIndex: 0)) and: ((list head characterAtIndex: 0) <= (to characterAtIndex: 0)))
	                   ifTrue: [PKParseMatch alloc initWithInput: list length: list head length]
		               ifFalse: [PKParseFail alloc initWithInput: list description: 'Expected character [', from, '-', to, ']']]
		
	]

	description [
		^'[', from, '-', to, ']'
	]
	
	
]

PKParseExpression subclass: PKNumericExpression [

	parseInput: list [
		^list head isEmpty ifTrue: [PKParseFail alloc initWithInput: list description: 'Expected digit character']
			ifFalse: [
				(list head characterAtIndex: 0) isDigit
			        ifTrue: [PKParseMatch alloc initWithInput: list length: list head length]
			        ifFalse: [PKParseFail alloc initWithInput: list description: 'Expected digit character']]

	]

	description [
		^'[0-9]'
	]
]

"Abstract class for composing expression"
PKParseExpression subclass: PKComposeExpression [
	| exp |

	initWithExp: expression [ 
		super init.
		exp := expression. 
		^self 
	]

	description [
		^exp description	
	]

	parseInput: list [
	    ^exp parseInput: list	
	]

	expression [^exp]

	" Non-Memoizability is inherited. "
	isMemoizable [ ^exp isMemoizable ]
	isMemoizableForNonTerminal: name inGrammar: grammar [ ^exp isMemoizableForNonTerminal: name inGrammar: grammar ] 
]


"Abstract compose expression with n subexpressions" 
PKParseExpression subclass: PKNAryComposeExpression [
	| expressions |

	init [
		super init.
		expressions := NSMutableArray new.
		^self
	]

	addExpression: exp
	[
		expressions addObject: exp.
	]

	addExpressions: exprs
	[
		expressions addObjectsFromArray: exprs.
	]

	parseInput: list [ 
		^self subclassResponsibility
	]

	expressions [ ^expressions]

	isMemoizableForNonTerminal: name inGrammar: grammar [
		| result |
		result := true.
		expressions do: [ :exp|
			result ifTrue: [
				result := exp isMemoizableForNonTerminal: name inGrammar: grammar.
			]
		].
		^result. 
	]

	isMemoizable [ ^self isMemoizableForNonTerminal: nil inGrammar: nil ]
]

PKComposeExpression subclass: PKActionExpression [
	| action |
	
	initWithExp: aExp action: anAction [
		super initWithExp: aExp.
		action := anAction
	]

	parseInput: list [
		| match |
		
		match := exp parseInput: list.
		match isSuccess  ifTrue: [
			match attachAction: (action invocationInEnvironment: list environment)
		].
		
		^match
	]
	description [ ^exp description, ' -> ', action description ]
]

PKComposeExpression subclass: PKParameterizedExpression [
	| predicate |
	initWithExp: aExp predicate: pred [
		super initWithExp: aExp.
		predicate := pred.
	]
	parseInput: list [
		| match |
		match := exp parseInput: list.
		^match isSuccess ifTrue: [
			(predicate succeedsInEnvironment: (list environment)) ifTrue: [ match ]
			ifFalse: [
				list popPosition.
				PKParseFail alloc initWithInput: list
				                    description: ('Expected ', exp description, ' to satisfy parameter ', predicate description)].
		] ifFalse: [ match ].
	]
	
	description [
		^exp description, ' ', predicate description
	]
	
	isMemoizable [ ^false ]
	isMemoizableForNonTerminal: name inGrammar: grammar [ ^false ] 
]

PKComposeExpression subclass: PKNonTerminalExpression [
	| name  |
	initWithName: string exp: expression [
		super init.
		exp := expression.
		name := string.
		^self
	]

	parseInput: list  [
		| match |
		list inEnvironmentDo: [
			exp == nil ifTrue: [NSException raise: 'ParserKit' format: 'Uncomplete grammar definition for ', name].
			ETTranscript debug: 'Try non terminal: ', name, ' input pos: '; debug: list positionStack; debugCr.
			match := list matchRule: name.
			(match == nil) ifTrue: [
				| position |
				position := list position.
				match := exp parseInput: list.
				" Only memoize the matches from expressions for which it is safely possible. "
				exp isMemoizable ifTrue: [list addMatch: match at: position named: name].
			] ifFalse: [match isSuccess ifTrue: [
				ETTranscript debug: 'Pushing back position: '; debug: match stopPosition; debugCr.
				list pushPosition: match stopPosition]].
			ETTranscript debug: 'End of non terminal: ', name, ' input pos: '; debug: list positionStack; debugCr.
		].
		^match
	]

	setExpression: anExp [ exp := anExp ]
	description [^name]
]

PKComposeExpression subclass: PKAlphanumericExpression [

	init [
		self initWithExp: (  PKAlphabeticExpression new or: PKNumericExpression new )
	]
]

PKParseExpression subclass: PKTokenExpression [
	| match |

	initWithPattern: matchPattern [
		super init.
		match := matchPattern.
		^self
	]
	
	parseInput: list [
		| return |
		((list head: match matchSize) isEqual: match) ifTrue: [ 
			return := PKParseMatch alloc initWithInput: list
								length: match matchSize.
		] ifFalse: [
			return := PKParseFail alloc initWithInput: list description: 'Unexpected token, expected: ', match
		].
		^return
	]

	description [
		^'''', match description, ''''
	]
]

PKParseExpression subclass: PKEmptyExpression [
	| +instance |

	+initialize [
        instance := self new.
	]

	+uniqueInstance [
        ^instance
	]

	parseInput: list [
		^list atEnd
            ifTrue: [PKParseMatch alloc initWithInput: list length: 0]
			ifFalse: [PKParseFail alloc initWithInput: list description:  'Expected an empty string'] 
	]

	description [
		^ '$'
	]
]

PKParseExpression subclass: PKAnythingExpression [
	| +instance |

	+initialize [
		instance := self new.
	]

	+uniqueInstance [
		^instance
	]

	parseInput: list [ ^PKParseMatch alloc initWithInput: list length: 0]

	description [ ^'']
]

PKParseExpression subclass: PKSequenceExpression [
 	| e1 e2 |

	initWithFirst: exp1 second: exp2 [
		e1 := exp1.
		e2 := exp2.
		^self
	] 

	parseInput: list [
		| match1 |
		match1 := e1 parseInput: list.
		^match1 isSuccess ifTrue: [
			| match2 |
			match2 := (e2 parseInput: list).
			match2 isSuccess 
                ifTrue: [ 
					ETTranscript debug: 'Merge sequence: ', match1 matchText, ' with: ', match2 matchText; debugCr.
					match1 sequenceWith: match2 ]
				ifFalse: [ list popPosition. match2 ]
		] ifFalse: [ match1 ]
	]

	expressions [ ^{e1. e2} ]

	seq: exp [
		| multiSeq |
		multiSeq := PKNArySequenceExpression new.
		multiSeq addExpressions: self expressions.
		^multiSeq seq: exp
	]

	description [
		^e1 description, ' ', e2 description
	]

	isMemoizable [ ^e1 isMemoizable ifTrue: [e2 isMemoizable]
			               ifFalse: [false] ]

	isMemoziableForNonTerminal: name inGrammar: grammar [ ^ (e1 isMemoizableForNonTerminal: name inGrammar: grammar) and:
		(e2 isMemoizableForNonTerminal: name inGrammar: grammar) ]
]

PKNAryComposeExpression subclass: PKNArySequenceExpression [

	parseInput: list [
		| match |
		match := PKParseMatch emptyMatch: list.
		expressions do: [ :exp|
			match isSuccess ifTrue: [
				| currentMatch |
				currentMatch := exp parseInput: list.
				currentMatch isSuccess ifTrue: [ 
					ETTranscript debug: 'Merge sequence ', match matchText, ' with: ', currentMatch matchText; debugCr.
					match := match sequenceWith: currentMatch.
				] ifFalse: [
					list popPosition.
					match := PKParseFail new initWithInput: list description: 'Unexpected token, expected: ', exp description
					                                 cause: currentMatch
				].
			]
		].
		^ match
	]
	
	seq: exp
	[
		((exp isKindOfClass: PKNArySequenceExpression class) or: (exp isKindOfClass: PKSequenceExpression class)) ifTrue: [
			self addExpressions: exp expressions.
		] ifFalse: [ self addExpression: exp ].
		^self
	]

	description [
		^expressions leftFoldWithInitialValue: ''
		                            intoBlock: [ :acc :exp|
			('' = acc) ifTrue: [exp description]
			          ifFalse: [acc, ' ', exp description]
		]
	]
]

PKComposeExpression subclass: PKBindExpression [
	| name |

	initWithExp: exp name: aName [
		super initWithExp: exp.
		name := aName
	]

	parseInput: list [
		| match |
		match := exp parseInput: list.
		match bind: name.
		^match
	]

	description [ ^'(', exp description, '):', name ]
	
]

PKComposeExpression subclass: PKLookAheadExpression [

	
	parseInput: list [
		| match |
		match := exp parseInput: list.
		match isFailure ifFalse: [list popPosition].
		^match
	]
	
	description [ ^'&(', exp description, ')' ]
]

PKComposeExpression subclass: PKNegateExpression [

	initWithExp: expression [
		super initWithExp: (PKLookAheadExpression alloc initWithExp: expression).
		^self
	]

	description [
		^'!(',exp expression description,')'
	]

	parseInput: list [
		| match |
		match := exp parseInput: list.
		^match isSuccess ifTrue: [PKParseFail alloc initWithInput: list description: 'Should not match ', exp description] 
						 ifFalse: [PKParseMatch alloc initWithInput: list length: 0]
	]
]

PKComposeExpression subclass: PKMaybeExpression [
	parseInput: list [
		| match |
		match := exp parseInput: list.
		^match isSuccess ifTrue: [match]
						 ifFalse: [PKParseMatch alloc initWithInput: list length: 0]
	]
	
	description [^'(', exp description, ')?']
]

PKParseExpression subclass: PKAlternateExpression [
     | first second |

	initWithExp: exp1 or: exp2 [
		first := exp1.
		second := exp2
	]

	parseInput: list [
		 ^first parseInput: list ifFailed: [
			 | match |
			 match := second parseInput: list.
			 match isFailure 
                 ifTrue:[ PKParseFail alloc initWithInput: list description: 'Expected ', self description]
				 ifFalse: [match]
		 ]		
	 ]

	expressions [ ^{first. second} ]

	or: exp [
		| multiOr |
		multiOr := PKNAryAlternateExpression new.
		multiOr addExpression: first; addExpression: second.
		
		^multiOr or: exp.
	]

	description [
		^first description, ' / ', second description
	]
	
	isMemoizable [ ^first isMemoizable ifTrue: [second isMemoizable]
			                  ifFalse: [false] ]

	isMemoziableForNonTerminal: name inGrammar: grammar [ ^ (first isMemoizableForNonTerminal: name inGrammar: grammar) and:
		(second isMemoizableForNonTerminal: name inGrammar: grammar) ]
]

PKNAryComposeExpression subclass: PKNAryAlternateExpression [
	parseInput: list [
		| match |
		match := PKParseFail alloc initWithInput: list description: 'Expected ', self description.
		expressions do: [ :exp |
			match isSuccess ifFalse: [
				| currentMatch |
				currentMatch := exp parseInput: list.
				currentMatch isSuccess ifTrue: [ match := currentMatch ]
			]
		].
		^match
	]
	
	description [
		^expressions leftFoldWithInitialValue: ''
		                            intoBlock: [ :acc :exp|
			('' = acc) ifTrue: [exp description]
			          ifFalse: [acc, ' / ', exp description]
		]
	]

	or: exp [
		((exp isKindOfClass: PKNAryAlternateExpression class) or: (exp isKindOfClass: PKAlternateExpression class)) ifTrue: [
			self addExpressions: exp expressions.
		] ifFalse: [ self addExpression: exp ]
	]
]



PKComposeExpression subclass: PKRepetitionExpression [
	| canBeEmpty |

	initWithExpression: anExp canBeEmpty: aBool [
		super init.
		exp := anExp.
		canBeEmpty := aBool.
		^self
	]
	
	parseInput: list [
		| match currentMatch |
		match := PKParseMatch emptyMatch: list.
		[
			currentMatch := exp parseInput: list.
			currentMatch isSuccess
		] whileTrue: [ 
			ETTranscript debug: 'Merge repetition ', match matchText, ' with: ', currentMatch matchText; debugCr.
			match := match sequenceWith: currentMatch.
		].
		^(match isEmpty and: canBeEmpty not) 
            ifTrue: [list popPosition. PKParseFail new initWithInput: list description: 'Unexpected token, expected: ', exp description
	                                                           cause: currentMatch ]
			ifFalse: [match]
	]

	description [
		^exp description , (canBeEmpty ifTrue: ['*'] ifFalse: ['+'])
	]
]

PKParseExpression subclass: PKNonTerminalLookup [
	| grammar name |
	initWithGrammar: aGrammar name: aName [
		grammar := aGrammar.
		name := aName
	]

	parseInput: list [
		"ETTranscript debug: 'Apply ', name, ' at: '; debug: list position; debugCr."
		^grammar apply: name
	]

	isMemoizable [ ^(grammar rules lookup: name ifFailed: [^false]) isMemoizableForNonTerminal: name inGrammar: grammar ]

	isMemoizableForNonTerminal: aName inGrammar: aGrammar [ ^((grammar == aGrammar) and: (name = aName)) ifTrue: [true] 
		ifFalse: [self isMemoizable]
	]
	description [ ^name ]
]


"--- Recursive Extend ---"
NSString extend [
	asExp [
		^PKTokenExpression new initWithPattern: self
	]
]

"The environment stack maintains a scoped list of all bound variables in an 
 OMeta parse tree."
NSObject subclass: PKEnvironmentStack [
	| environmentStack top |
	init [
		environmentStack := NSMutableArray new.
		top := NSMutableDictionary new.
		top setValue: NSMutableDictionary new
		      forKey: '$_matches'.
		^self
	]

	setValue: val forKey: key [
		top setValue: val forKey: key.
	]

	setObject: obj forKey: key [
		self setValue: obj forKey: key.
	]

	setAction: action forKey: key fromMatch: match [
		self setValue: action forKey: key.
		self registerMatch: match forKey: key.
	]

	registerMatch: match forKey: name [
		(top objectForKey: '$_matches') setValue: match forKey: name.
	]
	objectForKey: key [
		| object |
		object := top objectForKey: key.
		^(object == nil) ifTrue: [ self searchStackFor: key ]
		                ifFalse: [ object ]	
	]

	searchStackFor: key [
		| object |
		object := nil.
		" The stack top is at index 0, so we can just iterate over the array to
		  return the most locally scoped binding first. "
		environmentStack do: [ :each |
			(nil == object) ifTrue: [
				object := each objectForKey: key.
			]
		].
		^object
	]

	pushEnvironment [
		environmentStack insertObject: top atIndex: 0.
		top := NSMutableDictionary new.
		top setValue: NSMutableDictionary new
		      forKey: '$_matches'.
	]

	popEnvironment [
		self restoreActions.
		top := environmentStack objectAtIndex: 0.
		environmentStack removeObjectAtIndex: 0.
	]

	" It is necessary to restore actions for memoized matches "
	restoreActions [
		| matches |
		matches := top objectForKey: '$_matches'.
		matches allKeys do: [ :each |
			|match action |
			match := matches objectForKey: each.
			action := top objectForKey: each.
			"Only perform the restore if there is no new action that has overriden this one"
			(match matchAction == nil) ifTrue: [match attachAction: action].
		].
	]
]
	
NSObject subclass: PKInputStream [
    | memo stream position positionStack environmentStack |

    initWithStream: input [
        stream := input.
        memo := NSMutableDictionary new.
		positionStack := NSMutableArray new.
		position := 0.
		environmentStack := PKEnvironmentStack new.
		^self
	]

	description [
		^(stream substringWithRange: (NSValue rangeWithLocation: position length: stream length - position)), ' pos: ', positionStack description
	]

	inEnvironmentDo: aBlock [
		environmentStack pushEnvironment.
		aBlock value.
		environmentStack popEnvironment.
	]

	bind: name object: anObject [
		environmentStack setValue: anObject forKey: name

	]

	bind: name action: anAction match: match [
		environmentStack setAction: anAction forKey: name fromMatch: match.
	]

	environment [^environmentStack ]

    addMatch: parserMatch at: position named: aString [
		| matchList |
		((memo objectForKey: position) == nil)
			 ifTrue: [memo setValue: NSMutableDictionary new forKey: position].
		matchList := memo objectForKey: position.
		matchList setValue: parserMatch forKey: aString
	]

	matchRule: string [
		^self matchAt: position rule: string
	]

	matchAt: position rule: aString [
		| matchList |
		matchList := memo objectForKey: position.
		^(matchList == nil)
            ifTrue: [nil]
			ifFalse: [matchList objectForKey: aString]
	]

	pushPosition: anInt [
		positionStack addObject: position.
		position := anInt
	]

	lastPosition [
		^positionStack lastObject
	]

	popPosition [
		position := positionStack lastObject.
		positionStack removeLastObject.
	]

	fromRange: range [
		^(range length == 0) ifTrue: ['']
			ifFalse: [
				stream substringWithRange: range]
	]

	head [
		^self head: 1
	]
	
	head: size [
		"Todo non local return seems broken"
		^(position + size) > stream length ifTrue: ['']
			ifFalse: [self fromRange: (NSValue rangeWithLocation: position length: size)]
	]

	mergePosition [
		positionStack count >= 2 ifFalse: [NSException raise: 'PKParser' format: 'Not enought position to merge'].
		positionStack removeLastObject
	]

	position [^position]
	positionStack [^positionStack]
	length [ ^stream length]
	atEnd [^self position = stream length]
	stream [ ^stream ]
]

NSObject subclass: PKRules [
	| parent rules name |

	initWithName: string [
		super init.
		name := string.
		parent := nil.
		rules := NSMutableDictionary new.
		^self
	]

	at: rule [
		^self lookup: rule ifFailed: [
			| ruleExp |
			ruleExp := PKNonTerminalExpression alloc initWithName: rule exp: nil.
			rules setValue: ruleExp forKey: rule.
			ruleExp
		]
	]

	addRule: name expression: exp [
		| rule |
		rule := rules objectForKey: name.
		rule == nil ifTrue: [
			rule := PKNonTerminalExpression alloc initWithName: name exp: exp.
		    rules setValue: rule forKey: name
		] ifFalse: [
			rule setExpression: exp
		].
		^rule
	]

	lookup: rule ifFailed: aBlock [
		| return |
		return := rules objectForKey: rule.
		return == nil ifTrue:[
			parent == nil
                ifTrue: [ return := aBlock value ]
				ifFalse: [	
					return := parent lookup: rule ifFailed: aBlock
				]
		].
		^return	
	]
		
	initWithParent: pkRules name: string [
		self initWithName: string.
		parent := pkRules
	]

	name [ ^name ]

	description [
		| desc |
		desc := name.
		parent == nil ifFalse: [ desc := desc, ' : ', parent name ].
		desc := desc, ' {\n'.
		rules allKeys do: [:key | 
			desc := desc, key, ' <- ', (rules objectForKey: key) expression description, '\n'
		].
		^desc, '}'	
	]
		
	subgrammar: string [
		^self class alloc initWithParent: self name: string
	]
]


NSArray extend [
	joinAll [
		| exp |
		exp := nil.
		self do: [ :value |
			(exp == nil)
                ifTrue: [
					exp := value asExp]
				ifFalse: [exp := exp or: value asExp].
		].
		^exp
	]
	sequenceAll [
		| exp |
		exp := nil.
		self do: [ :value |
			(exp == nil)
                ifTrue: [
					exp := value asExp]
				ifFalse: [exp := exp seq: value asExp].
		].
		^exp
	]
]

NSObject subclass: PKParser [
	| input +rulesRepo rules actionObject delegate |

	+initialize [
		rulesRepo := NSMutableDictionary new.
	]

	+derivate: parent subgrammar: name [
		| rule newRule |
		newRule := parent subgrammar: name.
		rulesRepo setValue: newRule forKey: name.
		^newRule
	]

	+getGrammar: name [
		| rule |
		rule := rulesRepo objectForKey: name.
		rule == nil ifTrue: [
			^NSException raise: 'ParserKit' format: 'Cannot load grammar ''', name, ''''
		].
		^rule	
	]

	+getNewGrammar: name [
		| rule |
		rule := PKRules alloc initWithName: name.
		rulesRepo setValue: rule forKey: name.
		^rule	
	]

	setDelegate: anObject [
		delegate := anObject
	]

    initWithGrammar: grammarName [
		rules := self class getGrammar: grammarName.
		^self
	]

	initWithNewGrammar: grammarName [
		rules := self class getNewGrammar: grammarName.
		^self
	]

	setActionObject: obj [
		actionObject := actionObject
	]

	subgrammar: name [
		rules := self class derivate: rules subgrammar: name.
	]

	at: rule [
		^PKNonTerminalLookup alloc initWithGrammar: self name: rule
	]

	addRule: name expression: exp  [
		rules addRule: name expression: exp
	]

	description [
		^rules description
	]
	
	apply: rule [
		| exp init |
		exp := rules lookup: rule ifFailed: [
			NSException raise: 'ParserKit' format: ('Invalid rule ', rule)
		].
		" If the grammar has a __init__ rule, it needs to be matched first. "
		init := rules lookup: '__init__' ifFailed: [ nil ].
		init ==	nil ifFalse: [ exp := init seq: exp ].
		^exp parseInput: input.
	]
	
	match: inputStream rule: rule [
		|match|
		input := PKInputStream alloc initWithStream: inputStream.
		match := self apply: rule.
		match setDelegate: delegate.
		^match
	]

	rules  [ ^rules ]
   
]

NSObject subclass: PKAstExpressionGen [
	| expression operation |

	initWithExp: exp operation: op [
		expression := exp.
		operation := op
	]

	reduce: exp [
		exp == nil 
            ifFalse: [ expression ]
			ifTrue: [ operation value: exp value: expression ]
	]
]

NSObject subclass: PKDelayedExpressionBuilder [
	| block exp |

	initWithBlock: aBlock [
		block := aBlock.
		exp := nil.
		^self.
	]

	initWithExp: anExp [
		exp := anExp.
		block := nil.
		^self
	]

	asExp [ ^self ]
	
	bind: name [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value bind: name ].
		
	]

	repeat [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value repeat ].
	]
	
	repeatOneLeast [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value repeatOneLeast ].
	]

	maybe [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value maybe ].
	]

	parameter: predicate [
		^PKDelayedExpressionBuilder alloc initWithBlock: [ self value parameter: predicate ].
	]

	semanticAction: action [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value semanticAction: action ].
	]

	not [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value not ].
	]

	lookahead [
		^PKDelayedExpressionBuilder alloc initWithBlock: [self value lookahead ].
	]

	seq: exp [
		^(exp isKindOfClass: PKDelayedExpressionBuilder class) ifTrue: [
			PKDelayedExpressionBuilder alloc initWithBlock: [self value seq: exp value ]
		] ifFalse: [
			PKDelayedExpressionBuilder alloc initWithBlock: [self value seq: exp ]
		]
	]

	or: exp [
		^(exp isKindOfClass: PKDelayedExpressionBuilder class) ifTrue: [
			PKDelayedExpressionBuilder alloc initWithBlock: [self value or: exp value ]
		] ifFalse: [
			PKDelayedExpressionBuilder alloc initWithBlock: [self value or: exp ]
		]
	]
	
	value [ ^(nil == exp) ifTrue: [ block value ]
		                 ifFalse: [ exp ]	
	]
]

NSObject subclass: PKParserASTGenerator [
	| specialCharToChar |

	init [
		super init.
		specialCharToChar := NSMutableDictionary new.
		specialCharToChar setValue: '\n' forKey: 'n'.
		specialCharToChar setValue: '\t' forKey: 't'.
		specialCharToChar setValue: '\r' forKey: 'r'.
		specialCharToChar setValue: '\\' forKey: '\\'.
		specialCharToChar setValue: '''' forKey: ''''.
		specialCharToChar setValue: '"' forKey: '"'.
		specialCharToChar setValue: '[' forKey: '['.
		specialCharToChar setValue: ']' forKey: ']'.
	]
	
	makeLiteral: literal [
		(literal isKindOfClass: NSArray class) ifTrue: [
			literal := literal objectAtIndex: 0.
		].
		^literal asExp
	]
	makeRangeFrom: first to: second [
		^PKRangeExpression alloc initFrom: first to: second.
	]
	makeToken: tok [
		^PKTokenExpression alloc initWithPattern: tok

	]

	makeSuperGrammar: sup [
		^PKParser getGrammar: sup.
	]

	makeGrammar: grammarName parent: superGrammar rules: rules [
		| grammar |
		"Note: The grammars returned by PKParser are actually PKRules instances."
		'' = superGrammar ifTrue: [
			grammar := PKParser getNewGrammar: grammarName
		] ifFalse: [
			grammar := PKParser derivate: superGrammar subgrammar: grammarName.
		].
		ETTranscript debug: 'Building grammar ''', grammarName, ''''; debugCr.
		
		rules do: [ :each |
			| name expression |
			name := each objectForKey: 'rule'.
			expression := each objectForKey: 'expression'.
			" We need to materialize expressions whose building has been delayed
			  because the need to know about the grammars. "
			(expression isKindOfClass: PKDelayedExpressionBuilder class) ifTrue: [
				expression := expression value.
			].
			ETTranscript debug: 'Adding rule ''', name, ''' expression: ', (expression description); debugCr.
			grammar addRule: name expression: expression.
		].
		^grammar 
	]

	makeNullarySelector: sel [
		^sel selValue
	]


	makeEmpty [^'']

	restrict: arg  [
		^arg
	]

	makeKeywordMessagePart: keyword argument: arg [
		^NSDictionary dictionaryWithObjects: { keyword componentsJoinedByString: ''. arg }
		                            forKeys: { 'selectorPart'. 'argumentName' }
	]

	makeSelectorAndArguments: components [
		| selector args |
		selector := ''.
		args := NSMutableArray new.
		(components isKindOfClass: NSArray class) ifFalse: [ components := { components } ].
		components do: [ :each |
			selector := selector, (each objectForKey: 'selectorPart').
			args addObject: (each objectForKey: 'argumentName').
		].
		^ NSDictionary dictionaryWithObjects: { selector. args }
		                             forKeys: { 'selector'. 'arguments' }
	]

	makeAction: actionInfo [
		^(actionInfo isKindOfClass: NSDictionary class) ifTrue: [
			PKParseAction alloc initWithSelector: (actionInfo objectForKey: 'selector')
		     	                   argumentNames: (actionInfo objectForKey: 'arguments') 	
		] ifFalse: [
			PKParseAction alloc initWithSelector: actionInfo argumentNames: nil
		]
	]

	makePredicate: predicateInfo target: target [
		^(predicateInfo isKindOfClass: NSDictionary class) ifTrue: [
			PKParsePredicate alloc initWithTargetName: target
			                                 selector: (predicateInfo objectForKey: 'selector')
			                            argumentNames: (predicateInfo objectForKey: 'arguments')
		] ifFalse: [
			PKParsePredicate alloc initWithTargetName: target
			                                 selector: predicateInfo
			                            argumentNames: nil
		]
	]

	makeRule: ruleName expression: expression [
		^NSDictionary dictionaryWithObjects: { ruleName. expression }
                                    forKeys: { 'rule'. 'expression' }	
	] 

	makeExpression: expression modifier: mode bind: name predicate: predicate [
		mode = '+' ifTrue: [ expression := expression repeatOneLeast ].
		mode = '*' ifTrue: [ expression := expression repeat ].
		mode = '?' ifTrue: [ expression := expression maybe ].
		name = '' ifFalse: [ expression := expression bind: (name objectAtIndex: 1) ].
		predicate = '' ifFalse: [ expression parameter: predicate ].
		^expression
	]

	makePrefix: junction exp: expression [
		junction = '!' ifTrue: [ expression := expression not ].
		junction = '&' ifTrue: [ expression := expression lookahead ].	
		^expression
	]

	makeSequenceExpression: expressions action: action [
		| expression |
		(expressions isKindOfClass: NSArray class) ifTrue: [
			expression := expressions leftFoldWithInitialValue: nil
			                                         intoBlock: [ :acc :exp|
				(nil == acc) ifTrue: [ exp ]
				            ifFalse: [ 
					"If the argument and not the receiver is a delayed builder, we need to wrap
					 the receiver in one."
					(acc isKindOfClass: PKDelayedExpressionBuilder class) ifFalse: [
						(exp isKindOfClass: PKDelayedExpressionBuilder class) ifTrue: [
							acc := PKDelayedExpressionBuilder alloc initWithExp: acc
						]
					].
					acc seq: exp ]
			].
		] ifFalse: [
			expression := expressions.
		].
		action = '' ifFalse: [
			expression := expression semanticAction: action
		].
		^expression.
	]
	
	makeAlternativeExpression: exp1 alternative: alts [
		| expression |
		'' = alts ifTrue: [ expression := exp1 ]
		       ifFalse: [
			| op expectObj |
			expectObj := false.
			op := nil.
			expression := alts leftFoldWithInitialValue: exp1
			                                  intoBlock: [ :acc :expOrBlock|
				expectObj ifTrue: [
					" The current value is an object, we make sure that the next is being
					  interpreted as a block and update the accumulator by executing the block. "
					expectObj := false.
					"If the argument and not the receiver is a delayed builder, we need to wrap
					 the receiver in one."
					(acc isKindOfClass: PKDelayedExpressionBuilder class) ifFalse: [
						(expOrBlock isKindOfClass: PKDelayedExpressionBuilder class) ifTrue: [
							acc := PKDelayedExpressionBuilder alloc initWithExp: acc
						]
					].
					op value: acc value: expOrBlock
				] ifFalse: [
					" The next element will be an object, we store the operation and return the
					  present state of the accumulator. " 
					op := expOrBlock.
					expectObj := true.
					acc
				]
			].
		].
		^expression
	]
	
	" Returns a closure that is wrapped in an expressionBuilder which can be
	  evaluated by the action creating the grammar in order to install the rule
	  lookup. "
	makeRuleLookup: ruleName fromGrammar: grammarName [
		^PKDelayedExpressionBuilder alloc initWithBlock: [
			PKNonTerminalLookup alloc initWithGrammar: (PKParser getGrammar: grammarName)
			                                     name: ruleName
		]
	]


	" Super lookups are less problematic because the super grammar is
	  required to be resolved prior to the grammar we are parsing right
	  now. "
	makeRuleLookup: ruleName fromSuperGrammar: superGrammar [
		^PKNonTerminalLookup alloc initWithGrammar: superGrammar
			                              name: ruleName
	]

	parseSpecialChar: char [
		^specialCharToChar objectForKey: char
	]

	parseHexChar: value [
		| scanner return |
		scanner := NSScanner scannerWithString: value.
		return := NSMutableString new.
		return appendCharacter: scanner hexIntegerValue.
		^return
	]

	orJunction [^[:exp1 :exp2 | exp1 or: exp2 ]]
	seqJunction [^[:exp1 :exp2 | exp1 seq: exp2 ]]

	makeWildcard [^PKDotExpression new]

	makeAnythingBind: name [ ^(PKAnythingExpression uniqueInstance) bind: name ]

	join: list [
		^list joinAll
	]

	sequence: list [
		^list sequenceAll
	]
]


NSObject subclass: SmalltalkTool [
	
	run [
		| dict parser abStar b c tExp alphaNumeric parameterized multiSequence multiAlternate oMeta oMetaMatch content contentString match |

		ETTranscript setDebugMode: false.
		abStar := PKRepetitionExpression alloc
					 initWithExpression: 'ab' asExp
					 canBeEmpty: false; yourself.

		parser := abStar or: 'a' asExp.
		parser := ('c' asExp repeat) seq: parser seq: PKEmptyExpression uniqueInstance.
		alphaNumeric  := PKAlphanumericExpression new repeat.
		parameterized := (PKNumericExpression new bind: 'num') parameterTarget: 'num' selector: #isLessThan: arguments: {'7'}.
		multiSequence := PKNArySequenceExpression new.
		multiSequence addExpression: ('c' asExp repeat); addExpression: parser; addExpression: PKEmptyExpression uniqueInstance.
		multiAlternate := PKNAryAlternateExpression new.
		multiAlternate addExpression: ('c' asExp); addExpression: ('d' asExp); addExpression: ('e' asExp).
		multiAlternate := multiAlternate repeat.
		oMeta := PKParser alloc initWithNewGrammar: 'Test'.
		oMeta addRule: 'alphaNum'  expression: alphaNumeric.
		ETTranscript show: (parser parseInput: 'cab' asInputStream); cr.
		ETTranscript show: (multiSequence parseInput: 'cab' asInputStream); cr.
		ETTranscript show: (multiAlternate parseInput: 'cde' asInputStream); cr.
		ETTranscript show: alphaNumeric; cr.
		ETTranscript show: (alphaNumeric parseInput: 'Good34'  asInputStream); cr.
		ETTranscript show: (alphaNumeric parseInput: 'testing4'  asInputStream); cr.
		ETTranscript show: (parameterized parseInput: '6' asInputStream); cr.
		ETTranscript show: (parameterized parseInput: '8' asInputStream); cr.
		ETTranscript show: (oMeta match: 'testing4' rule: 'alphaNum'); cr.
		oMeta := self pegGrammar.
		
		ETTranscript show: oMeta; cr.
		ETTranscript show: (oMeta at: 'Char'); cr.
		ETTranscript show: (oMeta match:( '\\n') rule: 'Char').
		ETTranscript show: (oMeta match:('n') rule: 'Char').
		ETTranscript show: (oMeta match:( '\66') rule: 'Char').
		ETTranscript show: (oMeta match:( '\F8') rule: 'Char').
		ETTranscript show: (oMeta match:( '\6E') rule: 'Char').
		ETTranscript show: (oMeta match:( '\6A') rule: 'Char').
		ETTranscript show: (oMeta match:( '\66-\F4') rule: 'Range').
		ETTranscript show: (oMeta match:( 'a-d') rule: 'Range').
		ETTranscript show: (oMeta match:( '[a-d] ') rule: 'Class').
		ETTranscript show: (oMeta match:( '[a-d\34] ') rule: 'Class').
		ETTranscript show: (oMeta match:( '[a-dA-Z]\n') rule: 'Class').
		ETTranscript show: (oMeta match:( '''foo'' bar') rule: 'Literal').
		ETTranscript show: (oMeta match:( '"bar" foo') rule: 'Literal').
		ETTranscript show: (oMeta match:( '. ? ') rule: 'Suffix').
		ETTranscript show: (oMeta match:( '([zf]"oo")?') rule: 'Suffix').
		ETTranscript show: (oMeta match: '' rule: 'Spacing').
		ETTranscript show: (oMeta match: 'One <- .' rule: 'Grammar').
		ETTranscript show: (oMeta match: 'EndOfLine <- ''\\r\\n''' rule: 'Grammar').
		ETTranscript show: (oMeta match: 'Ometa { EndOfLine <- ''\\r\\n'' }' rule: 'Ometa').
		ETTranscript show: (oMeta match: 'Foo' rule: 'Identifier').
		oMeta := self smalltalkPegGrammar: oMeta.
		oMeta setDelegate: (PKParserASTGenerator new).

		content := NSFileManager defaultManager contentsAtPath: './ometa.pk'.
		contentString := NSString alloc initWithData: content encoding: 4.
		self testSubgrammar.
		oMetaMatch := (oMeta match: contentString  rule: 'OmetaList').
		ETTranscript show: oMetaMatch; cr.
		ETTranscript show: oMetaMatch reduce description; cr.
		ETTranscript show: (PKParser getGrammar: 'SmalltalkOmeta') description; cr.
		match := oMeta match: '''test''' rule: 'Literal'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '[a-d] ') rule: 'Class'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '[a-d\34] ') rule: 'Class'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\\t') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\\n') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\\\\') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\5F') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		
	]

	testSubgrammar [
		|grammar sub|
		grammar := PKParser alloc initWithNewGrammar: 'PEG'.
		grammar addRule: 'Ab' expression: ('a' asExp or: 'b' asExp).
		ETTranscript show: (grammar match: 'b'  rule: 'Ab').

		sub := grammar subgrammar: 'PEG2'.
		sub addRule: 'Ab' expression: ('c' asExp or: 'd' asExp).
		ETTranscript show: (sub match: 'b'  rule: 'Ab').
		ETTranscript show: (sub match: 'c'  rule: 'Ab').
	]

	smalltalkPegGrammar: parent [
		| ocParser |
		ocParser := parent subgrammar: 'SmalltalkPEG'.
		ocParser addRule: 'Nullary' expression: (((ocParser at: 'Identifier') bind: 'nullary')
			actionSelector: #makeNullarySelector: arguments: {'nullary'}).
		ocParser addRule: 'Keyword' expression: ((ocParser at: 'IdentStart') seq: (ocParser at: 'IdentCont') repeat seq: (ocParser at: 'COLON')).
		ocParser addRule: 'KeywordMessagePart' expression: ((((ocParser at: 'Keyword') bind: 'selectorPart')
			seq: ((ocParser at: 'Identifier') bind: 'argument'))
				actionSelector: #makeKeywordMessagePart:argument: arguments: {'selectorPart'. 'argument'}).
		ocParser addRule: 'KeywordMessage' expression: (((ocParser at: 'KeywordMessagePart') repeatOneLeast bind: 'selectorArgumentPairs')
			actionSelector: #makeSelectorAndArguments: arguments: {'selectorArgumentPairs'}).
		ocParser addRule: 'Statements' expression: ((ocParser at: 'KeywordMessage') or: (ocParser at: 'Nullary')).
		^ocParser
	]

	pegGrammar [
		| oMeta  |
		oMeta := PKParser alloc initWithNewGrammar: 'PEG'.
		oMeta addRule: 'EndOfLine' expression: ('\r\n' asExp or: '\n' asExp).
		oMeta addRule: 'Space' expression: (' ' asExp or: '\t' asExp or: (oMeta at: 'EndOfLine')).
		oMeta addRule: 'Comment' expression: ('#' asExp seq: ((oMeta at: 'EndOfLine') not 
            seq: (PKDotExpression new) ) repeat seq: (oMeta at: 'EndOfLine')).
		oMeta addRule: 'Spacing' expression: ((((oMeta at: 'Space') or: (oMeta at: 'Comment')) repeat) actionSelector: #makeEmpty arguments: {}).
		oMeta addRule: 'HexDigit' expression: ((PKRangeExpression alloc initFrom: '0' to: '9') or: (PKRangeExpression alloc initFrom: 'A' to: 'F')).
		oMeta addRule: 'DOT' expression: ((('.' asExp bind: 'expr') seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'COLON' expression: (((':' asExp bind: 'expr') seq: (oMeta at: 'Spacing'))actionSelector: #restrict: arguments: { 'expr' } ).
		oMeta addRule: 'CLOSE' expression: ((( ')' asExp  bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }). 
		oMeta addRule: 'OPEN' expression: ((( '(' asExp  bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'CCLOSE' expression: ((( '}' asExp  bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }). 
		oMeta addRule: 'COPEN' expression: ((( '{' asExp  bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'ACLOSE' expression: ((( ']' asExp  bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }). 
		oMeta addRule: 'AOPEN' expression: ((( '[' asExp  bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'PLUS' expression: ((('+' asExp bind: 'expr') seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'STAR' expression: ((('*' asExp bind: 'expr') seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'QUESTION' expression: ((('?' asExp bind: 'expr')  seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'NOT' expression: ((('!' asExp bind: 'expr') seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'SLASH' expression: (( '/' asExp seq: (oMeta at: 'Spacing')) actionSelector: #orJunction arguments: {}).
		oMeta addRule: 'AND' expression: ((('&' asExp bind: 'expr') seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'LEFTARROW' expression: ((( '<-' asExp   bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'RIGHTARROW' expression: ((( '->' asExp   bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'CARET' expression: ((('^' asExp   bind: 'expr')seq: (oMeta at: 'Spacing')) actionSelector: #restrict: arguments: { 'expr' }).
		oMeta addRule: 'Char' expression: 
			((('\' asExp seq: ({'n' . 'r' . 't' . ''''. '"' . '[' . ']'. '\'} joinAll bind: 'specialChar'))  
                          actionSelector: #parseSpecialChar: arguments: {'specialChar'})
				or: (('\' asExp seq: (((oMeta at: 'HexDigit') 
							    seq: (oMeta at: 'HexDigit')) bind: 'hexChar'))
				  actionSelector: #parseHexChar: arguments: {'hexChar'})
			    or: ('\' asExp not seq: (PKDotExpression new)  )).
		oMeta addRule: 'Range' expression: (((((oMeta at: 'Char') bind: 'first') 
        	seq: '-' asExp seq: ((oMeta at: 'Char') bind: 'second')) 
				 actionSelector: #makeRangeFrom:to: arguments: {'first'. 'second'})
        	or: (((oMeta at: 'Char') bind: 'tok') actionSelector: #makeToken: arguments: {'tok'})).
		oMeta addRule: 'Class' expression: (('[' asExp 
                seq: ((']' asExp not seq: (oMeta at: 'Range')) repeat bind: 'rangeList')
                seq: ']' asExp 
                seq: (oMeta at: 'Spacing')) actionSelector: #join: arguments: {'rangeList'}).
		oMeta addRule: 'Literal' expression: ((('''' asExp 
                seq: (('''' asExp not seq: (oMeta at: 'Char')) repeat bind: 'literal') 
				seq: '''' asExp seq: (oMeta at: 'Spacing') ) 
			or: ('"' asExp 
                seq: (('"' asExp not seq: (oMeta at: 'Char')) repeat bind: 'literal') 
				seq: '"' asExp seq: (oMeta at: 'Spacing') ))
		  actionSelector: #makeLiteral: arguments: {'literal'}).
		oMeta addRule: 'IdentStart'  expression: ((PKRangeExpression alloc initFrom: 'a' to: 'z') 
			or: (PKRangeExpression alloc initFrom: 'A' to: 'Z')
			or: '_' asExp).
		oMeta addRule: 'IdentCont' expression: ((oMeta at: 'IdentStart') or: (PKRangeExpression alloc initFrom: '0' to: '9')).
		oMeta addRule: 'Identifier' expression: (((((oMeta at: 'IdentStart') seq: ((oMeta at: 'IdentCont') repeat)) bind: 'ident') seq: (oMeta at: 'Spacing'))
			actionSelector: #restrict: arguments: {'ident'}).
		oMeta addRule: 'SuperRuleApplication' expression: (((oMeta at: 'CARET') seq: ((oMeta at: 'Identifier') bind: 'rule'))
			actionSelector: #makeRuleLookup:fromSuperGrammar: arguments: {'rule'. 'superGrammar'}).
		oMeta addRule: 'ForeignRuleApplication' expression: ((((oMeta at: 'Identifier') bind: 'grammar')
			seq: ('::' asExp)
			seq: ((oMeta at: 'Identifier') bind: 'rule'))
				actionSelector: #makeRuleLookup:fromGrammar: arguments: {'rule'. 'grammar'}).
		oMeta addRule: 'RuleApplication' expression: ((oMeta at: 'SuperRuleApplication')
			or: (oMeta at: 'ForeignRuleApplication')
			or: ((((oMeta at: 'Identifier') bind: 'rule') seq: ((oMeta at: 'LEFTARROW') not))
				actionSelector: #makeRuleLookup:fromGrammar: arguments: {'rule'. 'grammar'})).
		oMeta addRule: 'Primary' expression: ((((((oMeta at: 'RuleApplication') bind: 'expr') seq: (oMeta at: 'LEFTARROW') not)
			or: (((oMeta at: 'OPEN') seq: ((oMeta at: 'Expression') bind: 'expr') seq: (oMeta at: 'CLOSE'))))
				actionSelector: #restrict: arguments: {'expr'})
			or: (oMeta at: 'Literal')
			or: (oMeta at: 'Class')
			or: ((oMeta at: 'DOT') actionSelector: #makeWildcard arguments: {})).
		oMeta addRule: 'Suffix' expression: ((((oMeta at: 'Primary') bind: 'expression')
            seq: (((oMeta at: 'QUESTION') or: (oMeta at: 'STAR') or: (oMeta at: 'PLUS')) maybe bind: 'modifier')
			seq: ((':' asExp seq: (oMeta at: 'Identifier')) maybe bind: 'bindingName')
			seq: ((oMeta at: 'Predicate') maybe bind: 'predicate'))
			   actionSelector: #makeExpression:modifier:bind:predicate: arguments: {'expression'. 'modifier'. 'bindingName'. 'predicate'}).
		oMeta addRule: 'Prefix' expression: ((((((oMeta at: 'AND') or: (oMeta at: 'NOT')) maybe bind: 'junction') 
            seq: ((oMeta at: 'Suffix') bind: 'expression'))
			   actionSelector: #makePrefix:exp: arguments: {'junction'. 'expression'})
			or: (((oMeta at: 'COLON') seq: ((oMeta at: 'Identifier') bind: 'bindingName'))
				actionSelector: #makeAnythingBind: arguments: {'bindingName'})).
		oMeta addRule: 'Action' expression: (((oMeta at: 'RIGHTARROW')
			seq: (oMeta at: 'AOPEN')
			seq: ((oMeta at: 'Statements') bind: 'actionStatements')
			seq: (oMeta at: 'ACLOSE'))
				actionSelector: #makeAction: arguments: {'actionStatements'}).
		oMeta addRule: 'Predicate' expression: (((oMeta at: 'QUESTION') seq: (oMeta at: 'OPEN') seq: ((oMeta at: 'Identifier') bind: 'target')
		    seq: ((oMeta at: 'Statements') bind: 'predicateMessage') seq: (oMeta at: 'CLOSE'))
		       actionSelector: #makePredicate:target: arguments: {'predicateMessage'. 'target'}). 
		oMeta addRule: 'Sequence' expression: ((((oMeta at: 'Prefix')  repeat bind: 'expressions')
        	seq: ((oMeta at: 'Action') maybe bind: 'action'))
				actionSelector: #makeSequenceExpression:action: arguments: {'expressions'. 'action'}).
		oMeta addRule: 'Expression' expression: ((((oMeta at: 'Sequence') bind: 'expression1')
			seq: ((((oMeta at: 'SLASH')
			seq: (oMeta at: 'Sequence')) repeat) bind: 'alternative'))
				actionSelector: #makeAlternativeExpression:alternative: arguments: { 'expression1'. 'alternative' }).
		oMeta addRule: 'Definition' expression: ((((oMeta at: 'Identifier') bind: 'ruleName')
			seq: (oMeta at: 'LEFTARROW')
			seq: ((oMeta at: 'Expression') bind: 'ruleExpression'))
				actionSelector: #makeRule:expression: arguments: {'ruleName'. 'ruleExpression'}).
		oMeta addRule: 'Grammar' expression: (((oMeta at: 'Spacing') seq: (((oMeta at: 'Definition') repeatOneLeast) bind: 'expr'))
			actionSelector: #restrict: arguments: { 'expr'}).
		oMeta addRule: 'SuperGrammarIdentifier' expression: (((oMeta at: 'COLON') seq: ((oMeta at: 'Identifier') bind: 'super'))
			actionSelector: #makeSuperGrammar: arguments: {'super'}).
		oMeta addRule: 'Ometa' expression: ((((oMeta at: 'Identifier') bind: 'grammar')
			seq: (((oMeta at: 'SuperGrammarIdentifier') maybe bind: 'superGrammar'))
            seq: (oMeta at: 'COPEN')
			seq: ((oMeta at: 'Grammar') bind: 'grammarList')
			seq: (oMeta at: 'CCLOSE'))
				actionSelector: #makeGrammar:parent:rules: arguments: {'grammar'. 'superGrammar'. 'grammarList'}).
		oMeta addRule: 'OmetaList' expression: (((oMeta at: 'Spacing') 
            seq: (((oMeta at: 'Ometa') repeatOneLeast) bind: 'grammars')
			seq: PKEmptyExpression uniqueInstance)
				actionSelector: #restrict: arguments: { 'grammars'}).
		^oMeta
	]
]

