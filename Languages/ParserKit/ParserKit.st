"
============================================================================
  ParserKit.st -- OMeta like parser implementation

  Copyright (C) 2011 Mathieu Suen <mathieu@nebu.li>

  The parser have the same syntax that the OMeta one. Although the semantic 
  could differ. For the time being to write expression use the 
  PKParseExpression class. See example at the bottom of the file.

    2012/03/08 Rule lookup can be optimize at runtime

    2012/03/05 Fix way input consuming. 

    2012/02/22 Many bug fix and start to implement a OMeta parser. 
      - Todo fix the way we walk throw the input. When to consume or not
    the input etc.
      - Some PK*Expression should be singleton

    2011/09/21 Beginning of the expression tree
      - Get the expression tree implementation inspire from OMGrammar
 
    2011/10/20 Beginning of the OMeta implementation
      - Adding the PKParserBase PKRules class

    2011/11/09 Todo merge PKRules with PKParserBase

============================================================================
"

NSObject subclass: PKTranscriptController [
	| +inDebugMode |

	+setDebugMode: value [ inDebugMode := value ]
	+isInDebugMode [ ^inDebugMode ]

]

ETTranscript extend [

	+setDebugMode: value [
		PKTranscriptController setDebugMode: value
	]
    +debug: output [
		 PKTranscriptController isInDebugMode ifTrue: [ self show: output]
	 ]

	+debugCr [
		PKTranscriptController isInDebugMode ifTrue: [ self cr]
	]
]

NSString extend [

	concat: other [
		^self stringByAppendingString: other
	]

	asInputStream [
		^PKInputStream alloc initWithStream: self
	]

	matchSize [ ^self length ]
	count [ ^self length]
	isEmpty [^self length = 0]
	isNotEmpty [^self length > 0 ]

	isLessThan: other [
		^(self integerValue) < (other integerValue)
	]
]

Symbole extend [

]

NSObject extend [
	canReduce [^false]
	matchSize [ ^1 ]
	isArray [^false]
]

NSObject subclass: NSDelayActionArray [
	| anArray |

	init [
		super init.
		anArray := NSMutableArray new.
	]

	addObject: anObject [
		anArray addObject: anObject
	]

	addAction: anObject [
		
		(anObject isArray and: (anObject == nil) not)
			ifTrue: [anObject do: [:each | self addObject: each]]
			ifFalse: [self addObject: anObject].
		^self
	]

	isArray [^true]

	do: aBlock [
		anArray do: aBlock
	]

	canReduce [^true]
	reduceOn: target [
		^anArray map: [:each | 
			each canReduce 
                   ifTrue: [each reduceOn: target]
				   ifFalse: [each]]
	]
	description [^'Delay', anArray description]
]

NSObject subclass: NSDelayInvocation [
	| selector args |
	
	+invocationWithSelector: aSelector arguments: someArgs [
		^self alloc initWithSelector: aSelector arguments: someArgs
	]
	initWithSelector: aSelector arguments: someArgs [
		selector := aSelector.
		args := someArgs
	]
	canReduce [^true]
	reduceOn: target [
		| reduceArgs anInvoc |
		reduceArgs := args map: [:each | each canReduce 
                                       ifTrue: [each reduceOn: target]
									   ifFalse: [each]].
		anInvoc := NSInvocation invocationWithTarget: target selector: selector arguments: reduceArgs.
		anInvoc invoke.
		^anInvoc returnValueAsObject
		
	]

	description [
		^ selector description, ' with args: ', args description
	]
]

NSObject subclass: PKParseAction [
	| selector argumentNames |
	
	initWithSelector: sel argumentNames: args [
		selector := sel.
		argumentNames := args.
	]

	invocationInEnvironment: env [
		| argsBuild |
		argsBuild := NSMutableArray new.
		argumentNames do: [:each |
			| value |
			value := env objectForKey: each.
			value == nil ifTrue: [NSException raise: 'ParserKit' format: 'Unknown binding: ', each].
			argsBuild addObject: value.
		].
		^NSDelayInvocation invocationWithSelector: selector arguments: argsBuild
	]
	
	messageString [
		| messageString |
		(selector description hasSuffix: ':') ifTrue: [
			| selectorParts |
			selectorParts := selector description componentsSeparatedByString: ':'.
			selectorParts := selectorParts zippedCollectionWithCollection: argumentNames andBlock: [ 
				:first :second |
				first, ': ', second
			].
			messageString := selectorParts componentsJoinedByString: ' '.
		] ifFalse: [
			messageString := selector description.
		].
		^messageString substringWithRange: (NSValue rangeWithLocation: 1 length: (messageString length - 1))
	]

	description [ ^ '[', self messageString, ']' ]
]


PKParseAction subclass: PKParsePredicate [
	| targetName |
	initWithTargetName: trgt selector: sel argumentNames: args [
		super initWithSelector: sel argumentNames: args.
		targetName := trgt.
		^self
	]

	succeedsInEnvironment: env [
		| target arguments invocation |
		arguments := argumentNames mappedCollectionWithBlock: [ :argName |
			|value |
			value := env objectForKey: argName.
			"FIXME: This is a quick hack. If the value cannot be bound, we assume
			 that it should be interpreted as a literal value."
			value == nil ifTrue: [value := argName].
			value.
		].
		target := env objectForKey: targetName.
		target == nil ifTrue: [target := targetName].
		invocation := NSInvocation invocationWithTarget: target selector: selector arguments: arguments.
		invocation invoke.
		^invocation returnValueAsBool
	]
	
	description [
		^'?(', targetName, ' ', self messageString, ')'.
	]
]
	
		
			

NSObject subclass: PKParseMatch [
	| input range action delegate |

	+emptyMatch: input [
        ^self new initWithInput: input length: 0; 
			yourself
	]

	initWithInput: list length: length [
		super init.
		action := nil.
		input := list.
		range := (NSValue rangeWithLocation: input position length: length).
		input pushPosition: range length + range location.
		^self
	]
	
	copyInitWith: list range: aRange [
		input := list.
		range := aRange.
		action := nil
	]

	sequenceWith: match [
		| newMatch |
		input mergePosition.
		input lastPosition = range location ifFalse: [
			"Can be remove or rephrase later."
			NSException raise: 'ParseKit' format: 'Last position is not same as the location range, something is wrong here range loc: ', range location description, ' last input: ', input lastPosition description, ' match: ', match description, ' merge with: ', self description ].
		(range location + range length) = match range location
			ifFalse: [ NSException raise: 'ParserKit' format: 'Can not add the range, it is not contigus'].
		newMatch := self class alloc copyInitWith: input range: (NSValue rangeWithLocation: range location length: (range length + match  range length)).
		(action == nil and: match matchAction == nil) ifFalse: [
			newMatch attachAction: NSDelayActionArray new.
			newMatch attachAction: action.
			newMatch attachAction: match matchAction.
		].
		^newMatch
	]

	bind: name [
		action == nil 
            ifTrue: [input bind: name object: (input fromRange: range)]
			ifFalse: [input bind: name object: action. action := nil]
	]
	
	setDelegate: anObject  [ delegate := anObject ]
	attachAction: anAction [ 
		action == nil 
			ifTrue:  [action := anAction]
			ifFalse: [action := action addAction: anAction]
	]
	matchAction [^action]
	match  [ ^(input fromRange: range)]
	isEmpty [ ^range length = 0]
	isSuccess [ ^true ]
	isFailure [ ^false ]
	range [^range]
	reduce [^action == nil ifTrue: [nil] ifFalse: [action reduceOn: delegate]]
    stopPosition [^range length + range location]
	matchText [^ input fromRange: range]
	description [
		^'PKMatchSuccess  ( Recognized: ''', self matchText , ''' location: ', range description,' action: ', action description, ')\n' 
	]
]


NSObject subclass: PKParseFail [
	| input failedPosition describ delegate |

	initWithInput: list description: string [
		super init.
		describ := string.
		input := list.
		failedPosition := input position.
		^self
	]
	setDelegate: anObject  [ delegate := anObject]
	stopPosition [^failedPosition]
	isFailure [ ^true ]
	isSuccess [ ^false ]
	matchAction [^nil]
	bind: name ["No sensible thing can be done here"]
	description [ 
		^'PKMatchFailure  ( At: ''',   failedPosition description, ''', ', input stream, ') ', describ, '\n' 
	]
]


NSObject subclass: PKParseExpression [
	
	asExp [^self]

	bind: name [
		^PKBindExpression alloc initWithExp: self name: name
	]

	or: exp [
		^PKAlternateExpression alloc initWithExp: self or: exp.
	]

	or: exp1 or: exp2 [
		^(self or: exp1) or: exp2
	]

	or: exp1 or: exp2 or: exp3 [
		^((self or: exp1) or: exp2) or: exp3
	]

	or: exp1 or:exp2 or: exp3 or: exp4 [
		^(((self or: exp1) or:exp2) or: exp3) or: exp4
	]

	not [
		^PKNegateExpression alloc initWithExp: self
	]

	repeat [
		^PKRepetitionExpression alloc initWithExpression: self canBeEmpty: true
	]

	repeatOneLeast [
		^PKRepetitionExpression alloc initWithExpression: self canBeEmpty: false
	]
	
	seq: exp [
		^PKSequenceExpression alloc initWithFirst: self second: exp
	]

	actionSelector: aSel arguments: args  [
		|action|
		action := PKParseAction alloc initWithSelector: aSel argumentNames: args.
		^PKActionExpression alloc initWithExp: self action: action
	]

	parameterTarget: trgt selector: aSel arguments: args [
		| predicate |
		predicate := PKParsePredicate alloc initWithTargetName: trgt selector: aSel argumentNames: args.
		^PKParameterizedExpression alloc initWithExp: self predicate: predicate
	]	

	seq: exp1 seq: exp2 [
		^(self seq: exp1) seq: exp2
	]

	seq: exp1 seq: exp2 seq: exp3 [
		^(self seq: exp1 seq: exp2) seq: exp3
	]

	seq: exp1 seq: exp2 seq: exp3 seq: exp4 [
		^(self seq: exp1 seq: exp2 seq: exp3) seq: exp4
	]

	maybe [
		^PKMaybeExpression alloc initWithExp: self
	]

	parseInput: sequence [
		^self subclassResponsibility
	]
		
	parseInput: list ifFailed: aBlock [
		| match |
		match := (self parseInput: list).
		^match isFailure ifTrue: [aBlock value]
						 ifFalse: [ match ]
	]

	isMemoizable [ ^true ]

	" We need a special memoizability check for lookups to non-terminals because
	  they might recursively refer to themselves."
	isMemoizableForNonTerminal: name inGrammar: grammar [ ^true ]
]

PKParseExpression subclass: PKDotExpression [
	parseInput: list [
		^list atEnd 
            ifTrue: [PKParseFail alloc initWithInput: list description: 'Unexpected end of stream']
			ifFalse: [PKParseMatch alloc initWithInput: list length: list head length]
	]

	description [
		^'.'
	]
]

PKParseExpression subclass: PKAlphabeticExpression [
	
	parseInput: list [
		^list head isEmpty 
			ifTrue: [PKParseFail alloc initWithInput: list description: 'Expected alphabetic character']
			ifFalse: [
				(list head characterAtIndex: 0) isAlphabetic
			        ifTrue: [PKParseMatch alloc initWithInput: list length: list head length]
			        ifFalse: [PKParseFail alloc initWithInput: list description: 'Expected alphabetic character']]
	]

	description [
		^'[a-zA-Z]'
	]
]

PKParseExpression subclass: PKRangeExpression [
	| from to |

	initFrom: fromChar to: toChar [
		self init.
		from := fromChar.
		to := toChar.
		^self
	]

	parseInput: list [
		^list head isEmpty 
            ifTrue: [PKParseFail alloc initWithInput: list description: 'Expected character [', from, '-', to, ']']
			ifFalse: [
		         (((list head characterAtIndex: 0) >= ( from  characterAtIndex: 0)) and: ((list head characterAtIndex: 0) <= (to characterAtIndex: 0)))
	                   ifTrue: [PKParseMatch alloc initWithInput: list length: list head length]
		               ifFalse: [PKParseFail alloc initWithInput: list description: 'Expected character [', from, '-', to, ']']]
		
	]

	description [
		^'[', from, '-', to, ']'
	]
	
]

PKParseExpression subclass: PKNumericExpression [

	parseInput: list [
		^list head isEmpty ifTrue: [PKParseFail alloc initWithInput: list description: 'Expected digit character']
			ifFalse: [
				(list head characterAtIndex: 0) isDigit
			        ifTrue: [PKParseMatch alloc initWithInput: list length: list head length]
			        ifFalse: [PKParseFail alloc initWithInput: list description: 'Expected digit character']]

	]

	description [
		^'[0-9]'
	]
]

"Abstract class for composing expression"
PKParseExpression subclass: PKComposeExpression [
	| exp |

	initWithExp: expression [ 
		super init.
		exp := expression. 
		^self 
	]

	description [
		^exp description	
	]

	parseInput: list [
	    ^exp parseInput: list	
	]

	expression [^exp]

	" Non-Memoizability is inherited. "
	isMemoizable [ ^exp isMemoizable ]
	isMemoizableForNonTerminal: name inGrammar: grammar [ ^exp isMemoizableForNonTerminal: name inGrammar: grammar ] 
]

PKComposeExpression subclass: PKActionExpression [
	| action |
	
	initWithExp: aExp action: anAction [
		super initWithExp: aExp.
		action := anAction
	]

	parseInput: list [
		| match |
		
		match := exp parseInput: list.
		match isSuccess  ifTrue: [
			match attachAction: (action invocationInEnvironment: list environment)
		].
		
		^match
	]
	description [ ^exp description, ' -> ', action description ]
]

PKComposeExpression subclass: PKParameterizedExpression [
	| predicate |
	initWithExp: aExp predicate: pred [
		super initWithExp: aExp.
		predicate := pred.
	]
	parseInput: list [
		| match |
		match := exp parseInput: list.
		^match isSuccess ifTrue: [
			(predicate succeedsInEnvironment: (list environment)) ifTrue: [ match ]
			ifFalse: [
				list popPosition.
				PKParseFail alloc initWithInput: list
				                    description: ('Expected ', exp description, ' to satisfy parameter ', predicate description)].
		] ifFalse: [ match ].
	]
	
	description [
		^exp description, ' ', predicate description
	]
	
	isMemoizable [ ^false ]
	isMemoizableForNonTerminal: name inGrammar: grammar [ ^false ] 
]

PKComposeExpression subclass: PKNonTerminalExpression [
	| name  |
	initWithName: string exp: expression [
		super init.
		exp := expression.
		name := string.
		^self
	]

	parseInput: list  [
		| match |
		list inEnvironmentDo: [
			exp == nil ifTrue: [NSException raise: 'ParserKit' format: 'Uncomplete grammar definition for ', name].
			ETTranscript debug: 'Try non terminal: ', name, ' input pos: '; debug: list positionStack; debugCr.
			match := list matchRule: name.
			(match == nil) ifTrue: [
				| position |
				position := list position.
				match := exp parseInput: list.
				" Only memoize the matches from expressions for which it is safely possible. "
				exp isMemoizable ifTrue: [list addMatch: match at: position named: name].
			] ifFalse: [match isSuccess ifTrue: [
				ETTranscript debug: 'Pushing back position: '; debug: match stopPosition; debugCr.
				list pushPosition: match stopPosition]].
			ETTranscript debug: 'End of non terminal: ', name, ' input pos: '; debug: list positionStack; debugCr.
		].
		^match
	]

	setExpression: anExp [ exp := anExp ]
	description [^name]
]

PKComposeExpression subclass: PKAlphanumericExpression [

	init [
		self initWithExp: (  PKAlphabeticExpression new or: PKNumericExpression new )
	]
]

PKParseExpression subclass: PKTokenExpression [
	| match |

	initWithPattern: matchPattern [
		super init.
		match := matchPattern.
		^self
	]
	
	parseInput: list [
		| return |
		((list head: match matchSize) isEqual: match) ifTrue: [ 
			return := PKParseMatch alloc initWithInput: list
								length: match matchSize.
		] ifFalse: [
			return := PKParseFail alloc initWithInput: list description: 'Unexpected token, expected: ', match
		].
		^return
	]

	description [
		^'''', match description, ''''
	]
]

PKParseExpression subclass: PKEmptyExpression [
	| +instance |

	+initialize [
        instance := self new.
	]

	+uniqueInstance [
        ^instance
	]

	parseInput: list [
		^list atEnd
            ifTrue: [PKParseMatch alloc initWithInput: list length: 0]
			ifFalse: [PKParseFail alloc initWithInput: list description:  'Expected an empty string'] 
	]

	description [
		^ '$'
	]
]

PKParseExpression subclass: PKSequenceExpression [
 	| e1 e2 |

	initWithFirst: exp1 second: exp2 [
		e1 := exp1.
		e2 := exp2.
		^self
	] 

	parseInput: list [
		| match1 |
		match1 := e1 parseInput: list.
		^match1 isSuccess ifTrue: [
			| match2 |
			match2 := (e2 parseInput: list).
			match2 isSuccess 
                ifTrue: [ 
					ETTranscript debug: 'Merge sequence: ', match1 matchText, ' with: ', match2 matchText; debugCr.
					match1 sequenceWith: match2 ]
				ifFalse: [ list popPosition. match2 ]
		] ifFalse: [ match1 ]
	]

	description [
		^e1 description, ' ', e2 description
	]

	isMemoizable [ ^e1 isMemoizable ifTrue: [e2 isMemoizable]
			               ifFalse: [false] ]

	isMemoziableForNonTerminal: name inGrammar: grammar [ ^ (e1 isMemoizableForNonTerminal: name inGrammar: grammar) and:
		(e2 isMemoizableForNonTerminal: name inGrammar: grammar) ]
]

PKComposeExpression subclass: PKBindExpression [
	| name |

	initWithExp: exp name: aName [
		super initWithExp: exp.
		name := aName
	]

	parseInput: list [
		| match |
		match := exp parseInput: list.
		match bind: name.
		^match
	]

	description [ ^'(', exp description, '):', name ]
	
]

PKComposeExpression subclass: PKLookAheadExpression [

	
	parseInput: list [
		| match |
		match := exp parseInput: list.
		match isFailure ifFalse: [list popPosition].
		^match
	]
	
	description [ ^'!!(', exp description, ')' ]
]

PKComposeExpression subclass: PKNegateExpression [

	initWithExp: expression [
		super initWithExp: (PKLookAheadExpression alloc initWithExp: expression).
		^self
	]

	description [
		^'!(',exp expression description,')'
	]

	parseInput: list [
		| match |
		match := exp parseInput: list.
		^match isSuccess ifTrue: [PKParseFail alloc initWithInput: list description: 'Should not match ', exp description] 
						 ifFalse: [PKParseMatch alloc initWithInput: list length: 0]
	]
]

PKComposeExpression subclass: PKMaybeExpression [
	parseInput: list [
		| match |
		match := exp parseInput: list.
		^match isSuccess ifTrue: [match]
						 ifFalse: [PKParseMatch alloc initWithInput: list length: 0]
	]
	
	description [^'(', exp description, ')?']
]

PKParseExpression subclass: PKAlternateExpression [
     | first second |

	initWithExp: exp1 or: exp2 [
		first := exp1.
		second := exp2
	]

	parseInput: list [
		 ^first parseInput: list ifFailed: [
			 | match |
			 match := second parseInput: list.
			 match isFailure 
                 ifTrue:[ PKParseFail alloc initWithInput: list description: 'Expected ', self description]
				 ifFalse: [match]
		 ]		
	 ]

	description [
		^first description, ' / ', second description
	]
	
	isMemoizable [ ^first isMemoizable ifTrue: [second isMemoizable]
			                  ifFalse: [false] ]

	isMemoziableForNonTerminal: name inGrammar: grammar [ ^ (first isMemoizableForNonTerminal: name inGrammar: grammar) and:
		(second isMemoizableForNonTerminal: name inGrammar: grammar) ]
]

PKComposeExpression subclass: PKRepetitionExpression [
	| canBeEmpty |

	initWithExpression: anExp canBeEmpty: aBool [
		super init.
		exp := anExp.
		canBeEmpty := aBool.
		^self
	]
	
	parseInput: list [
		| match currentMatch |
		match := PKParseMatch emptyMatch: list.
		[
			currentMatch := exp parseInput: list.
			currentMatch isSuccess
		] whileTrue: [ 
			ETTranscript debug: 'Merge repetition ', match matchText, ' with: ', currentMatch matchText; debugCr.
			match := match sequenceWith: currentMatch.
		].
		^(match isEmpty and: canBeEmpty not) 
            ifTrue: [list popPosition. PKParseFail new initWithInput: list description: 'Unexpected token, expected: ', exp description ]
			ifFalse: [match]
	]

	description [
		^exp description , (canBeEmpty ifTrue: ['*'] ifFalse: ['+'])
	]
]

PKParseExpression subclass: PKNonTerminalLookup [
	| grammar name |
	initWithGrammar: aGrammar name: aName [
		grammar := aGrammar.
		name := aName
	]

	parseInput: list [
		"ETTranscript debug: 'Apply ', name, ' at: '; debug: list position; debugCr."
		^grammar apply: name
	]

	isMemoizable [ ^(grammar rules lookup: name ifFailed: [^false]) isMemoizableForNonTerminal: name inGrammar: grammar ]

	isMemoizableForNonTerminal: aName inGrammar: aGrammar [ ^((grammar == aGrammar) and: (name = aName)) ifTrue: [true] 
		ifFalse: [self isMemoizable]
	]
	description [ ^name ]
]

"--- Recursive Extend ---"
NSString extend [
	asExp [
		^PKTokenExpression new initWithPattern: self
	]
]

NSObject subclass: PKInputStream [
    | memo stream position positionStack positionStack currentEnvironment |

    initWithStream: input [
        stream := input.
        memo := NSMutableDictionary new.
		positionStack := NSMutableArray new.
		position := 0.
		currentEnvironment := NSMutableDictionary new.
		^self
	]

	description [
		^(stream substringWithRange: (NSValue rangeWithLocation: position length: stream length - position)), ' pos: ', positionStack description
	]

	inEnvironmentDo: aBlock [
		| previousEnvironment |
		previousEnvironment := currentEnvironment.
		currentEnvironment := NSMutableDictionary new.
		aBlock value.
		currentEnvironment := previousEnvironment
	]

	bind: name object: anObject [
		currentEnvironment setValue: anObject forKey: name
	]

	environment [^currentEnvironment ]

    addMatch: parserMatch at: position named: aString [
		| matchList |
		((memo objectForKey: position) == nil)
			 ifTrue: [memo setValue: NSMutableDictionary new forKey: position].
		matchList := memo objectForKey: position.
		matchList setValue: parserMatch forKey: aString
	]

	matchRule: string [
		^self matchAt: position rule: string
	]

	matchAt: position rule: aString [
		| matchList |
		matchList := memo objectForKey: position.
		^(matchList == nil)
            ifTrue: [nil]
			ifFalse: [matchList objectForKey: aString]
	]

	pushPosition: anInt [
		positionStack addObject: position.
		position := anInt
	]

	lastPosition [
		^positionStack lastObject
	]

	popPosition [
		position := positionStack lastObject.
		positionStack removeLastObject.
	]

	fromRange: range [
		^(range length == 0) ifTrue: ['']
			ifFalse: [
				stream substringWithRange: range]
	]

	head [
		^self head: 1
	]
	
	head: size [
		"Todo non local return seems broken"
		^(position + size) > stream length ifTrue: ['']
			ifFalse: [self fromRange: (NSValue rangeWithLocation: position length: size)]
	]

	mergePosition [
		positionStack count >= 2 ifFalse: [NSException raise: 'PKParser' format: 'Not enought position to merge'].
		positionStack removeLastObject
	]

	position [^position]
	positionStack [^positionStack]
	length [ ^stream length]
	atEnd [^self position = stream length]
	stream [ ^stream ]
]

NSObject subclass: PKRules [
	| parent rules name |

	initWithName: string [
		super init.
		name := string.
		parent := nil.
		rules := NSMutableDictionary new.
		^self
	]

	at: rule [
		^self lookup: rule ifFailed: [
			| ruleExp |
			ruleExp := PKNonTerminalExpression alloc initWithName: rule exp: nil.
			rules setValue: ruleExp forKey: rule.
			ruleExp
		]
	]

	addRule: name expression: exp [
		| rule |
		rule := rules objectForKey: name.
		rule == nil ifTrue: [
			rule := PKNonTerminalExpression alloc initWithName: name exp: exp.
		    rules setValue: rule forKey: name
		] ifFalse: [
			rule setExpression: exp
		].
		^rule
	]

	lookup: rule ifFailed: aBlock [
		| return |
		return := rules objectForKey: rule.
		return == nil ifTrue:[
			parent == nil
                ifTrue: [ return := aBlock value ]
				ifFalse: [	
					return := parent lookup: rule ifFailed: aBlock
				]
		].
		^return	
	]
		
	initWithParent: pkRules name: string [
		self initWithName: string.
		parent := pkRules
	]

	description [
		| desc |
		desc := name, ' {\n'.
		rules allKeys do: [:key | 
			desc := desc, key, ' <- ', (rules objectForKey: key) expression description, '\n'
		].
		^desc, '}'	
	]
		
	subgrammar: string [
		^self class alloc initWithParent: self name: string
	]
]


NSArray extend [
	joinAll [
		| exp |
		exp := nil.
		self do: [ :value |
			(exp == nil)
                ifTrue: [
					exp := value asExp]
				ifFalse: [exp := exp or: value asExp].
		].
		^exp
	]
	sequenceAll [
		| exp |
		exp := nil.
		self do: [ :value |
			(exp == nil)
                ifTrue: [
					exp := value asExp]
				ifFalse: [exp := exp seq: value asExp].
		].
		^exp
	]
]

NSObject subclass: PKParser [
	| input +rulesRepo rules actionObject delegate |

	+derivate: parent subgrammar: name [
		| rule newRule |
		newRule := parent subgrammar: name.
		rulesRepo setValue: newRule forKey: name.
		^newRule
	]

	+getGrammar: name [
		| rule |
		rule := rulesRepo objectForKey: name.
		rule == nil ifTrue: [
			^NSException raise: 'ParserKit' format: 'Can not found grammar ''', name, ''''
		].
		^rule	
	]

	+getNewGrammar: name [
		| rule |
		rule := PKRules alloc initWithName: name.
		rulesRepo setValue: rule forKey: name.
		^rule	
	]

	setDelegate: anObject [
		delegate := anObject
	]

    initWithGrammar: grammarName [
		rules := self class getGrammar: grammarName.
		^self
	]

	initWithNewGrammar: grammarName [
		rules := self class getNewGrammar: grammarName.
		^self
	]

	setActionObject: obj [
		actionObject := actionObject
	]

	subgrammar: name [
		rules := self class derivate: rules subgrammar: name.
	]

	at: rule [
		^PKNonTerminalLookup alloc initWithGrammar: self name: rule
	]

	addRule: name expression: exp  [
		rules addRule: name expression: exp
	]

	description [
		^rules description
	]
	
	apply: rule [
		| exp |
		exp := rules lookup: rule ifFailed: [
			NSException raise: 'ParserKit' format: 'Invalid rule'
		].
		^exp parseInput: input.
	]
	
	match: inputStream rule: rule [
		|match|
		input := PKInputStream alloc initWithStream: inputStream.
		match := self apply: rule.
		match setDelegate: delegate.
		^match
	]

	rules  [ ^rules ]
   
]

NSObject subclass: PKAstExpressionGen [
	| expression operation |

	initWithExp: exp operation: op [
		expression := exp.
		operation := op
	]

	reduce: exp [
		exp == nil 
            ifFalse: [ expression ]
			ifTrue: [ operation value: exp value: expression ]
	]
]

NSObject subclass: PKPegAstGen [
	| specialCharToChar |

	init [
		super init.
		specialCharToChar := NSMutableDictionary new.
		specialCharToChar setValue: '\n' forKey: 'n'.
		specialCharToChar setValue: '\t' forKey: 't'.
		specialCharToChar setValue: '\\' forKey: '\\'.
		specialCharToChar setValue: '''' forKey: ''''.
		specialCharToChar setValue: '"' forKey: '"'.
		specialCharToChar setValue: '[' forKey: '['.
		specialCharToChar setValue: ']' forKey: ']'.
	]
	
	makeLiteral: literal [
		^literal asExp
	]
	makeRangeFrom: first to: second [
		^PKRangeExpression alloc initFrom: first to: second.
	]
	makeToken: tok [
		^PKTokenExpression alloc initWithPattern: tok

	]

	makeExpression: expression modifier: mode bind: name [
		mode = '+' ifTrue: [ expression := expression repreatOneLeast ].
		mode = '*' ifTrue: [ expression := expression repeat ].
		mode = '?' ifTrue: [ expression := expression maybe ].
		name = '' ifFalse: [ expression := expression bind: name ].
		^expression
	]

	makePrefix: junction exp: expression [
		^PKAstExpressionGen alloc initWithExp: expression operation: junction
	]

	parseSpecialChar: char [
		^specialCharToChar objectForKey: char
	]

	parseHexChar: value [
		| scanner return |
		scanner := NSScanner scannerWithString: value.
		return := NSMutableString new.
		return appendCharacter: scanner hexIntegerValue.
		^return
	]

	orJunction [^[:exp1 :exp2 | exp1 or: exp2 ]]
	seqJunction [^[:exp1 :exp2 | exp1 seq: exp2 ]]

	makeWildcard [^PKDotExpression new]

	join: list [
		^list joinAll
	]

	sequence: list [
		^list sequenceAll
	]
]


NSObject subclass: SmalltalkTool [
	
	run [
		| dict parser abStar abStar b c tExp alphaNumeric parameterized oMeta content contentString match |

		ETTranscript setDebugMode: false.
		abStar := PKRepetitionExpression alloc
					 initWithExpression: 'ab' asExp
					 canBeEmpty: false; yourself.

		parser := abStar or: 'a' asExp.

		parser := ('c' asExp repeat) seq: parser seq: PKEmptyExpression uniqueInstance.

		alphaNumeric  := PKAlphanumericExpression new repeat.
		parameterized := (PKNumericExpression new bind: 'num') parameterTarget: 'num' selector: #isLessThan: arguments: {'7'}.
		oMeta := PKParser alloc initWithNewGrammar: 'Test'.
		oMeta addRule: 'alphaNum'  expression: alphaNumeric.
		ETTranscript show: (parser parseInput: 'cab' asInputStream); cr.
		ETTranscript show: alphaNumeric; cr.
		ETTranscript show: (alphaNumeric parseInput: 'Good34'  asInputStream); cr.
		ETTranscript show: (alphaNumeric parseInput: 'testing4'  asInputStream); cr.
		ETTranscript show: (parameterized parseInput: '6' asInputStream); cr.
		ETTranscript show: (parameterized parseInput: '8' asInputStream); cr.
		ETTranscript show: (oMeta match: 'testing4' rule: 'alphaNum'); cr.
		oMeta := self pegGrammar.
		
		ETTranscript show: oMeta; cr.
		ETTranscript show: (oMeta at: 'Char'); cr.
		ETTranscript show: (oMeta match:( '\\n') rule: 'Char').
		ETTranscript show: (oMeta match:('n') rule: 'Char').
		ETTranscript show: (oMeta match:( '\66') rule: 'Char').
		ETTranscript show: (oMeta match:( '\F8') rule: 'Char').
		ETTranscript show: (oMeta match:( '\6E') rule: 'Char').
		ETTranscript show: (oMeta match:( '\6A') rule: 'Char').
		ETTranscript show: (oMeta match:( '\66-\F4') rule: 'Range').
		ETTranscript show: (oMeta match:( 'a-d') rule: 'Range').
		ETTranscript show: (oMeta match:( '[a-d] ') rule: 'Class').
		ETTranscript show: (oMeta match:( '[a-d\34] ') rule: 'Class').
		ETTranscript show: (oMeta match:( '[a-dA-Z]\n') rule: 'Class').
		ETTranscript show: (oMeta match:( '''foo'' bar') rule: 'Literal').
		ETTranscript show: (oMeta match:( '"bar" foo') rule: 'Literal').
		ETTranscript show: (oMeta match:( '. ? ') rule: 'Suffix').
		ETTranscript show: (oMeta match:( '([zf]"oo")?') rule: 'Suffix').
		ETTranscript show: (oMeta match: '' rule: 'Spacing').
		ETTranscript show: (oMeta match: 'One <- .' rule: 'Grammar').
		ETTranscript show: (oMeta match: 'EndOfLine <- ''\\r\\n''' rule: 'Grammar').
		ETTranscript show: (oMeta match: 'Ometa { EndOfLine <- ''\\r\\n'' }' rule: 'Ometa').
		oMeta := self smalltalkPegGrammar: oMeta.
		oMeta setDelegate: (PKPegAstGen new).

		content := NSFileManager defaultManager contentsAtPath: './ometa.pk'.
		contentString := NSString alloc initWithData: content encoding: 4.
		self testSubgrammar.
		ETTranscript show: (oMeta match: contentString  rule: 'OmetaList').
		match := oMeta match: '''test''' rule: 'Literal'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '[a-d] ') rule: 'Class'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '[a-d\34] ') rule: 'Class'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\\t') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\\n') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\\\\') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		match := oMeta match:( '\5F') rule: 'Char'.
		ETTranscript show: match.
		ETTranscript show: match reduce; cr.

		
	]

	testSubgrammar [
		|grammar sub|
		grammar := PKParser alloc initWithNewGrammar: 'PEG'.
		grammar addRule: 'Ab' expression: ('a' asExp or: 'b' asExp).
		ETTranscript show: (grammar match: 'b'  rule: 'Ab').

		sub := grammar subgrammar: 'PEG2'.
		sub addRule: 'Ab' expression: ('c' asExp or: 'd' asExp).
		ETTranscript show: (sub match: 'b'  rule: 'Ab').
		ETTranscript show: (sub match: 'c'  rule: 'Ab').
	]

	smalltalkPegGrammar: parent [
		| ocParser |
		ocParser := parent subgrammar: 'SmalltalkOmeta'.
		ocParser addRule: 'Unary' expression: (ocParser at: 'Identifier').
		ocParser addRule: 'Keyword' expression: ((ocParser at: 'IdentStart') seq: (ocParser at: 'IdentCont') repeat seq: (ocParser at: 'COLON')).
		ocParser addRule: 'KeywordMessage' expression: ((ocParser at: 'Keyword') seq: (ocParser at: 'Identifier')) repeatOneLeast.
		ocParser addRule: 'Statements' expression: ((ocParser at: 'KeywordMessage') or: (ocParser at: 'Unary')).
		^ocParser
	]

	pegGrammar [
		| oMeta  |
		oMeta := PKParser alloc initWithNewGrammar: 'PEG'.
		oMeta addRule: 'EndOfLine' expression: ('\r\n' asExp or: '\n' asExp).
		oMeta addRule: 'Space' expression: (' ' asExp or: '\t' asExp or: (oMeta at: 'EndOfLine')).
		oMeta addRule: 'Comment' expression: ('#' asExp seq: ((oMeta at: 'EndOfLine') not 
            seq: (PKDotExpression new) ) repeat seq: (oMeta at: 'EndOfLine')).
		oMeta addRule: 'Spacing' expression: ((oMeta at: 'Space') or: (oMeta at: 'Comment')) repeat.
		oMeta addRule: 'HexDigit' expression: ((PKRangeExpression alloc initFrom: '0' to: '9') or: (PKRangeExpression alloc initFrom: 'A' to: 'F')).
		oMeta addRule: 'DOT' expression: ('.' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'COLON' expression: (':' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'CLOSE' expression: ( ')' asExp seq: (oMeta at: 'Spacing')). 
		oMeta addRule: 'OPEN' expression: ( '(' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'CCLOSE' expression: ( '}' asExp seq: (oMeta at: 'Spacing')). 
		oMeta addRule: 'COPEN' expression: ( '{' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'ACLOSE' expression: ( ']' asExp seq: (oMeta at: 'Spacing')). 
		oMeta addRule: 'AOPEN' expression: ( '[' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'PLUS' expression: ( '+' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'STAR' expression: ( '*' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'QUESTION' expression: ( '?' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'NOT' expression: ( '!' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'SLASH' expression: (( '/' asExp seq: (oMeta at: 'Spacing')) actionSelector: #orJunction arguments: {}).
		oMeta addRule: 'AND' expression: (( '&' asExp seq: (oMeta at: 'Spacing')) actionSelector: #seqJunction arguments: {}).
		oMeta addRule: 'LEFTARROW' expression: ( '<-' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'RIGHTARROW' expression: ( '->' asExp seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'Char' expression: 
			((('\' asExp seq: ({'n' . 'r' . 't' . ''''. '"' . '[' . ']'. '\'} joinAll bind: 'specialChar'))  
                          actionSelector: #parseSpecialChar: arguments: {'specialChar'})
				or: (('\' asExp seq: (((oMeta at: 'HexDigit') 
							    seq: (oMeta at: 'HexDigit')) bind: 'hexChar'))
				  actionSelector: #parseHexChar: arguments: {'hexChar'})
			    or: ('\' asExp not seq: (PKDotExpression new)  )).
		oMeta addRule: 'Range' expression: (((((oMeta at: 'Char') bind: 'first') 
                         seq: '-' asExp seq: ((oMeta at: 'Char') bind: 'second')) 
												 actionSelector: #makeRangeFrom:to: arguments: {'first'. 'second'})
                 or: (((oMeta at: 'Char') bind: 'tok') actionSelector: #makeToken: arguments: {'tok'})).
		oMeta addRule: 'Class' expression: (('[' asExp 
                seq: ((']' asExp not seq: (oMeta at: 'Range')) repeat bind: 'rangeList')
                seq: ']' asExp 
                seq: (oMeta at: 'Spacing')) actionSelector: #join: arguments: {'rangeList'}).
		oMeta addRule: 'Literal' expression: ((('''' asExp 
                seq: (('''' asExp not seq: (oMeta at: 'Char')) repeat bind: 'literal') 
				seq: '''' asExp seq: (oMeta at: 'Spacing') ) 
			or: ('"' asExp 
                seq: (('"' asExp not seq: (oMeta at: 'Char')) repeat bind: 'literal') 
				seq: '"' asExp seq: (oMeta at: 'Spacing') ))
		  actionSelector: #makeLiteral: arguments: {'literal'}).
		oMeta addRule: 'IdentStart'  expression: ((PKRangeExpression alloc initFrom: 'a' to: 'z') 
			or: (PKRangeExpression alloc initFrom: 'A' to: 'Z')
			or: '_' asExp).
		oMeta addRule: 'IdentCont' expression: ((oMeta at: 'IdentStart') or: (PKRangeExpression alloc initFrom: '0' to: '9')).
		oMeta addRule: 'Identifier' expression: ((oMeta at: 'IdentStart') seq: (oMeta at: 'IdentCont') repeat seq: (oMeta at: 'Spacing')).
		oMeta addRule: 'Primary' expression: (((oMeta at: 'Identifier') seq: (oMeta at: 'LEFTARROW') not)
			or: ((oMeta at: 'OPEN') seq: (oMeta at: 'Expression') seq: (oMeta at: 'CLOSE'))
			or: (oMeta at: 'Literal')
			or: (oMeta at: 'Class')
			or: ((oMeta at: 'DOT') actionSelector: #makeWildcard arguments: {})).
		oMeta addRule: 'Suffix' expression: ((((oMeta at: 'Primary') bind: 'expression')
            seq: (((oMeta at: 'QUESTION') or: (oMeta at: 'STAR') or: (oMeta at: 'PLUS')) maybe bind: 'modifier')
			seq: ((':' asExp seq: (oMeta at: 'Identifier')) maybe bind: 'bindingName'))
			   actionSelector: #makeExpression:modifier:bind: arguments: {'expression'. 'modifier'. 'bindingName'}) .
		oMeta addRule: 'Prefix' expression: (((((oMeta at: 'AND') or: (oMeta at: 'NOT')) maybe bind: 'junction') 
            seq: ((oMeta at: 'Suffix') bind: 'expression'))
			   actionSelector: #makePrefix:exp: arguments: {'junction'. 'expression'}).
		oMeta addRule: 'Sequence' expression: ((oMeta at: 'Prefix') repeat 
           seq: ((oMeta at: 'RIGHTARROW') 
                    seq: (oMeta at: 'AOPEN') 
					seq: (oMeta at: 'Statements') 
					seq: (oMeta at: 'ACLOSE') ) maybe).
		oMeta addRule: 'Expression' expression: ((oMeta at: 'Sequence') seq: ((oMeta at: 'SLASH') seq: (oMeta at: 'Sequence')) repeat).
		oMeta addRule: 'Definition' expression: ((oMeta at: 'Identifier') seq: (oMeta at: 'LEFTARROW') seq: (oMeta at: 'Expression')).
		oMeta addRule: 'Grammar' expression: ((oMeta at: 'Spacing') seq: (oMeta at: 'Definition') repeatOneLeast).
		oMeta addRule: 'Ometa' expression: ((oMeta at: 'Identifier')
			seq: ((oMeta at: 'COLON') seq: ((oMeta at: 'Identifier') bind: 'superGrammar')) maybe
            seq: (oMeta at: 'COPEN')
			seq: ((oMeta at: 'Grammar') bind: 'grammarList')
			seq: (oMeta at: 'CCLOSE')).
		oMeta addRule: 'OmetaList' expression: ((oMeta at: 'Spacing') 
            seq: (oMeta at: 'Ometa') repeatOneLeast 
			seq: PKEmptyExpression uniqueInstance ).
		^oMeta
	]
]

