TODO
====

First Release
-------------

- Major tasks
  x App-level undo
    - polish, fine-tune api
  - Diff/merge cleanup
  - Cleanup COObject, synthesize accessors
  - Copying support

- Tests
  - Pass all tests, including all from NestedVersioning, rewriting them where needed.

- COEditingContext / COPersistentRoot / COBranch
  - support for loading the root object of a persistent root as a fault
  - asychronous loading of persistent root contents / unfaulting faulted root object
  - full support for cross-persistent root references
    - handle persistent roots unloading
    - all other corner cases in TestCrossPersistentRootReferences.m
  x Use notifications posted by COSQLiteStore (very basic support)
    - complete support
    - full set of test cases
    - think of all corner cases
  - support "transient roots" in a COEditingContext. These are COObjectGraphContext wrappers.
    Or, support creating a persistent root in code, then calling "freeze" which will make it 
    read-only and prevent it from being committed to disk?
  - make deleted persistent roots read-only?
  - expose COSQLiteStore's finalize deletion method
  - (aesthetic) decide to what extent COPersistentRoot, COBranch should
    provide convenience methods that deletate to the COObjectGraphContext:
      [[(COPersistentRoot *)self editingBranch] objectGraphContext]
      
    e.g. I think we should surely keep:
     -[COPersistentRoot rootObject] = { return [[self editingBranch] rootObject]; }
     -[COBranch rootObject] = { return [[self objectGraphContext] rootObject]; }
     
    All of the other methods, I don't know.
  - Extend COBranch API to support branches and merging revisions accross tracks
  - Expose COSQLiteStore's attachments feature
  x Document COBranch class

- didAwaken: replacement
    - At the end of the setStoreItem:, call -awakeFromDeserialization
    - At the end of object graph loading, -didLoadObjectGraph on each object in topological sort order

- diff/merge API and code
  - Improve Merging (move detection and custom attributed string merger)
  - Need to support persisted partial merge resolutions.
    - Thought about this a bit. I don't think we can provide it in general in the framework,
      apps will have to implement support for it.
      
      Some apps may want to open a temporary persistent root, with its own
      metamodel for managing the merge, others may want to do it only in memory.
      
      Also, though the diff/merge happens at the persistent root granularity,
      there may be multiple embedded object trees with different merge UI's.
      (e.g. several types of objects on a canvas in a composite documents)
  - Build an example app with a merging UI
  - Requirements:
    - We will highlight the area where a conflict appeared. It will show the automatic result, and let the user make a manual edit
    - allow both collapsed (like SourceTree) and expanded (like Xcode) diff view

x Undo/redo support (app-level)
  x Requirements:
    x I want restarting applications to be side-effect-free, which means all undo/redo stacks must be persistent.
    x Applications/UI designers should have great flexibility in deciding on undo behaviour:
      - Making selections in a graphics editor is either included in the undo stack or not, depending on the app developer's choice
      - navigation (switching to a different section of the app) is either included in the undo stack or not, depending on the app developer's choice
        (e.g. Lightroom includes switching between tabs in its undo stack)
    x Support scenarios where subsections of a persistent root have their own undo stack
      (in IDE's like Xcode or Eclipse, each source file has its own undo stack. If the project is one persistent root, and each class/file within the
       project is just an embedded object, we need to implement separate undo/redo stacks for each file somehow)
       => Working & tested, see TestHistoryTrack.m
    x Support scenarios where an application can edit several persistent root, and unify the edits into a single undo/redo stack
      (e.g., an object manager editing the names of different persistent roots. The CoreObject version of a filename is stored in the
       root embedded object of a persistent root). 
       => Working, need to write a test for this use case
    x selective undoing your commits in a collaborative editing scenario
       => Should work with no further effort, sort of demonstrated by TestHistoryTrack.m
    x support undo/redo of branch/delete branch, create persistent root/delete persistent root, revert to old revision (if app desires)
       => Working & tested, see TestUndo.m
    x want to be able to tell whether a branch creation came before or after a commit. Timestamps may not be enough if commits are made in a loop
      This was why the earlier CoreObject used revision numbers for both undo/redo actions and regular commits.
       => COUndoStackStore stores edits in the order they are added, which satisfies this requirement.
  - Implementation ideas:
    x Reintroduce something like COCustomTrack which dynamically switches from
      navigational undo/redo to selective undo/redo. This should be sufficient
      to implement undo/redo for collaboration where the undo/redo commands only
      affect your own actions, as well as undo/redo for applications
       => implemented in COEditSetCurrentVersionForBranch
    - Reintroduce something like COHistoryTrack which allows undo/redo on subsets of a persistent root using selective undo
      => dynamically grouping edits isn't interesting imho. the current system satisfies what I wanted to achieve with COHistoryTrack anyway
    - custom track that tracks all changes made to store (like in cambridge typewriter demo)
      => after some thought it doesn't really make sense to automatically add
         edits to an undo stack. I decided that pushing an edit on the undo stack should
         only be done when the user is actively making a change in an application, in which case it's up to the 
         app policy to decide which stack (if any). Also edits should only be pushed onto a single stack.


- Oject copy model easy to extend in COObject subclasses (see COObject and COEditingContext copy methods)
  - Finish COCopier
  - Support another reference type for copy: NOT a composite reference, but acts like one for the pruposes of copy. see the copy keynote, and the yellow arrows
    => 2013-08-13: Discussed with Quentin and we decided this is probably not so important
  - Maybe need an "isShared" flag related to whether an object is copied when things that refer to it are copied.
    I need to understand the use case a bit more

- Metamodel
  - Add checks that derived properties are not persistent
  - Add check that parent property (isContainer = YES) is derived
  - Add check that one side of an opposite is derived
  - Review other constraints
  - Add a check that the derived side of a multivalued opposite is unordered
  - Add an "indexed" flag to ETPropertyDescription to tell the store whether to include values of that property in search indexes
  - Move to CoreObject
  - It scans over every loaded ObjC class, this is really slow and should be removed

- COObject
  x Remove support for freestanding COObject not associated with a COObjectGraphContext,
    and remove -becomePersistentInContext:. The rationale was that freestanding
    COObjects would only make sense if they have no relationships. Since relationships
    are such a central feature we might as well force COObjects to belong to a
    COObjectGraphContext
  - Attempting to set a value for a readonly property should raise an exception
  - Check COObject KVO semantics and documentation
  - See if we can get rid of all of the properties that only make sense for root objects.
    Maybe have a convention that the root embedded object is a subtype of COObject that
    has all of these properties. If we want to make an arbitrary object a root object, 
    we would actually make it a child of the real/wrapper root obejct with all of the
    root object metadata.
  - Clean out legacy code
  - We should have dedicated array/set multivalue mutation methods rather than using:
    -[COObject (void)insertObject: (id)object atIndex: (NSUInteger)index hint: (id)hint forProperty: (NSString *)key]
    for both, IMO (Eric)
  WIP Rather than dynamic subclassing which is flawed/broken (it's impossible to interact cleanly with KVO or other users of dynamic subclassing),
    synthesize accessors for properties when the app developer has made a subclass and marked the property @dynamic. Either using +resolveInstanceMethod
    or some earlier time when the metamodel/class are registered.
  - Use NSSortedSet for sorted composite relationships
  - Use weak references to other COObject instances to prevent retain cycles
  - Variable storage, relationship cache, relationship integrity implementations
    are a mess and need to be rewritten. The variable storage is very
    inefficient (makes mutable copy of collection even when using mutable
    colelction mutation method, so n inserts in O(n^2).), which must be fixed.

- COItem
  - tidy up ugly NSMutableDictionary / NSDictionary casting

- COSQLiteStore
  - Use change count for notifications. Make all mutations increment count.
  - Actually use NSError
  - Record in COPersistentRootInfo a copySource that records the persistent root UUID a cheap copy was made from (or just a flag, isCopy?)
	- To avoid bloating the store API, just store this in the root embedded object with the other metadata
  - Force api users to pass in COPersistentRootInfo to all mutation methods?
  - Switch to batch style api?
  - Add "parent branch" metadata to a branch that records which branch a branch was forked from?
  - For recording merges, the merged parent needs to be known when we gc commits.

- Make COQuery a bit more usable
- Switch to NSUUID

Future Work
-----------

- Switch from FMDB to an SQL abstraction backend 

- Implement Collaboration support (based on COSynchronizer and XMPP)
- Tune object copy model to respect user expectations about copy/paste in various recurrent use cases
- Improve Relationship Integrity and leverage it in more places (e.g. copy time, more aggressive checks or object graph integrity checking in a background thread etc.)
- Improve metamodel checker to ensure matching Objective-C property types (e.g. a ETCollection must be declared as multivalued, a NSArray as ordered)
- Evaluate a CORevision cache per COStore or process
- Evaluate a COTrackNode cache per track

x Figure out how to navigate large root object sets very quickly (evaluate writing a COSQLCursor class)/
  How to scroll smoothly through 50 000 root objects in an Object Manager without loading all the objects in memory?
  - I think we more or less have this figured out


Missing Features
----------------

- Schema Upgrade
- NSPredicate to SQL generator using OMeta
- Import/Export


Open Questions
--------------

- Adjust COEditingContext loaded object cache to use a strategy that matches which root objects are going to be accessed recurrently (e.g. photos in a Photo Manager should have priority over other root objects)
- Write a COSQLCursor that can load root objects in advance
- Just minimize the apparent loading time at the UI level (and no other optimizations possibly)
- Use an object pool mechanism to allocate COObject or subclass instances
- Allocate special fault objects that support some basic properties (e.g. -name) and retrieve their values from a single query against the store (e.g. multiples root object names a in single query)
