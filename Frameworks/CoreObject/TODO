TODO
====

First Release
-------------

- Tests
  - Pass all tests, including all from NestedVersioning, rewriting them where needed.
  x Test JSON serialization

- COEditingContext / COPersistentRoot / COBranch
  - support for loading the root object of a persistent root as a fault
  - asychronous loading of persistent root contents / unfaulting faulted root object
  - full support for cross-persistent root references
    - handle persistent roots unloading
    x handle the current branch being changed, and references to the current branch
      get updated
    x handle the specific branch referenced being deleted
      (the references should disappear if in a collection, or become null if
      not multivalued)
    - all other corner cases in TestCrossPersistentRootReferences.m
  x support for having multiple branches of a persistent root loaded into memory at once
  x batching persistent root mutations (revert current revision for branch to old revision,
    change main branch, change branch metadata, etc.) rather than committing them immediately
  x add method to get all persistent roots
  x Use notifications posted by COSQLiteStore (very basic support)
    - complete support
    - full set of test cases
    - think of all corner cases
  x add -insertNewPersistentWithObjectGraphContext: method
  - support "transient roots" in a COEditingContext. These are COObjectGraphContext wrappers.
    Or, support creating a persistent root in code, then calling "freeze" which will make it 
    read-only and prevent it from being committed to disk?
  x expose COSQLiteStore's undelete method
  x expose COSQLiteStore branch deletion / undeletion
  - choose between -[COEditingContext deletePersistentRoot:]/-[COEditingContext undeletePersistentRoot:]
    and COPersistentRoot's isDeleted property
  - choose between -[COPersistentRoot deleteBranch:]/-[COPersistentRoot undeleteBranch:]
    and COBranch's isDeleted property
  - make deleted persistent roots read-only?
  - expose COSQLiteStore's finalize deletion method
  - (aesthetic) decide to what extent COPersistentRoot, COBranch should
    provide convenience methods that deletate to the COObjectGraphContext:
      [[(COPersistentRoot *)self editingBranch] objectGraphContext]
      
    e.g. I think we should surely keep:
     -[COPersistentRoot rootObject] = { return [[self editingBranch] rootObject]; }
     -[COBranch rootObject] = { return [[self objectGraphContext] rootObject]; }
     
    All of the other methods, I don't know.
  - Extend COBranch API to support branches and merging revisions accross tracks
  - Expose COSQLiteStore's attachments feature
  x Document COBranch class

- didAwaken: replacement
    - At the end of the setStoreItem:, call -awakeFromDeserialization
    - At the end of object graph loading, -didLoadObjectGraph on each object in topological sort order

- Improve diff/merge API and code
  - Improve Merging (move detection and custom attributed string merger)
  - Need to support persisted partial merge resolutions.
    - Thought about this a bit. I don't think we can provide it in general in the framework,
      apps will have to implement support for it.
      
      Some apps may want to open a temporary persistent root, with its own
      metamodel for managing the merge, others may want to do it only in memory.
      
      Also, though the diff/merge happens at the persistent root granularity,
      there may be multiple embedded object trees with different merge UI's.
      (e.g. several types of objects on a canvas in a composite documents)
  - Build an example app with a merging UI


- Implement application-level undo/redo support
  - Requirements:
    - I want restarting applications to be side-effect-free, which means all undo/redo stacks must be persistent.
    - Applications/UI designers should have great flexibility in deciding on undo behaviour:
      - Making selections in a graphics editor is either included in the undo stack or not, depending on the app developer's choice
      - navigation (switching to a different section of the app) is either included in the undo stack or not, depending on the app developer's choice
        (e.g. Lightroom includes switching between tabs in its undo stack)
    - Support scenarios where subsections of a persistent root have their own undo stack
      (in IDE's like Xcode or Eclipse, each source file has its own undo stack. If the project is one persistent root, and each class/file within the
       project is just an embedded object, we need to implement separate undo/redo stacks for each file somehow)
    - Support scenarios where an application can edit several persistent root, and unify the edits into a single undo/redo stack
      (e.g., an object manager editing the names of different persistent roots. The CoreObject version of a filename is stored in the
       root embedded object of a persistent root)
    - selective undoing your commits in a collaborative editing scenario
    - support undo/redo of branch/delete branch, create persistent root/delete persistent root, revert to old revision (if app desires)

- Work out clear and well documented object copy model easy to extend in COObject subclasses (see COObject and COEditingContext copy methods)
  - Finish COCopier
  - Support another reference type for copy: NOT a composite reference, but acts like one for the pruposes of copy. see the copy keynote, and the yellow arrows

- Metamodel
  - Add checks that derived properties are not persistent
  - Add check that parent property (isContainer = YES) is derived
  - Add check that one side of an opposite is derived
  - Review other constraints
  - Add a check that the derived side of a multivalued opposite is unordered
  - Add an "indexed" flag to ETPropertyDescription to tell the store whether to include values of that property in search indexes
  - Move to CoreObject
  - It scans over every loaded ObjC class, this is really slow and should be removed

- COObject
  x Remove support for freestanding COObject not associated with a COObjectGraphContext,
    and remove -becomePersistentInContext:. The rationale was that freestanding
    COObjects would only make sense if they have no relationships. Since relationships
    are such a central feature we might as well force COObjects to belong to a
    COObjectGraphContext
  - Attempting to set a value for a readonly property should raise an exception
  - Check COObject KVO semantics and documentation
  - See if we can get rid of all of the properties that only make sense for root objects.
    Maybe have a convention that the root embedded object is a subtype of COObject that
    has all of these properties. If we want to make an arbitrary object a root object, 
    we would actually make it a child of the real/wrapper root obejct with all of the
    root object metadata.
  - Clean out legacy code
  - We should have dedicated array/set multivalue mutation methods rather than using:
    -[COObject (void)insertObject: (id)object atIndex: (NSUInteger)index hint: (id)hint forProperty: (NSString *)key]
    for both, IMO (Eric)
  WIP I'd like to look at generating COObject subclasses for each entity description with 
    generated KVC compliant property accessors and mutators. (Eric)
  - Use NSSortedSet for sorted composite relationships
  - Use weak references to other COObject instances to prevent retain cycles
  - Variable storage, relationship cache, relationship integrity implementations
    are a mess and need to be rewritten. The variable storage is very
    inefficient (makes mutable copy of collection even when using mutable
    colelction mutation method, so n inserts in O(n^2).), which must be fixed.

- COItem
  - tidy up ugly NSMutableDictionary / NSDictionary casting

- COSQLiteStore
  - Use change count for notifications. Make all mutations increment count.
  - Actually use NSError
  - Record in COPersistentRootInfo a copySource that records the persistent root UUID a cheap copy was made from (or just a flag, isCopy?)
	- To avoid bloating the store API, just store this in the root embedded object with the other metadata
  - Force api users to pass in COPersistentRootInfo to all mutation methods?
  - Switch to batch style api?
  - Add "parent branch" metadata to a branch that records which branch a branch was forked from?
  - The metadata: param of -createPersistentRoot is currently unused. Should it set the branch metadata? Initial revision metadata? Remove it or add separate branch/revision metadata params?
  

- Rewrite COHistoryTrack
- Fix COCustomTrack broken model
- Make COQuery a bit more usable
- Switch to NSUUID

x Check relationship integrity won't go against the developer needs
x Implement deletion support in COStore, COObject and COEditingContext


Future Work
-----------

- Switch from FMDB to an SQL abstraction backend 

- Implement Collaboration support (based on COSynchronizer and XMPP)
- Figure out basic undo/redo support on an object edited collaboratively, probably using selective undo
- Tune object copy model to respect user expectations about copy/paste in various recurrent use cases
- Improve Relationship Integrity and leverage it in more places (e.g. copy time, more aggressive checks or object graph integrity checking in a background thread etc.)
- Improve metamodel checker to ensure matching Objective-C property types (e.g. a ETCollection must be declared as multivalued, a NSArray as ordered)
- Evaluate a CORevision cache per COStore or process
- Evaluate a COTrackNode cache per track

x Adopt or leverage NestedVersioning improvements to the property list serialization model
x Figure out how to navigate large root object sets very quickly (evaluate writing a COSQLCursor class)/
  How to scroll smoothly through 50 000 root objects in an Object Manager without loading all the objects in memory?
  - I think we more or less have this figured out


Missing Features
----------------

- Schema Upgrade
- NSPredicate to SQL generator using OMeta
- Import/Export

x History Compaction
x Attachments to track imported files without importing all the data in the store (e.g. a photo or a song)


Open Questions
--------------

- Adjust COEditingContext loaded object cache to use a strategy that matches which root objects are going to be accessed recurrently (e.g. photos in a Photo Manager should have priority over other root objects)
- Write a COSQLCursor that can load root objects in advance
- Just minimize the apparent loading time at the UI level (and no other optimizations possibly)
- Use an object pool mechanism to allocate COObject or subclass instances
- Allocate special fault objects that support some basic properties (e.g. -name) and retrieve their values from a single query against the store (e.g. multiples root object names a in single query)
